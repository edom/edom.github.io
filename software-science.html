<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Towards software science</title>
        <link rel="stylesheet" href="/assets/main.css"/>
        <script>
// Help the reader estimate how much time the reading is going to take.
// Show word count and reading time estimation in TOC entry.
//
// TOC = table of contents
//
// Known issue: This janks: this DOM manipulation is done after the page is rendered.
// If we don't want jank, we have to manipulate the HTML source before it reaches the browser.
// We assume that the user doesn't refresh the page while reading.
// The benefit of fixing that jank is not enough for me to justify trying to fix it.
document.addEventListener("DOMContentLoaded", function () {
    function count_word (string) {
        return string.trim().split(/\s+/).length;
    }
    function show_quantity (count, singular) {
        let plural = singular + "s"; // For this script only.
        return count + " " + ((count == 1) ? singular : plural);
    }
    function create_length_indicator (word, minute) {
        let e = document.createElement("span");
        e.className = "toc_entry__length_indicator";
        e.textContent = " (" + show_quantity(word, "word") + " ~ " + show_quantity(minute, "minute") + ")";
        return e;
    }
    // We assume that readers read this many words per minute with 100% comprehension.
    // This assumption may not hold for dense texts such as philosophy and mathematics.
    const wpm_assumption = 200;
    // We assume a certain Jekyll template.
    let page = document.querySelector("main.page-content");
    if (page === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"main.page-content\" does not match anything");
        return;
    }
    let page_title = document.querySelector("header.post-header h1.post-title");
    if (page_title === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"header.post-header h1.post-title\" does not match anything");
        return;
    }
    let page_word = count_word(page.textContent);
    let page_minute = Math.ceil(page_word / wpm_assumption);
    page_title.insertAdjacentElement("afterend", create_length_indicator(page_word, page_minute));
    // We violate the HTML specification.
    // The page may have several elements with the same ID.
    // We assume that Org HTML Export generates a DIV element with ID "table-of-contents".
    // We assume that Jekyll Markdown-to-HTML generates a UL element with ID "markdown-toc".
    // This only works for Org HTML Export's TOC.
    let toc_entries = document.querySelectorAll("#table-of-contents a, #text-table-of-contents a");
    toc_entries.forEach((toc_entry_a) => {
        let href = toc_entry_a.getAttribute("href"); // We assume that this is a string like "#org0123456".
        if (href.charAt(0) !== '#') {
            console.log("toc_generate_estimate: Impossible: " + href + " does not begin with hash sign");
            return;
        }
        // We can't just document.querySelector(href) because target_id may contain invalid ID characters such as periods.
        let target_id = href.substring(1);
        let id_escaped = target_id.replace("\"", "\\\"");
        let h_elem = document.querySelector("[id=\"" + id_escaped + "\"]"); // We assume that this is the h1/h2/h3 element referred by the TOC entry.
        if (h_elem === null) { // We assume that this is impossible.
            console.log("toc_generate_estimate: Impossible: " + href + " does not refer to anything");
            return;
        }
        let section = h_elem.parentNode;
        let section_word = count_word(section.textContent);
        let section_minute = Math.ceil(section_word / wpm_assumption);
        toc_entry_a.insertAdjacentElement("afterend", create_length_indicator(section_word, section_minute));
    });
});
        </script>

        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12628443-6"></script>
<script>
  window['ga-disable-UA-12628443-6'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-12628443-6');
</script>
        
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            jax: ["input/TeX","input/MathML","input/AsciiMath",
            "output/CommonHTML"
            ],
            extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "a11y/accessibility-menu.js"],
            TeX: {
                extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
                , equationNumbers: {
                    autoNumber: "AMS"
                }
            },
            "CommonHTML": {
                scale: 100
            },
            "fast-preview": {
                disabled: true,
            }
        });
        </script>
        <style>
            /*
            PreviewHTML produces small Times New Roman text.
            PreviewHTML scale doesn't work.
            */
            .MathJax_PHTML { font-size: 110%; }
        </style>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js" async defer></script>
    </head>
    <body>
        <header class="site-header" role="banner">
            <div class="wrapper">
                <a class="site-title" rel="author" href="/">Erik Dominikus Research Group</a>
            </div>
        </header>
    <div style="display:none;">\(
    \renewcommand\emptyset{\varnothing}
    \newcommand\abs[1]{\left|#1\right|}
    \newcommand\dom{\textrm{dom}}
    \newcommand\cod{\textrm{cod}}
    \newcommand\Bernoulli{\textrm{Bernoulli}}
    \newcommand\Binomial{\textrm{Binomial}}
    \newcommand\Expect[1]{\mathbb{E}[#1]}
    \newcommand\Nat{\mathbb{N}}
    \newcommand\Integers{\mathbb{Z}}
    \newcommand\Real{\mathbb{R}}
    \newcommand\Rational{\mathbb{Q}}
    \newcommand\Complex{\mathbb{C}}
    \newcommand\Pr{\mathrm{P}}
    \newcommand\Time{\text{Time}}
    \newcommand\DTime{\text{DTime}}
    \newcommand\NTime{\text{NTime}}
    \newcommand\TimeP{\text{P}}
    \newcommand\TimeNP{\text{NP}}
    \newcommand\TimeExp{\text{ExpTime}}
    \newcommand\norm[1]{\left\lVert#1\right\rVert}
    \newcommand\bbA{\mathbb{A}}
    \newcommand\bbC{\mathbb{C}}
    \newcommand\bbD{\mathbb{D}}
    \newcommand\bbE{\mathbb{E}}
    \newcommand\bbN{\mathbb{N}}
    \newcommand\frakI{\mathfrak{I}}
    % deprecated; use TimeExp
    \newcommand\ExpTime{\text{ExpTime}}
    \newcommand\Compute{\text{Compute}}
    \newcommand\Search{\text{Search}}
    % model theory structure
    \newcommand\struc[1]{\mathcal{#1}}
    \newcommand\SetBuilder[2]{\{#1 ~|~ #2\}}
    \newcommand\Set[1]{\{#1\}}
    \newcommand\semantics[1]{\langle #1 \rangle}
    \newcommand\bigsemantics[1]{S\left(#1\right)}
    \)</div>
        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
                    <header class="post-header">
                        <h1 class="post-title">Towards software science</h1>
                    </header>
                </article>
                <div class="post-content">
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1</span><span class="section_title"><a href="#introduction"><span class="todo TODO">TODO</span> Introduction?</a></span><span class="word_count">(16w~1m)</span></li>
<li><span class="section_number">2</span><span class="section_title"><a href="#software">Software</a></span><span class="word_count">(904w~5m)</span></li>
<li><span class="section_number">3</span><span class="section_title"><a href="#hardness-pure-hardware-pure-software-and-mixtures">Hardness: pure hardware, pure software, and mixtures</a></span><span class="word_count">(142w~1m)</span></li>
<li><span class="section_number">4</span><span class="section_title"><a href="#words-invented-or-discovered">Words: Invented or discovered?</a></span><span class="word_count">(172w~1m)</span></li>
<li><span class="section_number">5</span><span class="section_title"><a href="#computer-science-terms">Computer science terms?</a></span><span class="word_count">(1119w~6m)</span></li>
<li><span class="section_number">6</span><span class="section_title"><a href="#language">Language</a></span><span class="word_count">(116w~1m)</span></li>
<li><span class="section_number">7</span><span class="section_title"><a href="#software-science">Software science</a></span><span class="word_count">(707w~4m)</span></li>
<li><span class="section_number">8</span><span class="section_title"><a href="#subfields-of-software-science">Subfields of software science?</a></span><span class="word_count">(851w~5m)</span></li>
<li><span class="section_number">9</span><span class="section_title"><a href="#logic">Logic</a></span><span class="word_count">(9w~1m)</span></li>
<li><span class="section_number">10</span><span class="section_title"><a href="#how-do-we-write-correct-software">How do we write correct software?</a></span><span class="word_count">(768w~4m)</span></li>
<li><span class="section_number">11</span><span class="section_title"><a href="#why-does-software-have-security-holes">Why does software have security holes?</a></span><span class="word_count">(97w~1m)</span></li>
</ul>
</div>
<h2 id="introduction"><span class="section_number">1</span><span class="section_title"><span class="todo TODO">TODO</span> Introduction?</span></h2>
<p>It would be nice if software engineering had predictive theories like Newton's laws of motion.</p>
<h2 id="software"><span class="section_number">2</span><span class="section_title">Software</span></h2>
<p>What do we mean by &quot;software&quot;?</p>
<p>We need an ontology.</p>
<p>Software science is a study of software. But what is software?</p>
<p>Terms to define and relate: hardware, software, computer, machine, calculator, program, code, language, programmable, error, mistake, bug, fault, malfunction.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">2.1</span><span class="section_title"><a href="#etymology-of-software-and-other-related-words">Etymology of &quot;software&quot; and other related words</a></span><span class="word_count">(67w~1m)</span></li>
<li><span class="section_number">2.2</span><span class="section_title"><a href="#english-sometimes-hampers-thought">English sometimes hampers thought</a></span><span class="word_count">(84w~1m)</span></li>
<li><span class="section_number">2.3</span><span class="section_title"><a href="#mereology-of-computers">Mereology of computers</a></span><span class="word_count">(224w~2m)</span></li>
<li><span class="section_number">2.4</span><span class="section_title"><a href="#hardware-dancers-and-platonism">Hardware, dancers, and Platonism</a></span><span class="word_count">(290w~2m)</span></li>
<li><span class="section_number">2.5</span><span class="section_title"><a href="#hardware-software"><span class="todo TODO">TODO</span> Hardware, software</a></span><span class="word_count">(72w~1m)</span></li>
<li><span class="section_number">2.6</span><span class="section_title"><a href="#computer-vs-running-computer">Computer vs running computer</a></span><span class="word_count">(12w~1m)</span></li>
<li><span class="section_number">2.7</span><span class="section_title"><a href="#examples-of-software">Examples of software</a></span><span class="word_count">(19w~1m)</span></li>
<li><span class="section_number">2.8</span><span class="section_title"><a href="#programs">Programs?</a></span><span class="word_count">(65w~1m)</span></li>
<li><span class="section_number">2.9</span><span class="section_title"><a href="#properties-of-software">Properties of software</a></span><span class="word_count">(43w~1m)</span></li>
</ul>
</div>
<h3 id="etymology-of-software-and-other-related-words"><span class="section_number">2.1</span><span class="section_title">Etymology of &quot;software&quot; and other related words</span></h3>
<p>The word &quot;software&quot; appeared no later than Tukey 1958,<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> and by it he meant the same thing that most people mean by &quot;software&quot; in 2019, that is, the intangible-but-vital choreography inside computers that makes them useful.</p>
<p>The word &quot;hardware&quot; appeared no later than the 15th century in which it meant &quot;small metal goods&quot;. The phrase &quot;hardware store&quot; appeared no later than 1789.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<h3 id="english-sometimes-hampers-thought"><span class="section_number">2.2</span><span class="section_title">English sometimes hampers thought</span></h3>
<p>The word &quot;software&quot; is a mass noun, which is uncountable. When one write &quot;a software&quot;, one usually means to write &quot;a program&quot; instead.</p>
<p>If we can list something, then it is described by a countable noun. There are abstract countable nouns, such as &quot;invitation&quot;, &quot;friend&quot;, &quot;failure&quot;, and &quot;achievement&quot;. There are concrete uncountable nouns, such as &quot;water&quot;.</p>
<p>We simply accept this syntactic idiosyncrasy as the cost of using English. This is a trivial syntactic inconvenience. Let us move on to more important semantic issues.</p>
<h3 id="mereology-of-computers"><span class="section_number">2.3</span><span class="section_title">Mereology of computers</span></h3>
<p>&quot;Software&quot; and &quot;hardware&quot; are <em>disjoint</em> categories: If something is software, it is not hardware; if something is hardware, it is not software.</p>
<p>A computer is the sum of its hardware and its software. A computer consists of its hardware, its software, and nothing else.</p>
<p>Thus, by the lone unqualified word &quot;software&quot; on its own, we actually mean &quot;the <em>software part</em> of all computers&quot;. Thus &quot;software&quot; is like &quot;water&quot;: By saying &quot;water exists&quot;, we actually mean &quot;there exists an object that has the properties of water&quot;.</p>
<p>But software is not purely abstract: It is stored in hardware as an arrangement of materials. But is that software or a <em>representation</em> of software?</p>
<p>What other things can be analyzed as a sum of hardware and software? Laws, choreographies, recipes.</p>
<p>A <em>software house</em> is a company that makes software.</p>
<p>Why &quot;hardware <em>store</em>&quot; but &quot;software <em>house</em>&quot;? A software house is more like a blacksmith's workshop than a hardware store: Things can be <em>made-to-order</em> in a blacksmith's workshop but not in a hardware store. Like &quot;production house&quot; for movies.</p>
<p><em>Hardware bridges software and reality.</em></p>
<p>A piece of hardware is a concrete object that can be controlled by an abstract object (a piece of software).</p>
<p>Software is an arrangement of matter (hardware) that makes the hardware useful. But must software have any purpose?</p>
<p>Examples of programming: Designing mechanical linkages. We arrange matter so that it does something we want.</p>
<h3 id="hardware-dancers-and-platonism"><span class="section_number">2.4</span><span class="section_title">Hardware, dancers, and Platonism</span></h3>
<p>Software is to hardware as choreography is to dancers. Indeed choreographies <em>are</em> software. Choreographies without dancers are dead ideas. Dancers without choreographies are useless matter.</p>
<p>The dancers are the hardware, the choreography is the software, and the entire performance is the running computer.</p>
<p>I'll be a Platonist here.</p>
<p>A drawing in dance notation<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> on a paper is a <em>representation</em> of several closely-related choreographies, and is not itself a choreography. The choreographies described by that notation are abstract objects with eternal existence in idea space. If the paper is destroyed, the choreographies persist; for example, the choreographies may be represented in the memories of dancers. Even if there are no people to discover them, the choreographies still exists in idea space.</p>
<p>A drawing cannot practically describe exactly one choreography, because there will always be a slightly different choreography in which the practical means of drawing does not have sufficient fidelity/resolution to describe the difference. For example, suppose that choreography Y is the same as choreography X but with the hand shifted 1 micrometer to the right. It is practically impossible to distinguish X and Y, because it is practically impossible to perceptibly move the hand with micrometer precision.</p>
<p>Thus there be the question: Are ideas discovered or invented? If I invent a word to mean something new, the concept that I mean with that word already exists in idea space. Thus, a Platonist would say that words are invented and concepts are discovered. Thus, for example, when Newton invented calculus, he invented words and notations for concepts that have always existed but not yet known by many people. The concept of derivatives has always existed, but the word &quot;derivative&quot; did not exist before humans existed.</p>
<p><em>How do we test Platonism?</em> Is it even falsifiable?</p>
<h3 id="hardware-software"><span class="section_number">2.5</span><span class="section_title"><span class="todo TODO">TODO</span> Hardware, software</span></h3>
<p>The choreography is the software. The dancer is the hardware.</p>
<p>The recipe is the software. The paper is a representation of the recipe, but not the recipe itself. You can tell the recipe to your friend, without paper. The cook is the hardware.</p>
<p>The music score is the software. The performers are the hardware.</p>
<p>The law is the software. People in government is the hardware.</p>
<p>Software is choreography of hardware. Software is an arrangement.</p>
<h3 id="computer-vs-running-computer"><span class="section_number">2.6</span><span class="section_title">Computer vs running computer</span></h3>
<p>A computer has software, but is the computer running?</p>
<h3 id="examples-of-software"><span class="section_number">2.7</span><span class="section_title">Examples of software</span></h3>
<p>Programs, laws, choreographies, and recipes are software.</p>
<p>Minds are software?</p>
<p>Software has existed for millenniums, although not called &quot;software&quot;.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<h3 id="programs"><span class="section_number">2.8</span><span class="section_title">Programs?</span></h3>
<p>Programs used to mean &quot;public notice&quot;.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> Authorities wrote programs to inform the public so that people behave accordingly.</p>
<p>What is programming? Programming is forcing. X programs Y to do Z iff X forces Y to do Z.</p>
<p>What can be programmed? People are programmable to some extent. We program people when we ask them to do something. Software development process itself is also programmable to some extent.</p>
<h3 id="properties-of-software"><span class="section_number">2.9</span><span class="section_title">Properties of software</span></h3>
<p>Software can be copied, but not moved like a concrete object such as a car.</p>
<p>Software is an arrangement of matter (hardware).</p>
<p>Software is executable abstract object?</p>
<p>Software is program, documents, configuration, and so on.</p>
<p>Software is abstract object.</p>
<p>Software is executable mathematics.</p>
<p>Software is an idea.</p>
<h2 id="hardness-pure-hardware-pure-software-and-mixtures"><span class="section_number">3</span><span class="section_title">Hardness: pure hardware, pure software, and mixtures</span></h2>
<p>If a computer is a mixture of hardware and software, then it makes sense to ask next: <em>How much</em> of it is hardware, and how much of it is software?</p>
<p>We define the <em>hardness</em> of a system as the proportion of it that is hardware.</p>
<p>An example of a pure-hardware system is a mechanical linkage or a salt crystal.</p>
<p>An example of a pure-software system is a mathematical equation or an algorithm.</p>
<p>An example of a mixed hardware-software system is a computer running a program.</p>
<p>If 2 unit of pure hardware is mixed with 8 unit of pure software, then the result should be a 10-unit 20%-hardness system.</p>
<p>The question is: What is that <em>unit</em>?</p>
<p>Does upgrading the hardware of a computer increase its hardness, because upgrading hardware implies adding hardware mass?</p>
<p>Mass is a unit of hardware.</p>
<p>Formula length is a unit of software.</p>
<h2 id="words-invented-or-discovered"><span class="section_number">4</span><span class="section_title">Words: Invented or discovered?</span></h2>
<p><em>Neologisms</em><a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> prove that words can be <em>invented</em>, such as &quot;grok&quot;, &quot;quark&quot;, &quot;bromance&quot;, and &quot;brexit&quot;. But words can also be <em>discovered</em>. For example, Heinlein invented &quot;grok&quot;<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>, but I discovered it through someone who has read his writing.</p>
<p>But what do we mean by saying that <em>a word exists</em>? If we say that words are invented, then words are not abstract objects in idea space? But a word is not a concrete object, and thus it must be an abstract object. But must it? What if we declare three categories of being instead: concrete objects, abstract objects, and names? Or, can abstract objects be invented?</p>
<p>Plato's Forms are abstract objects, but they are eternal.</p>
<p>Can abstract objects be non-eternal?</p>
<p>Does an idea exist if there is no one to think of it?</p>
<p>But a concept has to be named before it can be thought about and communicated. The name is invented, but the concept is discovered. Thus one job of philosophers is to <em>pick names</em> for concepts that may be important but cannot yet be communicated.</p>
<h2 id="computer-science-terms"><span class="section_number">5</span><span class="section_title">Computer science terms?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">5.1</span><span class="section_title"><a href="#tools-and-machines">Tools and machines</a></span><span class="word_count">(52w~1m)</span></li>
<li><span class="section_number">5.2</span><span class="section_title"><a href="#what-does-it-mean-for-a-machine-to-compute-a-real-number">What does it mean for a machine to compute a real number?</a></span><span class="word_count">(252w~2m)</span></li>
<li><span class="section_number">5.3</span><span class="section_title"><a href="#algorithm-machine-describability-computability">Algorithm, machine, describability, computability</a></span><span class="word_count">(302w~2m)</span></li>
<li><span class="section_number">5.4</span><span class="section_title"><a href="#what-it-means-for-an-algorithm-to-compute-a-function">What it means for an algorithm to compute a function</a></span><span class="word_count">(31w~1m)</span></li>
<li><span class="section_number">5.5</span><span class="section_title"><a href="#machine-algorithm-embodiment-computation">Machine, algorithm, embodiment, computation</a></span><span class="word_count">(48w~1m)</span></li>
<li><span class="section_number">5.6</span><span class="section_title"><a href="#what-is-software">What is software?</a></span><span class="word_count">(25w~1m)</span></li>
<li><span class="section_number">5.7</span><span class="section_title"><a href="#the-dualistic-nature-of-machines-the-machine-program-dualism-the-hardware-software-dualism">The dualistic nature of machines; the machine-program dualism; the hardware-software dualism</a></span><span class="word_count">(39w~1m)</span></li>
<li><span class="section_number">5.8</span><span class="section_title"><a href="#move-this-somewhere-else-hierarchy-of-machines"><span class="todo TODO">TODO</span> Move this somewhere else: Hierarchy of machines</a></span><span class="word_count">(91w~1m)</span></li>
<li><span class="section_number">5.9</span><span class="section_title"><a href="#what-do-we-mean-by-programmable">What do we mean by &quot;programmable&quot;?</a></span><span class="word_count">(139w~1m)</span></li>
<li><span class="section_number">5.10</span><span class="section_title"><a href="#what-is-a-tool">What is a tool?</a></span><span class="word_count">(66w~1m)</span></li>
<li><span class="section_number">5.11</span><span class="section_title"><a href="#software-and-electricity-running-computers-vs-non-running-computers">Software and electricity; running computers vs non-running computers</a></span><span class="word_count">(46w~1m)</span></li>
<li><span class="section_number">5.12</span><span class="section_title"><a href="#should-we-define-ones-self-as-the-set-of-all-things-he-can-control">Should we define one's &quot;self&quot; as the set of all things he can control?</a></span><span class="word_count">(37w~1m)</span></li>
<li><span class="section_number">5.13</span><span class="section_title"><a href="#philosophy">Philosophy?</a></span><span class="word_count">(1w~1m)</span></li>
</ul>
</div>
<h3 id="tools-and-machines"><span class="section_number">5.1</span><span class="section_title">Tools and machines</span></h3>
<p>(I need to find the words to say this, and rewrite this more clearly.)</p>
<p>A <em>machine</em> is an <em>automatic tool</em>: it is a tool that runs by itself; it has its own behavior.</p>
<p>A hammer doesn't have its own behaviors. A car has its own behaviors. A computer has its own behaviors.</p>
<h3 id="what-does-it-mean-for-a-machine-to-compute-a-real-number"><span class="section_number">5.2</span><span class="section_title">What does it mean for a machine to compute a real number?</span></h3>
<p>Computation is approximate expression normalization. To <em>compute</em> a real number is to calculate some of its digits. To <em>compute</em> an arithmetic <em>expression</em> is to <em>evaluate</em> it (to reduce it into a <em>value</em>), often approximately. For example: 1/7 is an <em>expression</em>, and .142 is a <em>value</em> that is the 3 most significant digits of the result of <em>evaluating</em> that expression.</p>
<p>Why do we feel that 1.412 is <em>more evaluated</em> than <span class="math inline">\(\sqrt{2}\)</span>? Why do we feel that 1.412 is a <em>normal form</em>? Because it is <em>physically easier</em> for us to locate 1.412 on the real number line than to locate <span class="math inline">\(\sqrt{2}\)</span>. Thus to compute a real number is to <em>locate it</em> on the real number line. This justifies the geometric interpretation of real numbers.</p>
<p>We can <em>partially evaluate</em> an expression, such as from 1+2-1 to 3-1.</p>
<p>See also:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Human_computer">https://en.wikipedia.org/wiki/Human_computer</a></li>
</ul>
<p>Don't conflate a <em>real-number expression</em> and a <em>real number</em>. A real-number expression <em>evaluates</em> to a real number. A real-number expression <em>is not</em> a real number.</p>
<p>Let <span class="math inline">\(E(\Real)\)</span> be the set of all real-number expressions.</p>
<p>Let <span class="math inline">\(f:E(\Real)\to\Real\)</span> be the evaluation function.</p>
<p>Questions:</p>
<ul>
<li>What is the machine computing when I'm typing this document?</li>
<li>There are several ways of defining the real numbers. Which one should we use for the philosophy of mind and computation, and why?</li>
</ul>
<p>Algebraic-geometric definition: A <em>real number</em> is a <em>point</em> in the <em>totally-ordered</em> set of points in <em>one-dimensional</em> Euclidean geometry; the real numbers form a <em>field</em>.</p>
<p>Addition also has a geometric meaning: it is the set of points on the plane <span class="math inline">\(\{(x,y,z) ~\vert~ x+y=z\}\)</span>.</p>
<h3 id="algorithm-machine-describability-computability"><span class="section_number">5.3</span><span class="section_title">Algorithm, machine, describability, computability</span></h3>
<p>We assume that these are primitive concepts: algorithm, machine. By &quot;machine&quot;, we mean a computing machine.</p>
<p>An algorithm <em>describes</em> what a machine <em>computes</em>.</p>
<p>An <em>algorithm</em> is an <em>executable description</em>: a string in a formal language in a formal system. A description has <em>finite</em> length. By &quot;executable&quot;, we mean that an algorithm has a <em>machine model</em>. We always define an algorithm with respect to a machine.</p>
<p>Thus not every real number is <em>describable</em>, because there are fewer strings in that formal language than there are real numbers.</p>
<p>Thus not every real number is <em>computable</em>, because computability requires describability.</p>
<p>Remember that a <em>formal system</em> is a <em>formal language</em> and a set of <em>inference rules</em>.</p>
<ul>
<li><a href="https://cs.stackexchange.com/questions/42443/relationship-between-formal-system-and-formal-languages">https://cs.stackexchange.com/questions/42443/relationship-between-formal-system-and-formal-languages</a></li>
</ul>
<p>An algorithm is a string in a formal language <span class="math inline">\(L\)</span>. We <em>model</em> a <em>machine</em> as a <em>formal system</em> whose language is <span class="math inline">\(L\)</span>. The machine is not the formal system. The thing is not the model.</p>
<p><strong>What does it mean for a machine to <em>compute</em> a real number?</strong></p>
<p>Suppose that <span class="math inline">\(Y(T) \in \Real\)</span> is the <em>output</em> of the algorithm <span class="math inline">\(A\)</span> if we let the algorithm run for duration <span class="math inline">\(T \in \Nat\)</span>.</p>
<p>The algorithm <span class="math inline">\(A\)</span> <em>computes</em> the <em>limit</em> of the approximation sequence <span class="math inline">\( \langle Y(t) \rangle_{t \in \Nat} \)</span>. Thus &quot;<span class="math inline">\(A\)</span> computes real number <span class="math inline">\(R\)</span>&quot; means that the limit of that sequence is <span class="math inline">\(R\)</span>.</p>
<p>More explicitly, we say &quot;the algorithm <span class="math inline">\(A\)</span> <em>computes</em> the real number <span class="math inline">\(R\)</span>&quot; to mean: for every approximation error <span class="math inline">\(E &gt; 0\)</span> that we are willing to have, there exists a duration <span class="math inline">\(T \in \Nat\)</span> such that <span class="math inline">\(\abs{Y(T) - R} &lt; E\)</span>. Informally, the algorithm can always take more time to satisfy ever-diminishing (but still positive) approximation error.</p>
<p>A real number <span class="math inline">\(R\)</span> is <em>computable</em> iff there is an algorithm that computes <span class="math inline">\(R\)</span>.</p>
<p>There are as many natural numbers as there are algorithms. Therefore <em>not every real number is computable</em>, because there are fewer natural numbers than real numbers.</p>
<p>See also:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Limit_of_a_sequence">https://en.wikipedia.org/wiki/Limit_of_a_sequence</a></li>
</ul>
<h3 id="what-it-means-for-an-algorithm-to-compute-a-function"><span class="section_number">5.4</span><span class="section_title">What it means for an algorithm to compute a function</span></h3>
<p>The algorithm <span class="math inline">\(A\)</span> <em>computes</em> the function <span class="math inline">\(f : A \to B\)</span> iff for every input <span class="math inline">\(x \in A\)</span>, the algorithm outputs <span class="math inline">\(f(x)\)</span>.</p>
<h3 id="machine-algorithm-embodiment-computation"><span class="section_number">5.5</span><span class="section_title">Machine, algorithm, embodiment, computation</span></h3>
<p>A machine <em>embodies</em> an algorithm. A machine <em>computes</em> what the algorithm computes.</p>
<p>&quot;To <em>program</em> a machine to compute X&quot; is to <em>arrange</em> the machine to compute X, for example: rewire the machine, load another set of punch cards, write a program in a text editor, etc.</p>
<h3 id="what-is-software"><span class="section_number">5.6</span><span class="section_title">What is software?</span></h3>
<ul>
<li>Which ICSE paper said this?
<ul>
<li>Law is software.</li>
<li>Process is software.</li>
<li>Recipe is software.</li>
</ul></li>
<li>What is software?</li>
</ul>
<p>The source code is not the software. Don't commit reification fallacy.</p>
<h3 id="the-dualistic-nature-of-machines-the-machine-program-dualism-the-hardware-software-dualism"><span class="section_number">5.7</span><span class="section_title">The dualistic nature of machines; the machine-program dualism; the hardware-software dualism</span></h3>
<p>The hardware is the body. The software is the mind.</p>
<p>Are bits software <em>itself</em>, or are bits a <em>representation</em> (embodiment) of software?</p>
<p>A running machine embodies the software it is running?</p>
<h3 id="move-this-somewhere-else-hierarchy-of-machines"><span class="section_number">5.8</span><span class="section_title"><span class="todo TODO">TODO</span> Move this somewhere else: Hierarchy of machines</span></h3>
<ul>
<li>An FA (<em>finite automaton</em>) is …</li>
<li>An FSM (<em>finite-state machine</em>) is …</li>
<li>A <em>Turing-machine</em> is an FSM with infinite memory.
<ul>
<li><a href="https://en.wikipedia.org/wiki/Turing_machine#Formal_definition">WP:Turing machine, formal definition</a></li>
<li>Turing-completeness
<ul>
<li><a href="https://en.wikipedia.org/wiki/Turing_completeness">WP:Turing-completeness</a></li>
<li>A formal system is <em>Turing-complete</em> iff it can simulate every TM (Turing machine).
<ul>
<li>What does it mean to <em>simulate</em> a TM?</li>
</ul></li>
<li><a href="https://cstheory.stackexchange.com/questions/36863/formal-definition-of-turing-completeness">StackExchange CS theory 36863 formal definition of Turing-completeness</a>:
<ul>
<li>Kaveh suggested:
<ul>
<li><a href="https://www.sciencedirect.com/science/article/pii/S0049237X08712576">Robin Gandy: Church's Thesis and Principles for Mechanisms</a></li>
<li>Classical recursion theory volume 1</li>
</ul></li>
</ul></li>
</ul></li>
<li>Partial Turing machine, total Turing machine
<ul>
<li>What is the significance of the theorem in <a href="https://en.wikipedia.org/wiki/Total_Turing_machine">WP:Total Turing machine</a>?</li>
<li>What is the relationship between total function and total Turing machine?</li>
</ul></li>
</ul></li>
</ul>
<h3 id="what-do-we-mean-by-programmable"><span class="section_number">5.9</span><span class="section_title">What do we mean by &quot;programmable&quot;?</span></h3>
<p>Calculator vs programmable calculator.</p>
<p>From:<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a></p>
<blockquote>
<p>General sense of &quot;a definite plan or scheme&quot; is recorded from 1837. Meaning &quot;list of pieces at a concert, playbill&quot; first recorded 1805 and retains the original sense. That of &quot;objects or events suggested by music&quot; is from 1854. Sense of &quot;broadcasting presentation&quot; is from 1923. Computer sense (noun and verb) is from 1945.</p>
</blockquote>
<p>There is a confusion. Program can mean both an individual show<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> and the entire plan for a television station<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>.</p>
<p>To program something is to write a plan to be executed by that thing.</p>
<p>To run a program is to execute the plan.</p>
<p>Software does not have to be changeable. An example of practically unchangeable software is a program stored in a read-only memory (ROM) chip.</p>
<p>Is training a dog programming? I say yes. I'd even say that teaching a person is programming.</p>
<h3 id="what-is-a-tool"><span class="section_number">5.10</span><span class="section_title">What is a tool?</span></h3>
<p>Philosophically, a tool is something that extends the user's self (the set of all things that the user can control). But this raises the question: Where is the boundary between two selves?</p>
<p>Economically, a tool is something that increases productivity (output per input).</p>
<p>Teleologically, a tool is something made by man for a specific purpose: A tool makes something easier (or even possible at all).</p>
<h3 id="software-and-electricity-running-computers-vs-non-running-computers"><span class="section_number">5.11</span><span class="section_title">Software and electricity; running computers vs non-running computers</span></h3>
<p>The operation of a computer requires an energy source.</p>
<p>A computer that is not turned has the <em>potential</em> to compute, in the same way a seed has the potential to grow.</p>
<p>An <em>assignment statement</em> can be modeled by a <em>state endofunction</em>.</p>
<h3 id="should-we-define-ones-self-as-the-set-of-all-things-he-can-control"><span class="section_number">5.12</span><span class="section_title">Should we define one's &quot;self&quot; as the set of all things he can control?</span></h3>
<p>There are lots of parts of one's own body that one cannot fully control, such as his heart, his breathing muscles, his reflexes, etc.</p>
<h3 id="philosophy"><span class="section_number">5.13</span><span class="section_title">Philosophy?</span></h3>
<p><a href="https://www.perforce.com/blog/modern-software-engineering-meets-philosophy">https://www.perforce.com/blog/modern-software-engineering-meets-philosophy</a></p>
<p><a href="https://mystudentvoices.com/is-the-programmer-the-new-philosopher-or-software-the-new-philosophy-6c0cbea5b8d2">https://mystudentvoices.com/is-the-programmer-the-new-philosopher-or-software-the-new-philosophy-6c0cbea5b8d2</a></p>
<p><a href="https://softwareengineeringdaily.com/2016/02/12/10-philosophies-for-developers/">https://softwareengineeringdaily.com/2016/02/12/10-philosophies-for-developers/</a></p>
<p><a href="https://conferences.oreilly.com/software-architecture/sa-ny-2016/public/schedule/detail/50859">https://conferences.oreilly.com/software-architecture/sa-ny-2016/public/schedule/detail/50859</a></p>
<p><a href="http://www.cs.cornell.edu/gries/July2016/The-Science-Of-Programming-Gries-038790641X.pdf">http://www.cs.cornell.edu/gries/July2016/The-Science-Of-Programming-Gries-038790641X.pdf</a></p>
<p><a href="https://www.sws.cs.ru.nl/">https://www.sws.cs.ru.nl/</a></p>
<h2 id="language"><span class="section_number">6</span><span class="section_title">Language</span></h2>
<p>Language is more about communication/utility than truth.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">6.1</span><span class="section_title"><a href="#the-common-conflation-of-something-and-its-representation">The common conflation of something and its representation</a></span><span class="word_count">(110w~1m)</span></li>
</ul>
</div>
<h3 id="the-common-conflation-of-something-and-its-representation"><span class="section_number">6.1</span><span class="section_title">The common conflation of something and its representation</span></h3>
<p>Draw a car, and ask someone what it is, and he will probably answer &quot;a car&quot;, although, pedantically, it is incorrect, and the correct answer is &quot;the drawing of a car&quot;. However, we communicate not to be correct, but to be useful. Thus, in everyday communication, we <em>conflate</em> things and their <em>representations</em>: we often say &quot;X&quot; to mean &quot;a representation of X&quot;.</p>
<p>The positions of levers and switches are not software, but a <em>representation</em> of software. The magnetic fields in a hard disk is not data, but a <em>representation</em> of data. Changing the concrete representation of an abstract object affects the represented abstract object.</p>
<h2 id="software-science"><span class="section_number">7</span><span class="section_title">Software science</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">7.1</span><span class="section_title"><a href="#what-is-the-science-of-software-engineering">What is the science of software engineering?</a></span><span class="word_count">(100w~1m)</span></li>
<li><span class="section_number">7.2</span><span class="section_title"><a href="#mathematics-as-a-domain-specific-language-for-science">Mathematics as a domain-specific language for science?</a></span><span class="word_count">(26w~1m)</span></li>
<li><span class="section_number">7.3</span><span class="section_title"><a href="#where-is-software-science">Where is software science?</a></span><span class="word_count">(363w~2m)</span></li>
<li><span class="section_number">7.4</span><span class="section_title"><a href="#why-has-mathematics-not-revolutionized-biology-or-software-engineering">Why has mathematics not revolutionized biology or software engineering?</a></span><span class="word_count">(25w~1m)</span></li>
<li><span class="section_number">7.5</span><span class="section_title"><a href="#the-object-of-study">The object of study</a></span><span class="word_count">(22w~1m)</span></li>
<li><span class="section_number">7.6</span><span class="section_title"><a href="#good-laws-enforceability-and-unintended-consequences">Good laws, enforceability, and unintended consequences</a></span><span class="word_count">(118w~1m)</span></li>
<li><span class="section_number">7.7</span><span class="section_title"><a href="#computer-science-should-be-renamed-to-software-science">&lt;2019-08-11&gt; &quot;Computer science&quot; should be renamed to &quot;software science&quot;</a></span><span class="word_count">(58w~1m)</span></li>
</ul>
</div>
<h3 id="what-is-the-science-of-software-engineering"><span class="section_number">7.1</span><span class="section_title">What is the science of software engineering?</span></h3>
<p>If a branch of engineering is an application of a branch of science, then what branch of science is applied in software engineering? What is software science?</p>
<p>Civil engineering is the application of natural science (especially physics) to build civil structures such as bridges, buildings, dams, roads, and other many things used by civilizations.</p>
<p>A civil engineer can predict how much load a steel beam can handle. Can a software engineer predict how much load a machine can handle?</p>
<p>Software engineering is the application of computer science?</p>
<p>2018 slides &quot;What would a science of software engineering look like?&quot;<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a></p>
<h3 id="mathematics-as-a-domain-specific-language-for-science"><span class="section_number">7.2</span><span class="section_title">Mathematics as a domain-specific language for science?</span></h3>
<p>Mathematics is more like a domain-specific language than a branch of science. Mathematics is a language optimized for abstract thinking?</p>
<h3 id="where-is-software-science"><span class="section_number">7.3</span><span class="section_title">Where is software science?</span></h3>
<p><a href="https://ubiquity.acm.org/article.cfm?id=2590529">https://ubiquity.acm.org/article.cfm?id=2590529</a></p>
<p><a href="https://services.math.duke.edu/undergraduate/Handbook96_97/node5.html">https://services.math.duke.edu/undergraduate/Handbook96_97/node5.html</a></p>
<p>The abstract-object counterpart of concrete-object physics How do we apply the scientific method to the study of abstract objects? To anything?</p>
<p>If engineering is an application of science, what is the science that is applied in software engineering?</p>
<p>We need something like Newton's laws of motions for software dynamics that will enable us to predict things.</p>
<p>What should be the object of study of software science? Software? What is software? A model of reality? A model.</p>
<p>Software dynamics? Science of bottlenecks? Queuing theory.</p>
<p>If computer science is science, where are the falsifiable theories and the experiments?</p>
<p>A software is a model of reality.</p>
<p>Which branch of science studies models?</p>
<p>Which branch of science studies abstract objects? None. All branches so far are materialistic. They study concrete objects.</p>
<p>What experiments can be done with abstract objects? Besides thought experiments?</p>
<p>We can experiment with a program: We can stress-test it to figure out its maximum load (the maximum number of requests it can handle per second without errors), in a similar way we stress-test a steel bar to figure out its maximum load (the maximum force it can withstand without breaking). Benchmark games are similar to tables of material strengths.</p>
<p>We can experiment with abstract objects. For example, we can test software, we can test ideas. The problem is that each piece of software creates its own branch of science that is not transferable to other pieces of software. For example, knowledge of word processors is not applicable to accounting information systems. It is as if there were different Newton's laws of motion for cars, bikes, rocks, and other things. We need a science of all software, not just a particular software.</p>
<p>What does science do with its object of study? Come up with a predictive theory and experiments to falsify it.</p>
<p>Science comes from Latin &quot;scientia&quot; which simply means &quot;knowledge&quot;, but &quot;science&quot; is the application of the scientific method, the formulation of theories with explanatory and predictive power, and the experimentation to falsify such theories.</p>
<p>Before science can even exist, the language must first exist. We must first invent the terms, name the objects, and form the ontology. We must first find out what to talk about. We must first define the object of study.</p>
<h3 id="why-has-mathematics-not-revolutionized-biology-or-software-engineering"><span class="section_number">7.4</span><span class="section_title">Why has mathematics not revolutionized biology or software engineering?</span></h3>
<p>Is it due to the nature of biology or software engineering?</p>
<p>Or I don't know that it has?</p>
<p><a href="https://www.ams.org/notices/201510/rnoti-p1172.pdf">https://www.ams.org/notices/201510/rnoti-p1172.pdf</a></p>
<h3 id="the-object-of-study"><span class="section_number">7.5</span><span class="section_title">The object of study</span></h3>
<p>The object of study may be software itself, or an aspect of software, such as requirements, capacity, complexity, performance.</p>
<h3 id="good-laws-enforceability-and-unintended-consequences"><span class="section_number">7.6</span><span class="section_title">Good laws, enforceability, and unintended consequences</span></h3>
<p>Good laws are:</p>
<ol>
<li>enforceable, and</li>
<li>have minimal unintended consequences.</li>
</ol>
<p>Human laws are programs executed by humans. The nature of human laws is the same as computer programs, The difference is that humans mostly follow the spirit of the law, and computers always follow the letter of the law.</p>
<p>Example: Banning smoking is not practical to enforce: Are you going to put a cop in each building? Banning prostitution is not enforceable: Are you going to put a cop in each building?</p>
<p>I hypothesize that the principles of good software engineering is applicable to good legal engineering. Lawmakers are legal engineers. They should have engineering background. They engineer the lives of lots of people and the future of nations.</p>
<h3 id="computer-science-should-be-renamed-to-software-science"><span class="section_number">7.7</span><span class="section_title">&lt;2019-08-11&gt; &quot;Computer science&quot; should be renamed to &quot;software science&quot;</span></h3>
<p>It is unfortunate that &quot;Oh, you're a computer scientist? So you can fix my computer?&quot;</p>
<p>We don't study computers. We study software.</p>
<p>As a computer has a hardware part and a software part, computer science should study both hardware and software.</p>
<p>Universities should merge law departments and computer science departments into software departments.</p>
<h2 id="subfields-of-software-science"><span class="section_number">8</span><span class="section_title">Subfields of software science?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">8.1</span><span class="section_title"><a href="#turing">Turing?</a></span><span class="word_count">(7w~1m)</span></li>
<li><span class="section_number">8.2</span><span class="section_title"><a href="#software-complexity-theory">Software complexity theory</a></span><span class="word_count">(58w~1m)</span></li>
<li><span class="section_number">8.3</span><span class="section_title"><a href="#essential-complexity-theory">Essential complexity theory</a></span><span class="word_count">(190w~1m)</span></li>
<li><span class="section_number">8.4</span><span class="section_title"><a href="#descriptive-complexity-theory">Descriptive complexity theory</a></span><span class="word_count">(115w~1m)</span></li>
<li><span class="section_number">8.5</span><span class="section_title"><a href="#capacity-planning-theory">Capacity planning theory</a></span><span class="word_count">(48w~1m)</span></li>
<li><span class="section_number">8.6</span><span class="section_title"><a href="#programming-science">Programming science</a></span><span class="word_count">(20w~1m)</span></li>
<li><span class="section_number">8.7</span><span class="section_title"><a href="#software-development-science">Software development science</a></span><span class="word_count">(265w~2m)</span></li>
<li><span class="section_number">8.8</span><span class="section_title"><a href="#specification-theory">Specification theory</a></span><span class="word_count">(18w~1m)</span></li>
<li><span class="section_number">8.9</span><span class="section_title"><a href="#science-of-models">Science of models</a></span><span class="word_count">(15w~1m)</span></li>
<li><span class="section_number">8.10</span><span class="section_title"><a href="#science-of-software-changes">Science of software changes</a></span><span class="word_count">(83w~1m)</span></li>
<li><span class="section_number">8.11</span><span class="section_title"><a href="#states">States</a></span><span class="word_count">(19w~1m)</span></li>
<li><span class="section_number">8.12</span><span class="section_title"><a href="#human-aspects">Human aspects</a></span><span class="word_count">(19w~1m)</span></li>
<li><span class="section_number">8.13</span><span class="section_title"><a href="#parsing-theory">Parsing theory</a></span><span class="word_count">(2w~1m)</span></li>
<li><span class="section_number">8.14</span><span class="section_title"><a href="#learning-theory">Learning theory</a></span><span class="word_count">(2w~1m)</span></li>
</ul>
</div>
<h3 id="turing"><span class="section_number">8.1</span><span class="section_title">Turing?</span></h3>
<p>Turing's theory is about computation, not software.</p>
<h3 id="software-complexity-theory"><span class="section_number">8.2</span><span class="section_title">Software complexity theory</span></h3>
<p>Essential complexity = Kolmogorov complexity = the length of the shortest description of the software. The description must contain enough information for clean-room-reimplementation by another software engineer without any communication to the requirement analyst.</p>
<p>Accidental complexity = a measure of the apparent size of the software; number of syntax objects (abstract-syntax-tree nodes), number of lines of code.</p>
<h3 id="essential-complexity-theory"><span class="section_number">8.3</span><span class="section_title">Essential complexity theory</span></h3>
<p>Here we are interested in a measure of complexity, the cognitive load of understanding the software?</p>
<p>Kolmogorov complexity.</p>
<p>The complexity of a software system is the length of the shortest description of that system. The description must be such that someone else can recreate the system from only the description.</p>
<p>Example: a formula that describes a program that checks whether a list <span class="math inline">\(x\)</span> is ordered according to the ordering <span class="math inline">\(\le\)</span>.</p>
<p><span class="math inline">\( \forall i \forall j ( i \le j \implies x_i \le x_j ) \)</span></p>
<p>The formula can then be fed to descriptive complexity theory in order to determine the minimum possible resources required to implement the system. For example, it is a well-known fact in computer science that comparison-sort of an array of <span class="math inline">\( n \)</span> elements require <span class="math inline">\( \Omega(n log n) \)</span> time.</p>
<p>If something takes <span class="math inline">\( t \)</span> seconds to finish, then doing it <span class="math inline">\( n \)</span> times takes <span class="math inline">\( n \cdot t \)</span> seconds to finish.</p>
<p>That should also work under uncertainty: If something takes <span class="math inline">\( t \)</span> seconds to finish <em>on average</em>, then doing it <span class="math inline">\( n \)</span> times takes <span class="math inline">\( n \cdot t \)</span> seconds to finish <em>on average</em>. But telling the whole truth requires knowing the shape of the distribution, not only the mean.</p>
<h3 id="descriptive-complexity-theory"><span class="section_number">8.4</span><span class="section_title">Descriptive complexity theory</span></h3>
<p>Descriptive complexity theory is deep: It puts a lower bound on the solutions of problems regardless of the machines that implement those solutions. It is due to the inherent/essential complexity in logic itself, and not due to accidental complexity of the machine implementation.</p>
<p>In software engineering, the results of computational complexity theory are used for capacity planning, for example, that the lower time bound of comparison sorting is quasilinear<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>. This enables us to calculate the number of processors and the amount of memory, from the number of requests we expect to serve.</p>
<p>In reality, what is important is the actual number of seconds that users are willing to wait for computations with expected input sizes.</p>
<h3 id="capacity-planning-theory"><span class="section_number">8.5</span><span class="section_title">Capacity planning theory</span></h3>
<p>The mathematics of basic bottleneck science is simple: It is only basic arithmetics (addition, subtraction, multiplication, and division). If one wants more details, one can resort to queuing theory, but capacity planning can be done with simple basic arithmetics, without the full power of queuing theory<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a>.</p>
<h3 id="programming-science"><span class="section_number">8.6</span><span class="section_title">Programming science</span></h3>
<p>Lambda calculus can be a model of computer programs, but how do we experiment, and what should we falsify?</p>
<h3 id="software-development-science"><span class="section_number">8.7</span><span class="section_title">Software development science</span></h3>
<p>Software engineering is hard because it requires the engineer to estimate estimations.</p>
<p>We often want to estimate how long it takes to implement something.</p>
<p>But the estimation itself can only be done by doing the thing, because software development is full of unforeseeable roadblocks, because that software does not fit in our working memory. (How do we know that a library cannot do something? We have to try and find it out the hard way. Unfortunately that's the only way.)</p>
<p>So we try.</p>
<p>Thus we estimate how long it takes us to come up with a probable estimation.</p>
<p>Thus software engineering is second-order estimation.</p>
<p>Example: To estimate how long it takes to do X:</p>
<ul>
<li>Try doing X for a week.</li>
<li>See how much is actually done.</li>
<li>Extrapolate.</li>
</ul>
<p>This estimation should be much more accurate than pure guessing.</p>
<p>Thus the proper answer to &quot;How long will it take?&quot; is &quot;It will take a week for me to come up with an estimation.&quot;</p>
<p>We estimate that it will take us a week to come up with an estimation.</p>
<p>It's hard to estimate how much time is required to implement something, because we need to estimate how long it takes to estimate.</p>
<p>The only known way to estimate software development time is by extrapolating: Try developing it for a month, measure the accomplishments, and extrapolate from there.</p>
<p>Is it simpler in civil engineering? If you know that laying one brick takes 10 seconds, then you know that laying 1,000 bricks takes 10,000 seconds, but that is an oversimplification: Some civil engineering projects are also late, such as Jakarta mass rapid transport, but is it a political issue or an engineering issue?</p>
<h3 id="specification-theory"><span class="section_number">8.8</span><span class="section_title">Specification theory</span></h3>
<p>A <em>specification</em> is a logical formula in conjunctive normal form with at least one positive clause (literal?).</p>
<h3 id="science-of-models"><span class="section_number">8.9</span><span class="section_title">Science of models</span></h3>
<p>How do we measure a model's quality/fidelity, and with respect to what purpose?</p>
<h3 id="science-of-software-changes"><span class="section_number">8.10</span><span class="section_title">Science of software changes</span></h3>
<p>It is obvious that software has inertia, and bigger software is harder to change.</p>
<p>Suppose that we have a system <span class="math inline">\( S \)</span> that satisfies the logical formula <span class="math inline">\( \phi \)</span>, and we want to change <span class="math inline">\( S \)</span> to <span class="math inline">\( S&#39; \)</span> that satisfies <span class="math inline">\( \phi&#39; \)</span>. How much is the effort? It seems that the effort cannot be deduced from the logical formula alone.</p>
<p>It is possible to make two programs that satisfy the same logical formula (have the same observable behavior) but have widely different source codes.</p>
<h3 id="states"><span class="section_number">8.11</span><span class="section_title">States</span></h3>
<p>All practical systems have memory.</p>
<p>All systems that have memory are stateful.</p>
<p>Thus, we have to learn to live with states.</p>
<h3 id="human-aspects"><span class="section_number">8.12</span><span class="section_title">Human aspects</span></h3>
<p>Complexity increases the probability of mistakes/disasters due to a mismatch between human mental models and the actual reality.</p>
<p>Examples<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a>.</p>
<h3 id="parsing-theory"><span class="section_number">8.13</span><span class="section_title">Parsing theory</span></h3>
<h3 id="learning-theory"><span class="section_number">8.14</span><span class="section_title">Learning theory</span></h3>
<h2 id="logic"><span class="section_number">9</span><span class="section_title">Logic</span></h2>
<p>How do we measure the size of logical formulas?</p>
<h2 id="how-do-we-write-correct-software"><span class="section_number">10</span><span class="section_title">How do we write correct software?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">10.1</span><span class="section_title"><a href="#what-is-correct">What is correct?</a></span><span class="word_count">(19w~1m)</span></li>
<li><span class="section_number">10.2</span><span class="section_title"><a href="#proving-and-testing">Proving and testing</a></span><span class="word_count">(62w~1m)</span></li>
<li><span class="section_number">10.3</span><span class="section_title"><a href="#the-problem-with-formal-methods-you-cant-prove-what-you-dont-model.">The problem with formal methods: you can't prove what you don't model.</a></span><span class="word_count">(78w~1m)</span></li>
<li><span class="section_number">10.4</span><span class="section_title"><a href="#what">What?</a></span><span class="word_count">(88w~1m)</span></li>
<li><span class="section_number">10.5</span><span class="section_title"><a href="#coq">Coq?</a></span><span class="word_count">(122w~1m)</span></li>
<li><span class="section_number">10.6</span><span class="section_title"><a href="#testing">Testing</a></span><span class="word_count">(353w~2m)</span></li>
<li><span class="section_number">10.7</span><span class="section_title"><a href="#symbolic-execution">Symbolic execution</a></span><span class="word_count">(9w~1m)</span></li>
<li><span class="section_number">10.8</span><span class="section_title"><a href="#model-checking">Model checking</a></span><span class="word_count">(39w~1m)</span></li>
</ul>
</div>
<h3 id="what-is-correct"><span class="section_number">10.1</span><span class="section_title">What is correct?</span></h3>
<p>Correct with respect to what? It does what we want, and it only does what we want?</p>
<h3 id="proving-and-testing"><span class="section_number">10.2</span><span class="section_title">Proving and testing</span></h3>
<p><em>Testing approximates proving.</em> We actually want to prove a logical formula phi about a piece of code, we want to prove that the code fragment is a model of the formula phi, but proving is too expensive. Therefore, we test phi instead.</p>
<p>In back-end testing, the formula is often obvious. What is the formula in front-end testing? DOM element existence testing?</p>
<h3 id="the-problem-with-formal-methods-you-cant-prove-what-you-dont-model."><span class="section_number">10.3</span><span class="section_title">The problem with formal methods: you can't prove what you don't model.</span></h3>
<ul>
<li>Intel uses formal method, but why does its processors have vulnerabilities?
<ul>
<li>Because <em>you can't prove what you don't model</em>.</li>
<li>Spectre, Meltdown, etc.</li>
<li><a href="https://arstechnica.com/information-technology/2018/11/intel-cpus-fall-to-new-hyperthreading-exploit-that-pilfers-crypto-keys/?amp=1">https://arstechnica.com/information-technology/2018/11/intel-cpus-fall-to-new-hyperthreading-exploit-that-pilfers-crypto-keys/?amp=1</a></li>
</ul></li>
<li>How will we ever know that we didn't miss anything?</li>
<li>You have to prove that it does everything that you want it to do, <em>and</em> that it does only that, and nothing else.</li>
</ul>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">10.3.1</span><span class="section_title"><a href="#what-if-it-is-impossible-to-write-correct-software-what-are-our-options-to-mitigatelimit-the-damage">What if it is impossible to write correct software? What are our options to mitigate/limit the damage?</a></span><span class="word_count">(17w~1m)</span></li>
</ul>
</div>
<h4 id="what-if-it-is-impossible-to-write-correct-software-what-are-our-options-to-mitigatelimit-the-damage"><span class="section_number">10.3.1</span><span class="section_title">What if it is impossible to write correct software? What are our options to mitigate/limit the damage?</span></h4>
<h3 id="what"><span class="section_number">10.4</span><span class="section_title">What?</span></h3>
<ul>
<li>Where is tutorial?</li>
<li>A goal should be to make it easy to make correct software?</li>
<li>2014, slides, &quot;How I became interested in foundations of mathematics.&quot;, Vladimir Voevodsky, <a href="https://www.math.ias.edu/vladimir/sites/math.ias.edu.vladimir/files/2014_08_ASC_lecture.pdf">pdf</a></li>
<li>Why should we be interested in homotopy type theory?</li>
<li>Coq</li>
<li><p><a href="https://leanprover.github.io/">Lean</a></p>
<ul>
<li><p>Pros of Lean</p>
<ul>
<li>Integrates with Visual Studio Code</li>
</ul></li>
<li><p>Cons of Lean</p>
<ul>
<li>Less mature than Coq</li>
</ul></li>
</ul></li>
<li>Should we care about the relationship between functional programming and theorem proving?</li>
<li><p>Ramble</p>
<ul>
<li><p>Useless idea?</p>
<ul>
<li><p>Reverse-proving: generate all proofs of a theory. (Proving is: given a statement, prove (or disprove).)</p>
<ul>
<li>Which true sentences are interesting?</li>
<li>Which proofs are interesting?</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Companies</p>
<ul>
<li><a href="https://galois.com/">Galois</a>, on <a href="https://github.com/GaloisInc/">github</a></li>
</ul></li>
<li><p>unread interesting things</p>
<ul>
<li><a href="http://www.joachim-breitner.de/blog/717-Why_prove_programs_equivalent_when_your_compiler_can_do_that_for_you_">http://www.joachim-breitner.de/blog/717-Why_prove_programs_equivalent_when_your_compiler_can_do_that_for_you_</a></li>
<li><a href="http://www.michaelburge.us/2017/08/25/writing-a-formally-verified-porn-browser-in-coq.html">http://www.michaelburge.us/2017/08/25/writing-a-formally-verified-porn-browser-in-coq.html</a></li>
<li><a href="https://aphyr.com/posts/342-typing-the-technical-interview">https://aphyr.com/posts/342-typing-the-technical-interview</a></li>
<li><a href="http://tech.frontrowed.com/2017/09/22/aggregations/">http://tech.frontrowed.com/2017/09/22/aggregations/</a></li>
</ul></li>
<li><p>interoperation between proof assistants?</p>
<ul>
<li><p>Lem (&quot;lightweight executable mathematics&quot;)</p>
<ul>
<li><a href="https://www.openhub.net/p/lightweight-executable-mathematics">https://www.openhub.net/p/lightweight-executable-mathematics</a></li>
<li><a href="http://www.cl.cam.ac.uk/~pes20/lem/">http://www.cl.cam.ac.uk/~pes20/lem/</a></li>
</ul></li>
</ul></li>
</ul>
<h3 id="coq"><span class="section_number">10.5</span><span class="section_title">Coq?</span></h3>
<ul>
<li><p>Introduction</p>
<ul>
<li>What is a suitable introduction to Coq?</li>
<li><a href="https://people.debian.org/~schepler/coqtut.v.html">Daniel Schepler's &quot;Mathematical formalization using Coq&quot;</a> seems approachable.</li>
<li><a href="https://mathoverflow.net/questions/155909/wanted-a-coq-for-the-working-mathematician">MO 155909: Wanted: a &quot;Coq for the working mathematician&quot;</a></li>
<li><a href="https://mathoverflow.net/questions/164959/how-do-i-verify-the-coq-proof-of-feit-thompson">MO 164959: How do I verify the Coq proof of Feit-Thompson?</a></li>
<li><a href="https://softwarefoundations.cis.upenn.edu/current/index.html">https://softwarefoundations.cis.upenn.edu/current/index.html</a></li>
<li>Yves Bertot's &quot;Coq in a hurry&quot;</li>
<li><a href="https://coq.inria.fr/tutorial-nahas">Coq tutorial by Mike Nahas</a></li>
<li><a href="https://coq.inria.fr/distrib/current/refman/Reference-Manual006.html#Cic">Calculus of inductive constructions</a></li>
</ul></li>
<li><a href="http://blog.mikael.johanssons.org/coq-and-simple-group-theory.html">Coq and simple group theory</a></li>
<li><p>Installation on Ubuntu 14.04</p>
<ul>
<li><code>sudo apt-get install coq</code></li>
</ul></li>
</ul>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">10.5.1</span><span class="section_title"><a href="#introduction">Introduction</a></span><span class="word_count">(45w~1m)</span></li>
<li><span class="section_number">10.5.2</span><span class="section_title"><a href="#defining-things">Defining things</a></span><span class="word_count">(22w~1m)</span></li>
<li><span class="section_number">10.5.3</span><span class="section_title"><a href="#how-coq-represents-propositions">How Coq represents propositions</a></span><span class="word_count">(4w~1m)</span></li>
</ul>
</div>
<h4 id="introduction"><span class="section_number">10.5.1</span><span class="section_title">Introduction</span></h4>
<p>Coq source file extension is <code>.v</code>.</p>
<p>The notation <code>x:T</code> means &quot;the type of <code>x</code> is <code>T</code>&quot;, &quot;<code>x</code> inhabits <code>T</code>&quot;. It also means &quot;<code>x</code> is a proof of <code>T</code>&quot; by Curry-Howard isomorphism.</p>
<p>The type of <code>nat</code> is <code>Type(1)</code>.</p>
<p>The type of <code>set</code> is <code>Type(2)</code>.</p>
<p>The type of <code>Type(i)</code> is <code>Type(i+1)</code>.</p>
<pre class="example"><code>(* This is a comment in Coq. *)
</code></pre>
<pre class="example"><code>coqtop -l filename.v -batch
</code></pre>
<h4 id="defining-things"><span class="section_number">10.5.2</span><span class="section_title">Defining things</span></h4>
<pre class="example"><code>Definition x: nat := 0.
Check x.

Definition f (x: nat): nat := x + 1.
</code></pre>
<p>Definition = non-recursive definition</p>
<p>Fixpoint = recursive definition</p>
<p>Inductive = type (Set (small set)) definition</p>
<pre class="example"><code>Definition name: type
where
type: Set
or type: Prop
or type: Type.
</code></pre>
<p>Proving 0+1 = 1 using Curry-Howard isomorphism?</p>
<p>Axiom: and-elimination</p>
<span class="math display">\[\begin{align*}
a \wedge b \vdash a
\end{align*}
\]</span>
<pre class="example"><code>Theorem and_elim: forall a b: Prop, a /\ b -&gt; a.
tauto.
Qed.
</code></pre>
<span class="math display">\[\begin{align*}
a \vdash a \vee b
\end{align*}
\]</span>
<p>Modus ponens</p>
<span class="math display">\[\begin{align*}
a, a \rightarrow b \vdash b
\end{align*}
\]</span>
<h4 id="how-coq-represents-propositions"><span class="section_number">10.5.3</span><span class="section_title">How Coq represents propositions</span></h4>
<pre class="example"><code>Print False.
Print True.
Inductive True : Prop := I : True.
Inductive False : Prop := .
Inductive and (A B : Prop) : Prop := and : A -&gt; B -&gt; and A B.
</code></pre>
<h3 id="testing"><span class="section_number">10.6</span><span class="section_title">Testing</span></h3>
<p>Why do we test? Because we are not sure that our program is correct.</p>
<p>Why are we not sure that our program is correct?</p>
<ul>
<li>Because we don't know how to prove its correctness. This can be alleviated by using a decent programming language.</li>
<li>Because the cost of proving its correctness does not justify the benefit. We can't do anything about this if the complexity is essential (irreducible), not accidental.</li>
</ul>
<p>We human are fallible. Thus we will always test. Therefore:</p>
<ul>
<li>What should we test?</li>
<li>How should we test?</li>
<li>What is the test that has the greatest benefit-to-cost ratio?</li>
</ul>
<p>The expected benefit of a test is the expected cost of the mistakes that might have been made if the test did not exist.</p>
<p>The quality of a test is the seriousness of the mistakes it prevents. Thus, the seriousness of testing is proportional to the seriousness of risk.</p>
<p>Test is insurance. A good insurance covers your risk. A bad insurance only wastes money and doesn't cover your risk: Testing Java class getters is like buying flood insurance for a house in the desert.</p>
<p>Insurance causes moral hazard (taking more risk because someone else pays for it). Does having a test cause you to take more risks?</p>
<ul>
<li>The benefit of a test is the cost of the mistakes it prevents.</li>
<li>The cost of a test is the person-hours spent writing the test and updating the test, and a slight increase in build time. (Assume $50/person-hour for simplicity.)</li>
</ul>
<p>The answers to these questions tell us what to test and how to test:</p>
<ul>
<li>What tests have the greatest benefit-to-cost ratio?</li>
<li>What mistakes do our tests prevent? How expensive are the mistakes that our tests prevent?</li>
<li>Which part of our code is most likely to cause expensive mistakes? (Example: testing getters won't prevent expensive mistakes.)</li>
</ul>
<p>Code coverage is a meaningless metric. We should measure the expected value of mistakes instead. We should &quot;color&quot; our code: color more risky methods more red, color less risky methods more green, like this travel risk map<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a> but for software.</p>
<p>If you are launching a rocket, then a mistake may cost billions of dollars. It makes sense to invest ten million dollars testing to avoid a 1/100 probability of making a billion-dollar mistake.</p>
<h3 id="symbolic-execution"><span class="section_number">10.7</span><span class="section_title">Symbolic execution</span></h3>
<p>Chris Meudec<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a><a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a>. Prolog constraint solving for C/Java testing.</p>
<h3 id="model-checking"><span class="section_number">10.8</span><span class="section_title">Model checking</span></h3>
<p>Suppose that we have just written a function that sorts an array, and a mistake will cost $1,000,000. How do we prove that the function indeed sorts an array?</p>
<p>Clarke's overview and lots of examples in the 1990s <a href="http://www.cs.cmu.edu/~emc/15-398/lectures/overview.pdf">http://www.cs.cmu.edu/~emc/15-398/lectures/overview.pdf</a></p>
<h2 id="why-does-software-have-security-holes"><span class="section_number">11</span><span class="section_title">Why does software have security holes?</span></h2>
<p>Software has security holes because:</p>
<ol>
<li>Languages makes it too hard to do the right thing.</li>
<li>Programmers are too lazy to do the right thing.</li>
</ol>
<p>Authentication systems such as OAuth are too complex for programmers to use or understand. Anything more than HTTP Basic Auth is too complex. It sucks to write code for handling authentication. How do we make a programming system such that handling authentication is not hard? What is authentication and authorization?</p>
<p>&quot;A Taxonomy of Causes of Software Vulnerabilities in Internet Software&quot; <a href="https://pdfs.semanticscholar.org/5ec6/93950d1e6039e04a7b86a488e816ddcdd82e.pdf">https://pdfs.semanticscholar.org/5ec6/93950d1e6039e04a7b86a488e816ddcdd82e.pdf</a> &quot;software developers are making the same mistakes over and over again&quot;</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://www.historyofinformation.com/detail.php?entryid=936">http://www.historyofinformation.com/detail.php?entryid=936</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><a href="https://www.etymonline.com/word/hardware?ref=etymonline_crossreference">https://www.etymonline.com/word/hardware?ref=etymonline_crossreference</a><a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Dance_notation">https://en.wikipedia.org/wiki/Dance_notation</a><a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><a href="https://en.wikipedia.org/wiki/History_of_software">https://en.wikipedia.org/wiki/History_of_software</a><a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><a href="https://www.etymonline.com/search?q=program">https://www.etymonline.com/search?q=program</a><a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><a href="https://en.wikipedia.org/wiki/Neologism">https://en.wikipedia.org/wiki/Neologism</a><a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p><a href="https://www.etymonline.com/search?q=grok">https://www.etymonline.com/search?q=grok</a><a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p><a href="https://www.etymonline.com/search?q=program">https://www.etymonline.com/search?q=program</a><a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p><a href="https://simple.wikipedia.org/wiki/Television_program">https://simple.wikipedia.org/wiki/Television_program</a><a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p><a href="https://en.wikipedia.org/wiki/Broadcast_programming">https://en.wikipedia.org/wiki/Broadcast_programming</a><a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p><a href="http://herbsleb.org/web-pres/slides/crowd-chase-2018-final-dist.pdf">http://herbsleb.org/web-pres/slides/crowd-chase-2018-final-dist.pdf</a><a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p>&lt;2019-08-11&gt; <a href="https://en.wikipedia.org/wiki/Time_complexity#Quasilinear_time">https://en.wikipedia.org/wiki/Time_complexity#Quasilinear_time</a><a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p><a href="https://en.wikipedia.org/wiki/Queueing_theory">https://en.wikipedia.org/wiki/Queueing_theory</a><a href="#fnref13" class="footnote-back">↩</a></p></li>
<li id="fn14"><p>&lt;2019-08-12&gt; <a href="https://monzo.com/blog/2019/09/08/why-monzo-wasnt-working-on-july-29th">https://monzo.com/blog/2019/09/08/why-monzo-wasnt-working-on-july-29th</a><a href="#fnref14" class="footnote-back">↩</a></p></li>
<li id="fn15"><p><a href="https://i.redd.it/ktop13ad2io01.png">https://i.redd.it/ktop13ad2io01.png</a><a href="#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p><a href="http://tinyurl.com/y42eyfkp">http://tinyurl.com/y42eyfkp</a><a href="#fnref16" class="footnote-back">↩</a></p></li>
<li id="fn17"><p><a href="http://www.echancrure.eu">http://www.echancrure.eu</a><a href="#fnref17" class="footnote-back">↩</a></p></li>
</ol>
</section>
                </div>
            </div>
        </main>
        <p>
            Disqus has been removed because it hijacks my links and redirects them to third-party ad networks.
            On 2019-05-27, a friend of mine reported that links on my website are broken,
            and I caught Disqus red-handed redirecting my links to pwieu.com.
        </p>
        <footer class="site-footer h-card">
            <data class="u-url" href="/"></data>
            <div class="wrapper">
                <p>This page was created on 2019-08-14 00:00 +0700.</p>
                <p class="rss-subscribe">There is an
                    <a href="/feed.xml">RSS feed</a>, but it's unused because this site is a wiki, not a blog.</p>
                <p>Stop writing books, papers, and blogs!
                    Write a personal wiki instead!
                    Or, even better, contribute to a community wiki.
                </p>
            </div>
        </footer>
    </body>
</html>
