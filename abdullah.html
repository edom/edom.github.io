<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Abdullah research roadmap</title>
  <meta name="description" content="Personal website">

  <link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700&amp;subset=latin-ext" rel="stylesheet">
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://edom.github.io/abdullah.html">
  <link rel="alternate" type="application/rss+xml" title="Erik Dominikus&#39;s wiki" href="/feed.xml">

  

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-12628443-6', 'auto');
  ga('send', 'pageview');

</script>
  

  

  
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    jax: ["input/TeX","input/MathML","input/AsciiMath",

    "output/CommonHTML"

    ],
    extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "a11y/accessibility-menu.js"],
    TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
        , equationNumbers: {
            autoNumber: "AMS"
        }
    },
    "CommonHTML": {
        scale: 100
    },
    "fast-preview": {
        disabled: true,
    }
});
  </script>
  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js" async></script>
  
</head>


  <body>

    <header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Erik Dominikus&#39;s wiki</a>
  </div>
</header>


    
  <div style="display:none;">\(
\renewcommand\emptyset{\varnothing}
\newcommand\abs[1]{\left|#1\right|}
\newcommand\dom{\textrm{dom}}
\newcommand\cod{\textrm{cod}}
\newcommand\Bernoulli{\textrm{Bernoulli}}
\newcommand\Binomial{\textrm{Binomial}}
\newcommand\Expect[1]{\mathbb{E}[#1]}
\newcommand\Nat{\mathbb{N}}
\newcommand\Integers{\mathbb{Z}}
\newcommand\Real{\mathbb{R}}
\newcommand\Rational{\mathbb{Q}}
\newcommand\Complex{\mathbb{C}}
\newcommand\Pr{\mathrm{P}}
\newcommand\Time{\text{Time}}
\newcommand\DTime{\text{DTime}}
\newcommand\NTime{\text{NTime}}
\newcommand\TimeP{\text{P}}
\newcommand\TimeNP{\text{NP}}
\newcommand\TimeExp{\text{ExpTime}}
\newcommand\norm[1]{\left\lVert#1\right\rVert}
\newcommand\bbA{\mathbb{A}}
\newcommand\bbC{\mathbb{C}}
\newcommand\bbD{\mathbb{D}}
\newcommand\bbE{\mathbb{E}}
\newcommand\bbN{\mathbb{N}}
\newcommand\frakI{\mathfrak{I}}
% deprecated; use TimeExp
\newcommand\ExpTime{\text{ExpTime}}
\newcommand\Compute{\text{Compute}}
\newcommand\Search{\text{Search}}
% model theory structure
\newcommand\struc[1]{\mathcal{#1}}
  \)</div>
    

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Abdullah research roadmap</h1>
  </header>

  <div class="post-content">
    <ul>
  <li>Abbreviations:
    <ul>
      <li>CCC: Cartesian closed category (<a href="https://en.wikipedia.org/wiki/Cartesian_closed_category">Wikipedia</a>)</li>
    </ul>
  </li>
  <li>Abdullah wants to make a monad-aware programming language.
    <ul>
      <li>Categories enable us to organize a hierarchy of effects?
        <ul>
          <li>effectful over category \( C \) = extends category \( C \)?</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>The plan is to research two related things in parallel:
    <ul>
      <li>using algebraic subtyping to mix parametric subtyping and inheritance subtyping
        <ul>
          <li><a href="https://www.cl.cam.ac.uk/~sd601/thesis.pdf">Stephen Dolan’s Ph.D. thesis “Algebraic subtyping”</a>
            <ul>
              <li>“Type systems which support subtyping care about the direction of data flow.”</li>
              <li>“Find the <em>simplest</em> algebra of types, and <em>some</em> syntax for them”</li>
            </ul>
          </li>
          <li><a href="https://en.wikipedia.org/wiki/Subtyping">Wikipedia: Subtyping</a></li>
          <li>Scala already tries to join parametric subtyping and inheritance subtyping.
  What is the problem with Scala?</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Related: <a href="/functional_programming.html">functional programming research</a>.</li>
  <li>Who is Abdullah?
    <ul>
      <li>Abdullah a.k.a. Kim-Ee Yeoh is <a href="https://www.atamo.com/">atamo.com</a>.</li>
    </ul>
  </li>
</ul>

<h2 id="research-questions">Research questions</h2>

<h3 id="possible-questions">Possible questions</h3>

<ul>
  <li>What is the result of CPS-transforming a recursive function?</li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fac</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fac</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">fac</span> <span class="mi">0</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="mi">1</span>
<span class="n">fac</span> <span class="n">n</span> <span class="n">k</span> <span class="o">=</span> <span class="n">fac</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">k</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>Conjecture:
Every recursive function can be transformed to a tail-recursive function with a helper function \( f(x) = f(g(x)) \).</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fac</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fac</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">fach</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">fach</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="n">fach</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">fac</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fach</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>How do we enable the caller to step the recursion?</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fac</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">\</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="n">k</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">fac</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">k</span><span class="p">)</span> <span class="n">n</span>
<span class="n">fac</span> <span class="n">n</span> <span class="p">(</span><span class="nf">\</span> <span class="n">f</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span>

<span class="n">tri</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">tri</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">tri</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">tri</span> <span class="o">::</span> <span class="kt">Nat</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Nat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Nat</span> <span class="o">-&gt;</span> <span class="kt">Nat</span><span class="p">)</span>
<span class="n">tri</span> <span class="mi">0</span> <span class="o">=</span> <span class="nf">\</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="mi">0</span>
<span class="n">tri</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">\</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="n">k</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">tri</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">c</span><span class="p">)</span> <span class="n">n</span>

<span class="n">inc</span> <span class="n">x</span> <span class="o">=</span> <span class="n">inc</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">inc</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">\</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="n">k</span> <span class="p">(</span><span class="nf">\</span> <span class="p">)</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><a href="https://github.com/dorchard/unfix">github: dorchard/unfix: Takes a recursive function and syntactically unties the recursive knot</a></li>
</ul>

<h3 id="what-is-the-relationship-between-self-reference-recursion-and-fixed-points">What is the relationship between self-reference, recursion, and fixed points?</h3>

<p>We say that \( x \) is a <em>fixed point</em> of \( f \) iff \( f(x) = x \).</p>

<p><a href="https://mathoverflow.net/questions/126513/categories-of-recursive-functions">MO 126513: categories of recursive functions</a></p>

<ul>
  <li>What is the essence of self-recursion?
    <ul>
      <li><code class="highlighter-rouge">fix</code> does not exist in a strict language.
        <ul>
          <li>“The Z combinator will work in strict languages […]” <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Strict_fixed_point_combinator">WP: Fixed-point combinator</a>
            <ul>
              <li>The Z combinator is obtained by eta-expanding the Y combinator.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="what-is-the-formal-definition-of-strict-non-strict-eager-and-lazy">What is the formal definition of strict, non-strict, eager, and lazy?</h3>

<p>The difference is explained by luqui on <a href="https://stackoverflow.com/questions/7140978/haskell-how-does-non-strict-and-lazy-differ">SO 7140978</a>.</p>
<ul>
  <li>Strict and non-strict are about meaning (denotational semantics?).
Eager and lazy are about operation (operational semantics?).</li>
  <li>Strictness is a domain-theoretic concept.
Laziness is a computer implementation detail.</li>
  <li>This uses Haskell to introduce domain theory: <a href="https://en.wikibooks.org/wiki/Haskell/Denotational_semantics">Wikibooks: Haskell: Denotational semantics</a>.
    <ul>
      <li>In Haskell, the least fixed point operator can be defined as <code class="highlighter-rouge">fix f = f (fix f)</code>.
        <ul>
          <li>Why is bottom the <em>least</em> fixed point of <code class="highlighter-rouge">id</code>?
  Every \( x \) is a fixed point of an identity function \( x \mapsto x \), isn’t it?
            <ul>
              <li>What is the ordering?
                <ul>
                  <li>“Semantic approximation order”</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="https://wiki.haskell.org/Lazy_vs._non-strict">Haskell wiki</a> is wrong?
  It conflates non-strictness with normal-order reduction strategy?</li>
      <li><a href="http://pages.cs.wisc.edu/~horwitz/CS704-NOTES/6.DENOTATIONAL-SEMANTICS.html#simple">A simple example of denotational semantics using a language of binary numerals</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Binary_combinatory_logic">WP: Binary combinatory logic</a>.
  Its semantics is SK calculus (SKI calculus without the redundant I combinator) which is equivalent to lambda calculus.</li>
    </ul>
  </li>
  <li>we can execute non-strict functions eagerly,
for example by strictness analysis or speculative execution.</li>
</ul>

<p>People are often sloppy with these terms. Redditors. Experts. Researchers. Academics.
It is true that Haskell is non-strict.
It is true that Haskell (as implemented by GHC) is lazy.</p>

<p>We can infer these formal definitions:</p>
<ul>
  <li>A function \( f \) is <em>strict</em> iff \( f(\bot) = \bot \).
    <ul>
      <li>“a strict function must map bottom to bottom” (from the SO answer)</li>
    </ul>
  </li>
</ul>

<h3 id="how-do-we-represent-general-recursion-by-a-monad-how-do-we-add-general-recursion-to-tfp-how-do-we-do-it-with-monads">How do we represent general recursion by a monad? How do we add general recursion to TFP? How do we do it with monads?</h3>

<p>Here we try to salvage [McBride2015].</p>

<p>TODO write the problem: how McBride’s General doesn’t compose</p>

<ul>
  <li>Is McBride’s General really a monad?</li>
  <li>Is Abdullah’s M really a monad?</li>
  <li>Did Abdullah mistranslate McBride’s General?</li>
  <li>Is there a way to transform begin-step-end to McBride’s General or Abdullah’s M?</li>
  <li>Start with axioms, then infer the data types.</li>
</ul>

<p>These are the axioms that we want M to satisfy.</p>
<ul>
  <li><code class="highlighter-rouge">rec f . rec g = rec (ext f . g)</code></li>
  <li><code class="highlighter-rouge">rec f . rec g = rec (f &lt;=&lt; g)</code></li>
  <li><code class="highlighter-rouge">rec pure = id</code></li>
</ul>

<p>How do we translate a recursive function <code class="highlighter-rouge">f : a -&gt; b</code>
to an explicitly recursive function <code class="highlighter-rouge">f : a -&gt; m b</code>?</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Abdullah's M, obtained by translating</span>
<span class="c1">-- the General in [McBride2015] from Agda to Haskell</span>
<span class="kr">data</span> <span class="kt">M</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span>
    <span class="o">=</span> <span class="kt">Em</span> <span class="n">a</span>
    <span class="o">|</span> <span class="kt">Ap</span> <span class="p">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">M</span> <span class="n">s</span> <span class="n">t</span> <span class="n">a</span><span class="p">)</span> <span class="n">s</span>

<span class="n">cata</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">r</span>
<span class="n">cata</span> <span class="n">ar</span> <span class="n">xrxr</span> <span class="n">m</span> <span class="o">=</span> <span class="n">fix</span> <span class="o">$</span> <span class="nf">\</span> <span class="n">self</span> <span class="n">m</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
    <span class="kt">Em</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">ar</span> <span class="n">a</span>
    <span class="kt">Ap</span> <span class="n">xma</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">xrxr</span> <span class="p">(</span><span class="n">self</span> <span class="o">.</span> <span class="n">xma</span><span class="p">)</span> <span class="n">x</span>
</code></pre></div></div>

<ul>
  <li>Why do we want to add general recursion to TFP?
    <ul>
      <li>Adding general recursion to a TFPL
  makes programming in that language more practical.</li>
    </ul>
  </li>
  <li>There are several attempts to add general recursion to TFP.
    <ul>
      <li>[Nordstrom1988] (terminating general recursion)</li>
      <li>[Bove2001] (simple general recursion in type theory)</li>
      <li>[Capretta2005] (general recursion via coinductive types)</li>
      <li>[McBride2015] (Turing-completeness totally free)</li>
      <li>me on 2018-04-07: <a href="/tfp_gen_rec.html">Approximating general recursion in TFP</a></li>
      <li><a href="http://adam.chlipala.net/cpdt/html/GeneralRec.html">A non-termination monad inspired by domain theory</a>,
  part of the documentation of Coq’s GeneralRec library</li>
    </ul>
  </li>
  <li>How are monads useful in FP?
    <ul>
      <li>Monads allow embedding a strict language in a lazy language [Wadler1996].</li>
      <li>“Monads may be regarded as a mild generalization of continuation-passing style.” [Wadler1996]</li>
    </ul>
  </li>
  <li><a href="http://homepages.inf.ed.ac.uk/wadler/topics/monads.html">Philip Wadler’s research on monads</a></li>
  <li>Reading triage:
    <ul>
      <li>Moggi 1991: Notions of computation and monads
        <ul>
          <li>Programs should form a category.
            <ul>
              <li>Every type becomes an object in the category.</li>
              <li>Every (one-parameter) function becomes a morphism in the category.</li>
            </ul>
          </li>
          <li>“Kleisli triples are just an alternative description for monads. Although
  the former are easy to justify from a computational perspective, the latter
  are more widely used in the literature on category theory and have the
  advantage of being defined only in terms of functors and natural transformations,
  which make them more suitable for abstract manipulation.”</li>
          <li>Moggi’s most cited paper, according to Google Scholar</li>
          <li><a href="https://www.disi.unige.it/person/MoggiE/">Moggi’s home page</a>
            <ul>
              <li><a href="https://www.disi.unige.it/person/MoggiE/publications.html">Moggi’s list of his publications</a>
                <ul>
                  <li>recent paper: 2010 “Monad Transformers as Monoid Transformers”. Theoretical Computer Science, TCS vol.411</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="https://www.irif.fr/~mellies/mpri/mpri-ens/articles/moggi-computational-lambda-calculus-and-monads.pdf">Moggi 1989: Computational lambda-calculus and monads</a></li>
      <li>2017 Uustalu <a href="https://www.semanticscholar.org/paper/Partiality-and-Container-Monads-Uustalu-Veltri/a45cabd8696232a985368e5b7f138fd21a7bff9f">Partiality and container monads</a></li>
      <li>[Sheard2003] (a pure language with default strict evaluation order and explicit laziness)</li>
      <li>[Wadler1998] (how to add laziness to a strict language without even being odd)</li>
      <li>[Wadler1992] “explores the use of monads to structure functional programs”</li>
      <li><a href="https://srfi.schemers.org/srfi-40/mail-archive/msg00059.html">Monad for lazy evaluation</a>,
  Scheme, SRFI-40 mail archive, Andre van Tonder</li>
      <li><a href="http://math.andrej.com/2008/11/17/not-all-computational-effects-are-monads/">Not all computational effects are monads</a></li>
      <li>2018 Tomas Petricek <a href="https://arxiv.org/pdf/1803.10195.pdf">What we talk about when we talk about monads</a></li>
    </ul>
  </li>
</ul>

<h2 id="result-of-meeting-on-2018-04-21">Result of meeting on 2018-04-21</h2>

<ul>
  <li>https://mvanier.livejournal.com/2897.html</li>
  <li>Applicative Functor is a homomorphism over CCC (Cartesian closed category)?</li>
  <li>We can use a category as the denotation of a functional programming language.
    <ul>
      <li>An example of a category:
        <ul>
          <li>One object: Unit</li>
          <li>One morphism:</li>
          <li>Two functions:
            <ul>
              <li><code class="highlighter-rouge">f0 x = Unit</code></li>
              <li><code class="highlighter-rouge">f1 x = x</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>What is a CCC? It is a category that satisfies the axioms in <a href="https://en.wikipedia.org/wiki/Cartesian_closed_category">WP: CCC</a>.</li>
</ul>

<h2 id="agenda-for-2018-04-21">Agenda for 2018-04-21</h2>

<h3 id="totality-is-not-about-termination">Totality is not about termination</h3>

<p>Consider this example.
This recursion is not structural.
However, it terminates under normal-order beta-reduction strategy.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Constant function.</span>
<span class="n">f</span> <span class="o">:</span> <span class="kt">Nat</span> <span class="o">-&gt;</span> <span class="kt">Nat</span>
<span class="n">f</span> <span class="kr">_</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">main</span> <span class="o">:</span> <span class="kt">Nat</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">f</span> <span class="n">main</span>
</code></pre></div></div>

<p>Is <code class="highlighter-rouge">main</code> a total function?
Does that question make sense?
Note that <code class="highlighter-rouge">main</code> is not a mathematical function.
The denotation of <code class="highlighter-rouge">main</code> might be a mathematical function.</p>

<p>Does totality depend on the reduction strategy?
Does that question make sense?</p>

<p>I conjecture that every general recursive function can be transformed into its begin-step-end form.
See <a href="/tfp_gen_rec.html">Approximating general recursion in TFP</a>.</p>

<h3 id="i-think-we-cant-add-a-lazy-monad-instance-to-strict-haskell-without-changing-the-language-semantics">I think we can’t add a Lazy Monad instance to Strict Haskell without changing the language semantics</h3>

<p>Here I try to (and fail to) add a Lazy monad to an imaginary language Strict Haskell (SH).</p>

<p>Imagine SH, a language with Haskell syntax
but with Scheme’s applicative-order beta reduction (AOBR) instead of Haskell’s normal-order beta reduction.
AOBR means: to evaluate <code class="highlighter-rouge">f x</code>, first evaluate <code class="highlighter-rouge">x</code>, and then evaluate <code class="highlighter-rouge">f x</code>.
SH is strict, and Haskell is lazy.</p>

<p>An inhabitant of the type <code class="highlighter-rouge">Lazy a</code> can be thought as a thunk that will return an inhabitant of <code class="highlighter-rouge">a</code>.</p>

<p>To construct an expression of type <code class="highlighter-rouge">Lazy a</code>, combine these:</p>
<ul>
  <li>The expression <code class="highlighter-rouge">bottom</code> constructs a thunk will fail.</li>
  <li>The expression <code class="highlighter-rouge">pure x</code> constructs a thunk that will return <code class="highlighter-rouge">x</code>.
Note that <code class="highlighter-rouge">x</code> is evaluated before the thunk is constructed.</li>
  <li>The expression <code class="highlighter-rouge">delay f</code> constructs a thunk that will return the result of evaluating <code class="highlighter-rouge">f Unit</code>.
The type of <code class="highlighter-rouge">f</code> is <code class="highlighter-rouge">Unit -&gt; a</code>.
Note that <code class="highlighter-rouge">f unit</code> is not evaluated when the thunk is constructed,
unlike <code class="highlighter-rouge">pure</code>.</li>
  <li>The expression <code class="highlighter-rouge">eval t</code> evaluates or forces the thunk <code class="highlighter-rouge">t</code>.
The type of <code class="highlighter-rouge">eval</code> is <code class="highlighter-rouge">Lazy a -&gt; Maybe a</code>.</li>
</ul>

<p>We want to embed laziness into SH.
Formally, this means that we want this equation to hold</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eval (bottom &gt;&gt;= \ x -&gt; pure c) = Just c
</code></pre></div></div>

<p>but this is impossible in SH because the <code class="highlighter-rouge">&gt;&gt;=</code> is strict.</p>

<p>However, if the type of <code class="highlighter-rouge">&gt;&gt;=</code> were this</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(Monad m) =&gt; m (Lazy a) -&gt; (Lazy a -&gt; m (Lazy b)) -&gt; m (Lazy b)
</code></pre></div></div>

<p>then it would be possible to embed laziness into SH.</p>

<p>Thus <code class="highlighter-rouge">Lazy</code> cannot be a <code class="highlighter-rouge">Monad</code> instance in SH.</p>

<p>Monads allow embedding a strict language in a lazy language [Wadler1996].
We are trying the reverse (embedding a lazy language in a strict language).
We have just tried the most naive way.
It failed.</p>

<h3 id="does-tfp-really-sacrifice-turing-completeness">Does TFP really sacrifice Turing-completeness?</h3>

<ul>
  <li>What is a rigorous definition of Turing-completeness?
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Turing_completeness">Wikipedia</a>:
  “a system of data-manipulation rules (such as a computer’s instruction set, a programming language, or a cellular automaton)
  is said to be Turing complete or computationally universal if it can be used to simulate any Turing machine”
        <ul>
          <li>What does “simulate” mean?</li>
        </ul>
      </li>
      <li>What is the relationship among total Turing machine, partial Turing machine, total function, and partial function?
  See <a href="https://en.wikipedia.org/wiki/Machine_that_always_halts">Wikipedia: Machine that always halts</a>.</li>
    </ul>
  </li>
  <li>Why do you ask this?
    <ul>
      <li>We’ve been thinking that totality precludes Turing-completeness, but Conor McBride disagrees in [McBride2015].</li>
    </ul>
  </li>
</ul>

<h2 id="results">Results</h2>

<h3 id="is-continuation-the-mother-of-all-monads">Is continuation the mother of all monads?</h3>

<p>Abdullah wants to prove that continuation is the mother of all monads.</p>

<p>I think I have a partial proof of that for all Haskell-98 type endofunctions.</p>

<p>The folder <a href="https://github.com/Lambda-Jakarta/research/tree/master/abdullah-conjecture">abdullah-conjecture</a>
contains a proposed partial proof of the Abdullah conjecture for all Haskell 98 type endofunctions.
The proof can be checked by the Lean theorem prover version 3.
See also the <a href="https://leanprover.github.io/">Lean prover home page</a>.
To edit Lean source files, use Visual Studio Code and its Lean plugin.</p>

<h2 id="reading-triage">Reading triage</h2>

<p><a href="https://pdfs.semanticscholar.org/b60b/1c2e49ec6f574f220f162c8fdc81b2831830.pdf">1995, D. A. Turner, Elementary Strong Functional Programming</a></p>

<p><a href="https://nms.kcl.ac.uk/maribel.fernandez/papers/TCS10.pdf">Godel’s System T revisited</a></p>

<p><a href="http://semantic-domain.blogspot.co.id/2012/12/total-functional-programming-in-partial.html">Total Functional Programming in a Partial Impure Language</a></p>

<p><a href="http://www.cse.chalmers.se/~coquand/bengt.pdf">Type theory and functional programming</a>:
Can we see type theory as a functional programming language?</p>

<p><a href="http://www.cse.chalmers.se/~coquand/">Thierry Coquand page at Chalmers</a></p>

<p><a href="https://mathoverflow.net/questions/126513/categories-of-recursive-functions">MO 126513: Categories of recursive functions</a></p>

<p><a href="https://www.researchgate.net/publication/234808984_Denotational_semantics_and_rewrite_rules_for_FP">Denotational semantics and rewrite rules for FP</a>:
“We consider languages whose operational semantics is given by a set of rewrite rules.”</p>

<p><a href="http://www.allisons.org/ll/Semantics/">allisons.org: Denotational Semantics</a></p>

<p>The Y-combinator is \( \lambda f. (\lambda x. f ~ (x ~ x)) ~ (\lambda x. f ~ (x ~ x)) \).
<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">WP: Fixed-point combinator</a></p>

<p><a href="http://siek.blogspot.co.id/2016/12/simple-denotational-semantics-for.html">Simple Denotational Semantics for the Lambda Calculus, Pω Revisited?</a></p>

<h2 id="undigested-information-fragments">Undigested information fragments</h2>

<ul>
  <li>“Partiality is an effect”
https://www.cs.ox.ac.uk/ralf.hinze/WG2.8/22/slides/tarmo.pdf</li>
  <li>“Partiality Monad Transformer”
https://stackoverflow.com/questions/15192897/partiality-monad-transformer</li>
  <li>http://www.cse.chalmers.se/~nad/publications/danielsson-semantics-partiality-monad.pdf</li>
  <li>categorical programming language
    <ul>
      <li>http://web.sfc.keio.ac.jp/~hagino/thesis.pdf</li>
      <li>https://mathoverflow.net/questions/3721/programming-languages-based-on-category-theory</li>
      <li>https://softwareengineering.stackexchange.com/questions/216635/category-theory-based-language</li>
    </ul>
  </li>
  <li>“Kleisli triple over a category”</li>
  <li>“Category formed by the Kleisli triples over a category”</li>
  <li>Moggi 1991:
    <ul>
      <li>“Kleisli triples are just an alternative description for monads. Although
the former are easy to justify from a computational perspective, the latter
are more widely used in the literature on category theory and have the
advantage of being defined only in terms of functors and natural transformations, which make them more suitable for abstract manipulation.”</li>
    </ul>
  </li>
  <li>Where does monad come from? Who invented it? Why was it invented?</li>
  <li>What is the relationship among monad, natural transformation, Kleisli category of a monad, Eilenberg-Moore what, adjunction?</li>
  <li>Has some semantics link
http://math.andrej.com/2016/08/06/hask-is-not-a-category/comment-page-1/</li>
  <li><a href="ftp://nozdr.ru/biblio/kolxo3/Cs/CsLn/Mathematics%20of%20program%20construction..%2010%20conf.,%20MPC%202010%20(LNCS6120,%20Springer,%202010)(ISBN%203642133207)(O)(435s)_CsLn_.pdf#page=109">2010, “Subtyping, Declaratively: An Exercise in Mixed Induction and Coinduction”, Nils Anders Danielsson and Thorsten Altenkirch</a></li>
</ul>

  </div>

</article>

      </div>
    </main>

    
    
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
var disqus_config = function () {
    this.page.url = "https://edom.github.io/abdullah.html";  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = "https://edom.github.io/abdullah.html"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://edom-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    

    <footer class="site-footer h-card">
    <data class="u-url" href="/"></data>

    <div class="wrapper">
        <p>This page was created on 2018-04-11 03:50 +0700.</p>
        <p class="rss-subscribe">There is an <a href="/feed.xml">RSS feed</a>,
        but it's unused because this site is a wiki, not a blog.</p>
        <p>Stop writing books, papers, and blogs! Write a personal wiki instead! Or, even better, contribute to a community wiki.</p>
    </div>

</footer>


  </body>

</html>
