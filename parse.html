<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Parsing Research Group</title>
        <link rel="stylesheet" href="/assets/main.css"/>
        <script>
// Help the reader estimate how much time the reading is going to take.
// Show word count and reading time estimation in TOC entry.
//
// TOC = table of contents
//
// Known issue: This janks: this DOM manipulation is done after the page is rendered.
// If we don't want jank, we have to manipulate the HTML source before it reaches the browser.
// We assume that the user doesn't refresh the page while reading.
// The benefit of fixing that jank is not enough for me to justify trying to fix it.
document.addEventListener("DOMContentLoaded", function () {
    function count_word (string) {
        return string.trim().split(/\s+/).length;
    }
    function show_quantity (count, singular) {
        let plural = singular + "s"; // For this script only.
        return count + " " + ((count == 1) ? singular : plural);
    }
    function create_length_indicator (word, minute) {
        let e = document.createElement("span");
        e.className = "toc_entry__length_indicator";
        e.textContent = " (" + show_quantity(word, "word") + " ~ " + show_quantity(minute, "minute") + ")";
        return e;
    }
    // We assume that readers read this many words per minute with 100% comprehension.
    // This assumption may not hold for dense texts such as philosophy and mathematics.
    const wpm_assumption = 200;
    // We assume a certain Jekyll template.
    let page = document.querySelector("main.page-content");
    if (page === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"main.page-content\" does not match anything");
        return;
    }
    let page_title = document.querySelector("header.post-header h1.post-title");
    if (page_title === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"header.post-header h1.post-title\" does not match anything");
        return;
    }
    let page_word = count_word(page.textContent);
    let page_minute = Math.ceil(page_word / wpm_assumption);
    page_title.insertAdjacentElement("afterend", create_length_indicator(page_word, page_minute));
    // We violate the HTML specification.
    // The page may have several elements with the same ID.
    // We assume that Org HTML Export generates a DIV element with ID "table-of-contents".
    // We assume that Jekyll Markdown-to-HTML generates a UL element with ID "markdown-toc".
    // This only works for Org HTML Export's TOC.
    let toc_entries = document.querySelectorAll("#table-of-contents a, #text-table-of-contents a");
    toc_entries.forEach((toc_entry_a) => {
        let href = toc_entry_a.getAttribute("href"); // We assume that this is a string like "#org0123456".
        if (href.charAt(0) !== '#') {
            console.log("toc_generate_estimate: Impossible: " + href + " does not begin with hash sign");
            return;
        }
        // We can't just document.querySelector(href) because target_id may contain invalid ID characters such as periods.
        let target_id = href.substring(1);
        let id_escaped = target_id.replace("\"", "\\\"");
        let h_elem = document.querySelector("[id=\"" + id_escaped + "\"]"); // We assume that this is the h1/h2/h3 element referred by the TOC entry.
        if (h_elem === null) { // We assume that this is impossible.
            console.log("toc_generate_estimate: Impossible: " + href + " does not refer to anything");
            return;
        }
        let section = h_elem.parentNode;
        let section_word = count_word(section.textContent);
        let section_minute = Math.ceil(section_word / wpm_assumption);
        toc_entry_a.insertAdjacentElement("afterend", create_length_indicator(section_word, section_minute));
    });
});
        </script>

        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12628443-6"></script>
<script>
  window['ga-disable-UA-12628443-6'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-12628443-6');
</script>
        
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            jax: ["input/TeX","input/MathML","input/AsciiMath",
            "output/CommonHTML"
            ],
            extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "a11y/accessibility-menu.js"],
            TeX: {
                extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
                , equationNumbers: {
                    autoNumber: "AMS"
                }
            },
            "CommonHTML": {
                scale: 100
            },
            "fast-preview": {
                disabled: true,
            }
        });
        </script>
        <style>
            /*
            PreviewHTML produces small Times New Roman text.
            PreviewHTML scale doesn't work.
            */
            .MathJax_PHTML { font-size: 110%; }
        </style>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js" async defer></script>
    </head>
    <body>
        <header class="site-header" role="banner">
            <div class="wrapper">
                <a class="site-title" rel="author" href="/">Erik Dominikus Research Group</a>
            </div>
        </header>
    <div style="display:none;">\(
    \renewcommand\emptyset{\varnothing}
    \newcommand\abs[1]{\left|#1\right|}
    \newcommand\dom{\textrm{dom}}
    \newcommand\cod{\textrm{cod}}
    \newcommand\Bernoulli{\textrm{Bernoulli}}
    \newcommand\Binomial{\textrm{Binomial}}
    \newcommand\Expect[1]{\mathbb{E}[#1]}
    \newcommand\Nat{\mathbb{N}}
    \newcommand\Integers{\mathbb{Z}}
    \newcommand\Real{\mathbb{R}}
    \newcommand\Rational{\mathbb{Q}}
    \newcommand\Complex{\mathbb{C}}
    \newcommand\Pr{\mathrm{P}}
    \newcommand\Time{\text{Time}}
    \newcommand\DTime{\text{DTime}}
    \newcommand\NTime{\text{NTime}}
    \newcommand\TimeP{\text{P}}
    \newcommand\TimeNP{\text{NP}}
    \newcommand\TimeExp{\text{ExpTime}}
    \newcommand\norm[1]{\left\lVert#1\right\rVert}
    \newcommand\bbA{\mathbb{A}}
    \newcommand\bbC{\mathbb{C}}
    \newcommand\bbD{\mathbb{D}}
    \newcommand\bbE{\mathbb{E}}
    \newcommand\bbN{\mathbb{N}}
    \newcommand\frakI{\mathfrak{I}}
    % deprecated; use TimeExp
    \newcommand\ExpTime{\text{ExpTime}}
    \newcommand\Compute{\text{Compute}}
    \newcommand\Search{\text{Search}}
    % model theory structure
    \newcommand\struc[1]{\mathcal{#1}}
    \)</div>
        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
                    <header class="post-header">
                        <h1 class="post-title">Parsing Research Group</h1>
                    </header>
                </article>
                <div class="post-content">
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1</span><span class="section_title"><a href="#what-is-parsing">What is parsing?</a></span><span class="word_count">(117w~1m)</span></li>
<li><span class="section_number">2</span><span class="section_title"><a href="#what-is-the-inverse-of-parsing">What is the inverse of parsing?</a></span><span class="word_count">(129w~1m)</span></li>
<li><span class="section_number">3</span><span class="section_title"><a href="#how-do-we-parse-how-should-we">How do we parse? How should we?</a></span><span class="word_count">(1952w~10m)</span></li>
<li><span class="section_number">4</span><span class="section_title"><a href="#conferences">Conferences</a></span><span class="word_count">(192w~1m)</span></li>
</ul>
</div>
<h2 id="what-is-parsing"><span class="section_number">1</span><span class="section_title">What is parsing?</span></h2>
<p>In 1550, &quot;to parse&quot; is &quot;to state the parts of speech in a sentence&quot;.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>Grammar is the what. Parsing is the how.</p>
<p>Parsing is relating strings and trees. Parsing is creating a tree from a string.</p>
<p>We say that a parser <em>implements</em> a grammar.</p>
<p>What is an alphabet? It may be the set of Unicode character code points. It may be the set of the tokens that a <em>lexical analyzer</em> may produce.</p>
<p>A parser <em>implements</em> a grammar, as a machine <em>implements</em> an algorithm.</p>
<p>A <em>lexer</em> is a degenerate<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> parser whose codomain is a list (which is a degenerate tree).</p>
<p>The parser is <em>parallelizable</em> if there exists a relatively fast function <span class="math inline">\(combine\)</span> such that for all <span class="math inline">\(x,y \in C^*\)</span>: <span class="math display">\[
P(xy) = combine(P(x), P(y))
\]</span></p>
<h2 id="what-is-the-inverse-of-parsing"><span class="section_number">2</span><span class="section_title">What is the inverse of parsing?</span></h2>
<p>The inverse of parsing is <em>unparsing</em> (tree linearization).</p>
<p>Parsing is the treeization (delinearization, deserialization) of a line. Unparsing is the linearization (serialization) of a tree.</p>
<p>Parsing is String -&gt; Maybe Tree. Unparsing is Tree -&gt; String.</p>
<p>Can we make parsing truly one-to-one? String -&gt; Tree. CST = AST. Very rigid syntax. Forbid whitespace freedom.</p>
<p>Another possibility: Inverse of parsing is anti-parsing (generation)? From grammar, generate all possible strings and their syntax trees.</p>
<p>Inverse of analytical grammar is generative grammar?</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Generative_grammar">https://en.wikipedia.org/wiki/Generative_grammar</a></li>
<li><a href="https://en.wikipedia.org/wiki/Formal_grammar#Analytic_grammars">https://en.wikipedia.org/wiki/Formal_grammar#Analytic_grammars</a></li>
</ul>
<p>Parser is syntax analyzer. Analysis is the opposite of synthesis? What is syntax synthesizer?</p>
<p>Inverse of parsing is pretty-printing?</p>
<p>If matching is analogous to subtraction, then what is analogous to multiplication? Generation?</p>
<ul>
<li><p>algebra of pretty-printing</p>
<ul>
<li>1995, Hughes, &quot;The design of a pretty-printing library&quot;</li>
<li>1998, Wadler, &quot;A prettier printer&quot;</li>
<li>Hughes, Peyton-Jones, et al., <a href="http://hackage.haskell.org/package/pretty-1.1.3.6/docs/Text-PrettyPrint-HughesPJ.html">http://hackage.haskell.org/package/pretty-1.1.3.6/docs/Text-PrettyPrint-HughesPJ.html</a></li>
</ul></li>
<li><a href="https://www.cs.kent.ac.uk/people/staff/oc/pretty.html">Efficient simple pretty printing combinators</a></li>
</ul>
<h2 id="how-do-we-parse-how-should-we"><span class="section_number">3</span><span class="section_title">How do we parse? How should we?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.1</span><span class="section_title"><a href="#how">How?</a></span><span class="word_count">(197w~1m)</span></li>
<li><span class="section_number">3.2</span><span class="section_title"><a href="#derivatives">Derivatives?</a></span><span class="word_count">(4w~1m)</span></li>
<li><span class="section_number">3.3</span><span class="section_title"><a href="#parsing-with-brzozowski-quotients">Parsing with Brzozowski quotients</a></span><span class="word_count">(207w~2m)</span></li>
<li><span class="section_number">3.4</span><span class="section_title"><a href="#incrementalonline-parsing">Incremental/online parsing</a></span><span class="word_count">(65w~1m)</span></li>
<li><span class="section_number">3.5</span><span class="section_title"><a href="#how-should-we-generate-parsers-and-unparsers-from-grammars">How should we generate parsers and unparsers from grammars?</a></span><span class="word_count">(117w~1m)</span></li>
<li><span class="section_number">3.6</span><span class="section_title"><a href="#what-parsing-techniquesformalisms-are-there">What parsing techniques/formalisms are there?</a></span><span class="word_count">(280w~2m)</span></li>
<li><span class="section_number">3.7</span><span class="section_title"><a href="#how-do-we-relate-cst-and-ast-without-clutter">How do we relate CST and AST without clutter?</a></span><span class="word_count">(19w~1m)</span></li>
<li><span class="section_number">3.8</span><span class="section_title"><a href="#direct-left-recursive-parsers-in-prolog">&lt;2018-11-02&gt; Direct left-recursive parsers in Prolog</a></span><span class="word_count">(13w~1m)</span></li>
<li><span class="section_number">3.9</span><span class="section_title"><a href="#relational-parsing-parsing-with-prolog">Relational parsing; parsing with Prolog</a></span><span class="word_count">(836w~5m)</span></li>
<li><span class="section_number">3.10</span><span class="section_title"><a href="#metainterpreter-for-left-recursive-parsing">Metainterpreter for left-recursive parsing?</a></span><span class="word_count">(8w~1m)</span></li>
<li><span class="section_number">3.11</span><span class="section_title"><a href="#what-is-left-recursion-and-how-should-we-handle-it">What is left-recursion, and how should we handle it?</a></span><span class="word_count">(166w~1m)</span></li>
<li><span class="section_number">3.12</span><span class="section_title"><a href="#inconclusive">Inconclusive</a></span><span class="word_count">(8w~1m)</span></li>
<li><span class="section_number">3.13</span><span class="section_title"><a href="#parsing">Parsing</a></span><span class="word_count">(38w~1m)</span></li>
</ul>
</div>
<h3 id="how"><span class="section_number">3.1</span><span class="section_title">How?</span></h3>
<p>Zaytsev &amp; Bagge 2014 <span class="citation" data-cites="zaytsev2014parsing">[<a href="#ref-zaytsev2014parsing">9</a>]</span> survey</p>
<p><span class="citation" data-cites="Mu2004AnIL">[<a href="#ref-Mu2004AnIL">6</a>]</span></p>
<p><span class="citation" data-cites="alimarine2005there">[<a href="#ref-alimarine2005there">1</a>]</span></p>
<p><span class="citation" data-cites="Kourzanov2014BidirectionalPA">[<a href="#ref-Kourzanov2014BidirectionalPA">3</a>]</span></p>
<p><span class="citation" data-cites="caballero1999functional">[<a href="#ref-caballero1999functional">2</a>]</span></p>
<p>somewhat unrelated <span class="citation" data-cites="Tan2016BidirectionalGF">[<a href="#ref-Tan2016BidirectionalGF">8</a>]</span></p>
<p><span class="citation" data-cites="Matsuda2013FliPprAP">[<a href="#ref-Matsuda2013FliPprAP">5</a>]</span></p>
<p>Parsing is also called &quot;syntax analysis&quot; (analysis = breakdown, syntax = put together).</p>
<p>Parsing is the act of modifying the <em>state</em> of the parser. This is the operational view.</p>
<p>Parsing is converting a sequence to a tree. This is the data view.</p>
<p>What is the difference between syntax and grammar?</p>
<p>We <em>lex</em> (perform lexical analysis / tokenization) to clean up the grammar (no need to mention whitespaces in the grammar).</p>
<p>Lexing simplifies grammars.</p>
<p>With lexing:</p>
<pre class="example"><code>exp ::= exp PLUS exp
</code></pre>
<p>Without lexing:</p>
<pre class="example"><code>white ::= ...
exp ::= exp white &quot;+&quot; white exp
</code></pre>
<p>&quot;Strictly speaking, tokenization may be handled by the parser. The reason why we tend to bother with tokenising in practice is that it makes the parser simpler, and decouples it from the character encoding used for the source code.&quot; (<a href="https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis">Wikibooks:Compiler construction</a>)</p>
<ul>
<li><a href="https://jeffreykegler.github.io/personal/timeline_v3">Parsing: a timeline – V3.0</a>: 2012 article about a history of parsing.
<ul>
<li><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/8cz97n/parsing_a_timeline_hopefully_this_puts_parsing_is/">Parsing: a timeline. Hopefully this puts &quot;Parsing is a solved problem&quot; to rest. : ProgrammingLanguages</a></li>
<li><a href="http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2018/05/knuth_1965.html">Why is parsing considered solved?</a></li>
</ul></li>
</ul>
<p>See the forest, not only the trees.</p>
<p>Some parsing techniques:</p>
<ul>
<li>recursive descent parser (writing a parser manually)</li>
<li>parser generators: Happy (Haskell), Bison (with Yacc)</li>
<li>parser combinators: Parsec (Haskell)</li>
<li>PEG (parsing expression grammar)</li>
<li>Brzozowski quotient</li>
<li>binary-parser description languages: ASN.1, Google Protobuf, Apache Thrift, Apache Avro</li>
<li>invertible parsing?</li>
<li><a href="https://en.wikipedia.org/wiki/Chart_parser">https://en.wikipedia.org/wiki/Chart_parser</a></li>
<li>Parsing Expression Grammar (PEG)
<ul>
<li><a href="https://github.com/harc/ohm/">https://github.com/harc/ohm/</a>
<ul>
<li><a href="https://ohmlang.github.io/">https://ohmlang.github.io/</a>
<ul>
<li><a href="https://harc.ycr.org/project/ohm/">https://harc.ycr.org/project/ohm/</a></li>
</ul></li>
</ul></li>
<li>Packrat</li>
</ul></li>
<li>2015, <a href="https://arxiv.org/abs/1511.08307">Nez: practical open grammar language</a></li>
<li>Earley parser
<ul>
<li><a href="https://en.wikipedia.org/wiki/Earley_parser">https://en.wikipedia.org/wiki/Earley_parser</a></li>
<li><a href="https://hackage.haskell.org/package/Earley">https://hackage.haskell.org/package/Earley</a></li>
</ul></li>
<li><a href="https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#parsing--pretty-printing">https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#parsing--pretty-printing</a>
<ul>
<li><a href="https://hackage.haskell.org/package/trifecta">https://hackage.haskell.org/package/trifecta</a></li>
<li><a href="https://hackage.haskell.org/package/parsers">https://hackage.haskell.org/package/parsers</a></li>
</ul></li>
<li>Parsing in Lisp and Racket <a href="https://stackoverflow.com/questions/21185879/writing-a-formal-language-parser-with-lisp">https://stackoverflow.com/questions/21185879/writing-a-formal-language-parser-with-lisp</a></li>
</ul>
<h3 id="derivatives"><span class="section_number">3.2</span><span class="section_title">Derivatives?</span></h3>
<p>Parsing with derivatives<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a><a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<p>Atoms<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
<p>Differentiating Parsers<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<h3 id="parsing-with-brzozowski-quotients"><span class="section_number">3.3</span><span class="section_title">Parsing with Brzozowski quotients</span></h3>
<p>Brzozowski quotient is like quotient in integer division, but for strings. (Formal definition?)</p>
<p>Why is Brzozowski quotient called Brzozowski derivative?</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Quotient_of_a_formal_language">Quotient of a formal language</a></li>
<li><p><a href="https://en.wikipedia.org/wiki/Brzozowski_derivative">Brzozowski derivative</a></p>
<ul>
<li><a href="https://arxiv.org/find/cs/1/au:+Brzozowski_J/0/1/0/all/0/1">Janusz Brzozowski et al. on arxiv</a></li>
</ul></li>
</ul>
<p>The <em>multiplication</em> of two strings <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> is the concatenation <span class="math inline">\(x \cdot y = x y\)</span>.</p>
<p>Multiplication is associative: <span class="math inline">\((xy)z = x(yz)\)</span>.</p>
<p>The <em>inverse</em> of a string <span class="math inline">\(x\)</span> is written <span class="math inline">\(x^{-1}\)</span>. It's hypothetical. It's pure symbolic manipulation. Don't imagine what it looks like. Do care about its properties:</p>
<ul>
<li>We define <span class="math inline">\(x^{-1} x = \epsilon\)</span>.</li>
<li>We define <span class="math inline">\(x x^{-1} = \epsilon\)</span>.</li>
<li>We define <span class="math inline">\((x y)^{-1} = x^{-1} y^{-1}\)</span>.</li>
</ul>
<p>The <em>left division</em> of a string <span class="math inline">\(x\)</span> by divisor <span class="math inline">\(y\)</span> is <span class="math inline">\(y^{-1} x\)</span>.</p>
<p>The <em>right division</em> of a string <span class="math inline">\(x\)</span> by divisor <span class="math inline">\(y\)</span> is <span class="math inline">\(x y^{-1}\)</span>.</p>
<p>How do we define quotient and remainder?</p>
<p>Perhaps Brzozowski's paper describes why it's called a derivative?</p>
<p>The multiplication of two languages <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is the Cartesian product <span class="math inline">\(AB = \\{ ab ~\|~ a \in A, b \in B \\}\)</span>.</p>
<ul>
<li>Differentiating Parsers Automatic derivation of incremental parser from a grammar or a non-incremental parser? Like automatic differentiation but generalized to any program? <a href="http://lambda-the-ultimate.org/node/3704">http://lambda-the-ultimate.org/node/3704</a></li>
<li><a href="http://matt.might.net/articles/implementation-of-regular-expression-matching-in-scheme-with-derivatives/">http://matt.might.net/articles/implementation-of-regular-expression-matching-in-scheme-with-derivatives/</a></li>
<li><a href="http://okmij.org/ftp/continuations/differentiating-parsers.html">http://okmij.org/ftp/continuations/differentiating-parsers.html</a></li>
<li><p>Parsing with derivatives?</p>
<ul>
<li><a href="https://hackage.haskell.org/package/derp">https://hackage.haskell.org/package/derp</a></li>
<li><a href="https://arxiv.org/abs/1010.5023">https://arxiv.org/abs/1010.5023</a></li>
<li><a href="http://matt.might.net/articles/parsing-with-derivatives/">http://matt.might.net/articles/parsing-with-derivatives/</a> &quot;Yacc is dead&quot;</li>
</ul></li>
<li><p>Brzozowski quotients.</p>
<ul>
<li><a href="https://arxiv.org/abs/1010.5023">Yacc is dead</a></li>
<li>&quot;Parsing with derivatives&quot;</li>
</ul></li>
<li><p>2017, <a href="https://www.cl.cam.ac.uk/~nk480/parsing.pdf">&quot;A Typed, Algebraic Approach to Parsing&quot;</a></p>
<ul>
<li>&quot;[…] we extend the notion of Brzozowski derivative from regular expressions to the typed context-free expressions.&quot;</li>
</ul></li>
</ul>
<h3 id="incrementalonline-parsing"><span class="section_number">3.4</span><span class="section_title">Incremental/online parsing</span></h3>
<p>How do IDEs not have to reparse the entire document when the user presses one keystroke?</p>
<p>Incremental parsing is parsing as input becomes available (without waiting for the whole input to become available).</p>
<ul>
<li><p>Type-directed automatic incrementalization</p>
<ul>
<li><a href="http://www.cs.cmu.edu/~joshuad/papers/incr/">http://www.cs.cmu.edu/~joshuad/papers/incr/</a></li>
</ul></li>
<li><p><a href="https://en.wikipedia.org/wiki/Incremental_computing">https://en.wikipedia.org/wiki/Incremental_computing</a></p>
<ul>
<li><a href="https://inc-lc.github.io/">https://inc-lc.github.io/</a></li>
</ul></li>
<li><a href="https://hackage.haskell.org/package/incremental-parser">https://hackage.haskell.org/package/incremental-parser</a></li>
<li><p><a href="https://yi-editor.github.io/posts/2014-09-04-incremental-parsing/">incremental/online parsing</a></p></li>
</ul>
<p>An <em>incremental</em> parser is a relation <span class="math inline">\(step \subseteq C \times T \times T\)</span>.</p>
<p>The idea is to output to all possible continuations? <span class="math inline">\(incrementalize : (C^* \to T) \to (C^* \to T^*)\)</span>?</p>
<h3 id="how-should-we-generate-parsers-and-unparsers-from-grammars"><span class="section_number">3.5</span><span class="section_title">How should we generate parsers and unparsers from grammars?</span></h3>
<p>What we are interested in is how to specify grammar, and how to derive a parser and unparser from grammar specificiation.</p>
<p>I expect the computer to infer a parser and a pretty-printer from the same grammar. Parser generators only give half of what I want.</p>
<p>I expect the computer to work with non-ambiguous left-recursive grammars.</p>
<p>How should parsing be done? From grammar description, the machine should generate both a parser and a pretty-printer.</p>
<p>Given grammar, generate both parser and unparser/pretty-printer.</p>
<ul>
<li><a href="http://www.semdesigns.com/Products/DMS/DMSPrettyPrinters.html?Home=DMSToolkit">http://www.semdesigns.com/Products/DMS/DMSPrettyPrinters.html?Home=DMSToolkit</a></li>
<li><a href="https://hackage.haskell.org/package/invertible-syntax-0.2.1/src/Example.lhs">https://hackage.haskell.org/package/invertible-syntax-0.2.1/src/Example.lhs</a></li>
<li><a href="https://hackage.haskell.org/package/invertible-syntax">https://hackage.haskell.org/package/invertible-syntax</a></li>
<li><a href="http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf">Tillmann Rendel and Klaus Ostermann. &quot;Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing&quot;. In Proc. of Haskell Symposium, 2010.</a></li>
<li><a href="http://jssst.or.jp/files/user/taikai/2016/PPL/ppl1-1.pdf">http://jssst.or.jp/files/user/taikai/2016/PPL/ppl1-1.pdf</a></li>
<li><a href="http://lambda-the-ultimate.org/node/4191">LTU: Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing</a></li>
<li><a href="http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf">Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing</a></li>
</ul>
<h3 id="what-parsing-techniquesformalisms-are-there"><span class="section_number">3.6</span><span class="section_title">What parsing techniques/formalisms are there?</span></h3>
<p>There are many techniques/formalisms:</p>
<ul>
<li>Prolog definite-clause grammar (DCG) rules</li>
<li>Haskell parser combinators</li>
<li>continuation-based parsing</li>
<li>parser generators</li>
</ul>
<p>Prolog DCG is interesting because it is often <em>reversible</em>: the same code often gives us both a parser and an unparser.</p>
<p>Logically, a production (a syntax rule) is a predicate (relation) of arity 2. That is, the rule <code>Exp ::= Num Op Num</code> is logically the Horn-clause <code>exp(A,D) :- num(A,B), op(B,C), num(C,D)</code>.</p>
<p>The application of a rule to an input-list produces a syntax object and a remaining-list. A syntax object contains the name of the rule that produces it, the part of the input that matches it, the input position, and so on. We can make this with SWI-Prolog dicts.</p>
<p>We can use Scheme continuation for backtracking like Prolog.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.6.1</span><span class="section_title"><a href="#syntax-objects">Syntax objects?</a></span><span class="word_count">(49w~1m)</span></li>
<li><span class="section_number">3.6.2</span><span class="section_title"><a href="#reversible-programming-bidirectional-programming">Reversible programming? Bidirectional programming?</a></span><span class="word_count">(112w~1m)</span></li>
</ul>
</div>
<h4 id="syntax-objects"><span class="section_number">3.6.1</span><span class="section_title">Syntax objects?</span></h4>
<p>The application of a rule to an input-list produces a syntax object and a remaining-list. A syntax object contains the name of the rule that produces it, the part of the input that matches it, the input position, and so on. We can make this with SWI-Prolog dicts.</p>
<h4 id="reversible-programming-bidirectional-programming"><span class="section_number">3.6.2</span><span class="section_title">Reversible programming? Bidirectional programming?</span></h4>
<p>Example: If <span class="math inline">\(T\)</span> is a terminal, then the nonterminal <span class="math inline">\(N \to T\)</span> is invertible. To parse, remove the prefix matching T from the input list. To unparse, prepend T to the input list.</p>
<p>If the rules <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are invertible, then the concatenation nonterminal <span class="math inline">\(N \to AB\)</span> is invertible.</p>
<p>Thus we say the relation <code>cons/3</code> is invertible: <code>cons(H,T,[H|T])</code>.</p>
<p>We want something similar to Rendell &amp; Ostermann 2010 <span class="citation" data-cites="rendel2010invertible">[<a href="#ref-rendel2010invertible">7</a>]</span>, but in Prolog instead of Haskell.</p>
<p>Given view : D -&gt; V and modv : V -&gt; V, the interpreter should be able to infer modd : D -&gt; D.</p>
<p>modd = through view modv</p>
<p>Boomerang language?</p>
<p>Benjamin C. Pierce 2006 &quot;The Weird World of Bi-Directional Programming&quot;<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a></p>
<p>Wikipedia<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a></p>
<p>Janus<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a><a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a></p>
<h3 id="how-do-we-relate-cst-and-ast-without-clutter"><span class="section_number">3.7</span><span class="section_title">How do we relate CST and AST without clutter?</span></h3>
<p>Big problems in parsing: lossless clutterless relation between CST and AST.</p>
<h3 id="direct-left-recursive-parsers-in-prolog"><span class="section_number">3.8</span><span class="section_title">&lt;2018-11-02&gt; Direct left-recursive parsers in Prolog</span></h3>
<p>The key: unify terminals before recursing into nonterminals.</p>
<pre class="example"><code>% S is a list of character codes.
binary_operator([0&#39;+]).
binary_operator([0&#39;*]).

digit(C) :- code_type(C, digit).

number(S) :-
    digit([S])
;   append([[A], B], S), digit(A), number(B);

expression(S) :-
    number(S)
;   binary_operator(B), append([A, B, C], S), expression(A), expression(C).
</code></pre>
<h3 id="relational-parsing-parsing-with-prolog"><span class="section_number">3.9</span><span class="section_title">Relational parsing; parsing with Prolog</span></h3>
<p>Parsing is turning a list into a tree.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.9.1</span><span class="section_title"><a href="#approaches">Approaches</a></span><span class="word_count">(66w~1m)</span></li>
<li><span class="section_number">3.9.2</span><span class="section_title"><a href="#determining-the-groundness-of-the-length-of-the-lists-involved-in-append3-and-append2">Determining the groundness of the length of the lists involved in append/3 and append/2</a></span><span class="word_count">(245w~2m)</span></li>
<li><span class="section_number">3.9.3</span><span class="section_title"><a href="#naive-approach-with-recognizer-membership-predicate">Naive approach with recognizer / membership predicate</a></span><span class="word_count">(226w~2m)</span></li>
<li><span class="section_number">3.9.4</span><span class="section_title"><a href="#prefix-remover-difference-list-recognizer-list-partitioner">Prefix remover / difference-list recognizer / list partitioner</a></span><span class="word_count">(156w~1m)</span></li>
<li><span class="section_number">3.9.5</span><span class="section_title"><a href="#definite-clause-grammars">Definite clause grammars</a></span><span class="word_count">(89w~1m)</span></li>
<li><span class="section_number">3.9.6</span><span class="section_title"><a href="#context-sensitive-grammars">Context-sensitive grammars?</a></span><span class="word_count">(8w~1m)</span></li>
<li><span class="section_number">3.9.7</span><span class="section_title"><a href="#libraries">Libraries?</a></span><span class="word_count">(8w~1m)</span></li>
<li><span class="section_number">3.9.8</span><span class="section_title"><a href="#left-recursion">Left recursion</a></span><span class="word_count">(23w~1m)</span></li>
<li><span class="section_number">3.9.9</span><span class="section_title"><a href="#precedence-parsing">Precedence parsing?</a></span><span class="word_count">(12w~1m)</span></li>
</ul>
</div>
<h4 id="approaches"><span class="section_number">3.9.1</span><span class="section_title">Approaches</span></h4>
<ul>
<li>2002 course notes <a href="http://www.cs.sfu.ca/~cameron/Teaching/383/DCG.html">http://www.cs.sfu.ca/~cameron/Teaching/383/DCG.html</a></li>
<li>1987 article &quot;Parsing and compiling using Prolog&quot; <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.101.9739&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.101.9739&amp;rep=rep1&amp;type=pdf</a></li>
<li>relational approach
<ul>
<li>recognizer: <code>digit(Input)</code>
<ul>
<li>recognizer with explicit search strategy</li>
</ul></li>
<li>prefix remover: <code>digit(Input, Unparsed_suffix)</code>
<ul>
<li>This is the approach used by Prolog DCG (definite clause grammar).</li>
</ul></li>
<li>prefix extractor: <code>digit(Input, Parsed_prefix, Unparsed_suffix)</code>
<ul>
<li>This enables us to get the parsed input without <code>append/3</code>.</li>
</ul></li>
<li>concrete syntax tree parser: <code>digit(Input, Parsed, Unparsed)</code> where <code>Parsed = number(Children)</code>.
<ul>
<li>An example of <code>Parsed</code> is <code>number(digit(1), number(digit(2)))</code>.</li>
</ul></li>
<li>interpreter</li>
</ul></li>
<li>functional approach
<ul>
<li>parser combinator</li>
</ul></li>
<li>generator approach
<ul>
<li>parser generator</li>
<li>parsing expression grammar</li>
</ul></li>
<li>procedural approach
<ul>
<li>recursive-descent</li>
</ul></li>
<li><a href="https://en.wikipedia.org/wiki/Garden-path_sentence">https://en.wikipedia.org/wiki/Garden-path_sentence</a></li>
</ul>
<h4 id="determining-the-groundness-of-the-length-of-the-lists-involved-in-append3-and-append2"><span class="section_number">3.9.2</span><span class="section_title">Determining the groundness of the length of the lists involved in append/3 and append/2</span></h4>
<ol>
<li><p>Why do we care?</p>
<p>Because we want to write naive parsers that terminate.</p></li>
<li><p>What?</p>
<p>From the source code of SWI-Prolog, with some modifications:</p>
<ul>
<li><a href="http://www.swi-prolog.org/pldoc/doc/_SWI_/library/lists.pl?show=src#append/3">http://www.swi-prolog.org/pldoc/doc/_SWI_/library/lists.pl?show=src#append/3</a></li>
</ul>
<p>&quot;Ground&quot; here is an adjective, not a noun. A term is <em>ground</em> iff it has no variables. A term is non-ground otherwise.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb4-1" title="1">append([]<span class="kw">,</span> <span class="dt">L</span><span class="kw">,</span> <span class="dt">L</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb4-2" title="2">append([<span class="dt">H</span><span class="fu">|</span><span class="dt">T</span>]<span class="kw">,</span> <span class="dt">L</span><span class="kw">,</span> [<span class="dt">H</span><span class="fu">|</span><span class="dt">R</span>]) <span class="kw">:-</span></a>
<a class="sourceLine" id="cb4-3" title="3">    append(<span class="dt">T</span><span class="kw">,</span> <span class="dt">L</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5">append([]<span class="kw">,</span> [])<span class="kw">.</span></a>
<a class="sourceLine" id="cb4-6" title="6">append([<span class="dt">L</span><span class="fu">|</span><span class="dt">Ls</span>]<span class="kw">,</span> <span class="dt">As</span>) <span class="kw">:-</span></a>
<a class="sourceLine" id="cb4-7" title="7">    append(<span class="dt">L</span><span class="kw">,</span> <span class="dt">Ws</span><span class="kw">,</span> <span class="dt">As</span>)<span class="kw">,</span></a>
<a class="sourceLine" id="cb4-8" title="8">    append(<span class="dt">Ls</span><span class="kw">,</span> <span class="dt">Ws</span>)<span class="kw">.</span></a></code></pre></div>
<p>We say that a list is <em>length-ground</em> iff its length is ground, and <em>length-unground</em> otherwise. The elements don't have to be ground.</p>
<ul>
<li>The empty list is length-ground.</li>
<li>A list [_|T] is length-ground iff T is length-ground.</li>
<li>If a variable gets unified with a length-ground list, then the variable is length-ground.</li>
</ul>
<p>To analyze length-groundedness, we &quot;reverse&quot; the program.</p>
<pre class="example"><code>% append(T, L, R)
append([], L, L).
append(T, L, R) =&gt; append([H|T], L, [H|R]).
</code></pre>
<p>(Length-ground = proper list?)</p>
<p>Now we can infer these about append(T, L, R):</p>
<ul>
<li>If T = [], then L and R have the same length-groundness.</li>
<li>The recursive case:
<ul>
<li>Iff T is length-ground, then [H|T] is length-ground.</li>
<li>Iff R is length-ground, then [H|R] is length-ground.</li>
</ul></li>
<li>If we want L to be length-ground, then R has to be length-ground.</li>
<li>Thus we can infer that L and R have the same length-groundness regardless of the length-groundness of T.</li>
</ul>
<p>If append(A, B, C) succeeds, then:</p>
<ul>
<li>If A = [], then B and C have the same length-groundness.</li>
<li>If two of A, B, C are length-ground, then the other one is length-ground?</li>
<li>If two of A, B, C are length-unground, then the other one is length-unground?</li>
</ul>
<p>What?</p>
<ul>
<li>2002 article &quot;Efficient Groundness Analysis in Prolog&quot; <a href="https://arxiv.org/abs/cs/0201012">https://arxiv.org/abs/cs/0201012</a>
<ul>
<li><a href="https://github.com/pschachte/groundness">https://github.com/pschachte/groundness</a></li>
</ul></li>
</ul></li>
<li><p>How do we generate a long list in Prolog, for testing?</p>
<ol>
<li><p>How do we say &quot;A is a list of 100 equal elements&quot; in Prolog?</p></li>
</ol></li>
</ol>
<h4 id="naive-approach-with-recognizer-membership-predicate"><span class="section_number">3.9.3</span><span class="section_title">Naive approach with recognizer / membership predicate</span></h4>
<p>A <em>recognizer</em> is a unary predicate that takes a list of character codes.</p>
<p>Another possible names for recognizer are <em>acceptor</em>, <em>determiner</em>, <em>decider</em>, <em>membership predicate</em>.</p>
<p>Example: The following <code>digit</code> predicate recognizes ASCII decimal digits.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb6-1" title="1">digit([<span class="dt">D</span>]) <span class="kw">:-</span> code_type(<span class="dt">D</span><span class="kw">,</span> digit)<span class="kw">.</span></a></code></pre></div>
<p>We can build recognizers on other recognizers. For example, here we use <code>digit</code> to define <code>number_</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb7-1" title="1"><span class="co">% We append underscore because =number= is a reserved Prolog predicate.</span></a>
<a class="sourceLine" id="cb7-2" title="2">number_([<span class="dt">H</span>]) <span class="kw">:-</span> digit([<span class="dt">H</span>])<span class="kw">.</span></a>
<a class="sourceLine" id="cb7-3" title="3">number_([<span class="dt">H</span><span class="fu">|</span><span class="dt">T</span>]) <span class="kw">:-</span> digit([<span class="dt">H</span>])<span class="kw">,</span> number_(<span class="dt">T</span>)<span class="kw">.</span></a></code></pre></div>
<p>That Prolog knowledge base corresponds to this context-free grammar:</p>
<pre><code>digit ::= &lt;a digit character as defined by Unicode&gt;
number ::= digit | digit number
</code></pre>
<p>Exercise:</p>
<ul>
<li>Here you will compare depth-first search and iterative deepening search, and understand search completeness.</li>
<li>Try the query <code>number_(S)</code>.</li>
<li>Try the query <code>length(S,_), number_(S)</code>.</li>
<li>If you keep pressing semicolon in the first query, will you ever encounter <code>S = [48,49]</code>?</li>
</ul>
<ol>
<li><p>A cool thing: recognizers are generators.</p>
<p>The predicate <code>number_</code> can be used not only to recognize strings, but also to <em>generate</em> all such strings.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb9-1" title="1"><span class="co">% Press ; to generate the next possibility.</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">% Press . to stop.</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="fu">?-</span> length(<span class="dt">S</span><span class="kw">,</span><span class="dt">_</span>)<span class="kw">,</span> number_(<span class="dt">S</span>)<span class="kw">.</span></a></code></pre></div>
<p>To understand how that works, we have to understand Prolog backtracking.</p></li>
<li><p>Left recursion thwarts the naive approach.</p>
<p>Problem: The following <code>expression</code> doesn't terminate.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb10-1" title="1">operator([<span class="dt">A</span>]) <span class="kw">:-</span> string_codes(<span class="ot">&quot;+&quot;</span><span class="kw">,</span> <span class="dt">Ops</span>)<span class="kw">,</span> member(<span class="dt">A</span><span class="kw">,</span> <span class="dt">Ops</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3">expression(<span class="dt">E</span>) <span class="kw">:-</span> number_(<span class="dt">E</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb10-4" title="4">expression(<span class="dt">E</span>) <span class="kw">:-</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="kw">,</span> append([<span class="dt">A</span>, <span class="dt">B</span>, <span class="dt">C</span>]<span class="kw">,</span> <span class="dt">E</span>)</a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="kw">,</span> expression(<span class="dt">A</span>)</a>
<a class="sourceLine" id="cb10-7" title="7">    <span class="kw">,</span> operator(<span class="dt">B</span>)</a>
<a class="sourceLine" id="cb10-8" title="8">    <span class="kw">,</span> expression(<span class="dt">C</span>)</a>
<a class="sourceLine" id="cb10-9" title="9">    <span class="kw">.</span></a></code></pre></div>
<p>The corresponding context-free grammar is left-recursive:</p>
<pre><code>expression ::= number | expression operator expression
</code></pre>
<p>We don't want to sacrifice the elegance of the description.</p></li>
<li><p>Can memoization (tabling) help speed up the naive approach?</p>
<p>No.</p></li>
<li><p>Another naive approach that works.</p>
<p>This one works.</p>
<p>The key is:</p>
<ul>
<li>Put grounding goals first. A grounding goal is a goal that grounds its variables.</li>
<li><p>Be careful with the pattern <code>g, u</code> where <code>g</code> generates ungrounded terms and <code>u</code> fails, because it may cause infinite loop when Prolog backtracks, because Prolog continues to generate fresh variables. For example, this doesn't terminate:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb12-1" title="1"><span class="fu">?-</span> length(<span class="dt">L</span><span class="kw">,</span> <span class="dt">N</span>)<span class="kw">,</span> <span class="kw">fail.</span></a></code></pre></div>
<ul>
<li>If <code>p</code> may generate infinite choice points, then <code>p, fail</code> doesn't terminate.</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb13-1" title="1">digit([<span class="dt">C</span>]) <span class="kw">:-</span> code_type(<span class="dt">C</span><span class="kw">,</span> digit)<span class="kw">.</span></a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3">number_([<span class="dt">H</span>]) <span class="kw">:-</span> digit([<span class="dt">H</span>])<span class="kw">.</span></a>
<a class="sourceLine" id="cb13-4" title="4">number_([<span class="dt">H</span><span class="fu">|</span><span class="dt">T</span>]) <span class="kw">:-</span> digit([<span class="dt">H</span>])<span class="kw">,</span> number_(<span class="dt">T</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb13-5" title="5"></a>
<a class="sourceLine" id="cb13-6" title="6">operator([<span class="bn">0&#39;+</span>])<span class="kw">.</span></a>
<a class="sourceLine" id="cb13-7" title="7"></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="co">% expression(Meaning,Codes) may not work if Codes is ungrounded.</span></a>
<a class="sourceLine" id="cb13-9" title="9">expression(<span class="dt">number</span>(<span class="dt">E</span>)<span class="kw">,</span> <span class="dt">E</span>) <span class="kw">:-</span> number_(<span class="dt">E</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb13-10" title="10">expression(plus(<span class="dt">MA</span><span class="kw">,</span><span class="dt">MC</span>)<span class="kw">,</span> <span class="dt">E</span>) <span class="kw">:-</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb13-11" title="11">    <span class="kw">,</span> operator(<span class="dt">EB</span>) <span class="co">% Put grounding goals first.</span></a>
<a class="sourceLine" id="cb13-12" title="12">    <span class="kw">,</span> append([<span class="dt">EA</span>,<span class="dt">EB</span>,<span class="dt">EC</span>]<span class="kw">,</span> <span class="dt">E</span>) <span class="co">% Thus B is grounded.</span></a>
<a class="sourceLine" id="cb13-13" title="13">    <span class="kw">,</span> expression(<span class="dt">MA</span><span class="kw">,</span><span class="dt">EA</span>)</a>
<a class="sourceLine" id="cb13-14" title="14">    <span class="kw">,</span> expression(<span class="dt">MC</span><span class="kw">,</span><span class="dt">EC</span>)</a>
<a class="sourceLine" id="cb13-15" title="15">    <span class="kw">.</span></a></code></pre></div></li>
</ol>
<h4 id="prefix-remover-difference-list-recognizer-list-partitioner"><span class="section_number">3.9.4</span><span class="section_title">Prefix remover / difference-list recognizer / list partitioner</span></h4>
<p>We can turn the naive recognizer <code>digit/1</code> into difference-list recognizer <code>digit/2</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb14-1" title="1">digit([<span class="dt">D</span>]) <span class="kw">:-</span> code_type(<span class="dt">D</span><span class="kw">,</span> digit)<span class="kw">.</span></a></code></pre></div>
<ul>
<li>The first parameter is the input string, say Input.</li>
<li>The second parameter is the recognized prefix of Input.</li>
<li>The third parameter is the unrecognized suffix of Input.</li>
</ul>
<p>In the following, P stands for Parsed, and U stands for Unparsed.</p>
<p>We can turn the recognizer into:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb15-1" title="1"><span class="co">% Prefix remover.</span></a>
<a class="sourceLine" id="cb15-2" title="2">digit([<span class="dt">P</span><span class="fu">|</span><span class="dt">U</span>]<span class="kw">,</span> <span class="dt">U</span>) <span class="kw">:-</span> code_type(<span class="dt">P</span><span class="kw">,</span> digit)<span class="kw">.</span></a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="co">% List partitioner.</span></a>
<a class="sourceLine" id="cb15-5" title="5">digit([<span class="dt">P</span><span class="fu">|</span><span class="dt">U</span>]<span class="kw">,</span> [<span class="dt">P</span>]<span class="kw">,</span> <span class="dt">U</span>) <span class="kw">:-</span> code_type(<span class="dt">P</span><span class="kw">,</span> digit)<span class="kw">.</span></a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="co">% The list partitioner can be derived from the prefix remover:</span></a>
<a class="sourceLine" id="cb15-8" title="8"><span class="co">% digit(U0, P0, U1) :- digit(U0, U1), append(P0, U1, U0).</span></a>
<a class="sourceLine" id="cb15-9" title="9"></a>
<a class="sourceLine" id="cb15-10" title="10">number_(<span class="dt">U0</span><span class="kw">,</span> <span class="dt">U1</span>) <span class="kw">:-</span> digit(<span class="dt">U0</span><span class="kw">,</span> <span class="dt">U1</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb15-11" title="11"></a>
<a class="sourceLine" id="cb15-12" title="12">number_(<span class="dt">U0</span><span class="kw">,</span> <span class="dt">P0</span><span class="kw">,</span> <span class="dt">U1</span>) <span class="kw">:-</span> digit(<span class="dt">U0</span><span class="kw">,</span> <span class="dt">P0</span><span class="kw">,</span> <span class="dt">U1</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb15-13" title="13">number_(<span class="dt">U0</span><span class="kw">,</span> <span class="dt">P2</span><span class="kw">,</span> <span class="dt">U2</span>) <span class="kw">:-</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb15-14" title="14">    <span class="kw">,</span> digit(<span class="dt">U0</span><span class="kw">,</span> <span class="dt">P0</span><span class="kw">,</span> <span class="dt">U1</span>)</a>
<a class="sourceLine" id="cb15-15" title="15">    <span class="kw">,</span> number_(<span class="dt">U1</span><span class="kw">,</span> <span class="dt">P1</span><span class="kw">,</span> <span class="dt">U2</span>)</a>
<a class="sourceLine" id="cb15-16" title="16">    <span class="kw">,</span> append(<span class="dt">P0</span><span class="kw">,</span> <span class="dt">P1</span><span class="kw">,</span> <span class="dt">P2</span>)</a>
<a class="sourceLine" id="cb15-17" title="17">    <span class="kw">.</span></a></code></pre></div>
<p>The meaning of <code>number_(U0, P0, U1)</code> is:</p>
<ul>
<li>P0 is a number.</li>
<li>P0 is a prefix of U0.</li>
<li>U0 is the concatenation of P0 and U1.</li>
</ul>
<p>Observe how we &quot;thread&quot; the state. The calls in the body follow the pattern <code>something(U&lt;n&gt;, P&lt;n&gt;, U&lt;n+1&gt;)</code>.</p>
<p>We can translate a recognizer into a difference-list recognizer.</p>
<p>The cool thing is that each parameter works both ways.</p>
<ul>
<li>The query <code>string_codes(&quot;123&quot;, A), number_(A, A, [])</code> asks Prolog to find out whether &quot;123&quot; parses as a number.</li>
<li>The query <code>length(A, _), number_(A, A, []).</code> asks Prolog to find a string that parse as a number. You can keep pressing <code>;</code> to generate the next strings.</li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb16-1" title="1">operator([<span class="dt">P</span><span class="fu">|</span><span class="dt">U</span>]<span class="kw">,</span> [<span class="dt">P</span>]<span class="kw">,</span> <span class="dt">U</span>) <span class="kw">:-</span> string_codes(<span class="ot">&quot;+&quot;</span><span class="kw">,</span> <span class="dt">Codes</span>)<span class="kw">,</span> member(<span class="dt">P</span><span class="kw">,</span> <span class="dt">Codes</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3">expression(<span class="dt">U0</span><span class="kw">,</span> <span class="dt">P0</span><span class="kw">,</span> <span class="dt">U1</span>) <span class="kw">:-</span> number_(<span class="dt">U0</span><span class="kw">,</span> <span class="dt">P0</span><span class="kw">,</span> <span class="dt">U1</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb16-4" title="4">expression(<span class="dt">U0</span><span class="kw">,</span> <span class="dt">P0</span><span class="kw">,</span> <span class="dt">U1</span>) <span class="kw">:-</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb16-5" title="5">    <span class="kw">,</span> expression(<span class="dt">U0</span><span class="kw">,</span> <span class="dt">P0</span><span class="kw">,</span> <span class="dt">U1</span>)</a>
<a class="sourceLine" id="cb16-6" title="6">    <span class="kw">,</span> operator(<span class="dt">U1</span><span class="kw">,</span> <span class="dt">P1</span><span class="kw">,</span> <span class="dt">U2</span>)</a>
<a class="sourceLine" id="cb16-7" title="7">    <span class="kw">,</span> expression(<span class="dt">U2</span><span class="kw">,</span> <span class="dt">P2</span><span class="kw">,</span> <span class="dt">U3</span>)</a>
<a class="sourceLine" id="cb16-8" title="8">    <span class="kw">.</span></a></code></pre></div>
<h4 id="definite-clause-grammars"><span class="section_number">3.9.5</span><span class="section_title">Definite clause grammars</span></h4>
<ul>
<li>The DCG clause <code>left --&gt; right</code> desugars/expands/translates into the definite clause <code>left(U0, U1) :- ...</code> where:
<ul>
<li>U0 is the input.</li>
<li>U1 is the suffix of U0 that is not recognized by the DCG clause.</li>
<li>The string recognized by the clause is the difference between U0 and U1. That string is the P such that U0 = P + U1 where + denotes list concatenation.</li>
</ul></li>
<li>&quot;Interesting Things about Prolog&quot; <a href="https://gist.github.com/CMCDragonkai/89a6c502ca7272e5e7464c0fc8667f4d">https://gist.github.com/CMCDragonkai/89a6c502ca7272e5e7464c0fc8667f4d</a>
<ul>
<li>&quot;Definite clause grammars (DCG) make the difference list pattern into a first class primitive with the <code>--&gt;</code> operator.&quot;</li>
</ul></li>
</ul>
<ol>
<li><p>Why does this naive DCG fail?</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb17-1" title="1">digit <span class="kw">--&gt;</span> [<span class="dt">Code</span>]<span class="kw">,</span> <span class="kw">{</span>code_type(<span class="dt">Code</span><span class="kw">,</span> digit)<span class="kw">}.</span></a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="dt">number</span> <span class="kw">--&gt;</span></a>
<a class="sourceLine" id="cb17-4" title="4">    digit<span class="kw">,</span> <span class="dt">number</span></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="kw">;</span>   digit</a>
<a class="sourceLine" id="cb17-6" title="6"><span class="kw">.</span></a>
<a class="sourceLine" id="cb17-7" title="7"></a>
<a class="sourceLine" id="cb17-8" title="8">operator <span class="kw">--&gt;</span> <span class="ot">&quot;+&quot;</span><span class="kw">.</span></a>
<a class="sourceLine" id="cb17-9" title="9"></a>
<a class="sourceLine" id="cb17-10" title="10">expression <span class="kw">--&gt;</span></a>
<a class="sourceLine" id="cb17-11" title="11">    <span class="dt">number</span></a>
<a class="sourceLine" id="cb17-12" title="12"><span class="kw">;</span>   expression<span class="kw">,</span> operator<span class="kw">,</span> expression</a>
<a class="sourceLine" id="cb17-13" title="13"><span class="kw">.</span></a></code></pre></div></li>
</ol>
<h4 id="context-sensitive-grammars"><span class="section_number">3.9.6</span><span class="section_title">Context-sensitive grammars?</span></h4>
<p>We can add context by adding parameter.</p>
<h4 id="libraries"><span class="section_number">3.9.7</span><span class="section_title">Libraries?</span></h4>
<ul>
<li><a href="https://github.com/cbaziotis/prolog-cfg-parser">https://github.com/cbaziotis/prolog-cfg-parser</a></li>
<li>This isn't Prolog, but this looks awesome <a href="https://github.com/Engelberg/instaparse/blob/master/README.md">https://github.com/Engelberg/instaparse/blob/master/README.md</a></li>
</ul>
<h4 id="left-recursion"><span class="section_number">3.9.8</span><span class="section_title">Left recursion</span></h4>
<p>Mathematics handles left recursion just fine. Computers should too. We shouldn't chicken out. We shouldn't compromise by working around our grammar descriptions.</p>
<h4 id="precedence-parsing"><span class="section_number">3.9.9</span><span class="section_title">Precedence parsing?</span></h4>
<ul>
<li>1996 article &quot;An Operator Precedence Parser for Standard Prolog Text&quot; <a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/%28SICI%291097-024X%28199607%2926%3A7%3C763%3A%3AAID-SPE33%3E3.0.CO%3B2-L">https://onlinelibrary.wiley.com/doi/abs/10.1002/%28SICI%291097-024X%28199607%2926%3A7%3C763%3A%3AAID-SPE33%3E3.0.CO%3B2-L</a></li>
</ul>
<h3 id="metainterpreter-for-left-recursive-parsing"><span class="section_number">3.10</span><span class="section_title">Metainterpreter for left-recursive parsing?</span></h3>
<p>&quot;Parsing with left-recursive grammars&quot; <a href="https://www.metalevel.at/acomip/">https://www.metalevel.at/acomip/</a></p>
<h3 id="what-is-left-recursion-and-how-should-we-handle-it"><span class="section_number">3.11</span><span class="section_title">What is left-recursion, and how should we handle it?</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.11.1</span><span class="section_title"><a href="#should-we-blame-left-recursion-on-naive-operational-semantics">Should we blame left-recursion on naive operational semantics?</a></span><span class="word_count">(20w~1m)</span></li>
<li><span class="section_number">3.11.2</span><span class="section_title"><a href="#handling-left-recursion">Handling left-recursion</a></span><span class="word_count">(87w~1m)</span></li>
<li><span class="section_number">3.11.3</span><span class="section_title"><a href="#left-recursive-parsing">Left-recursive parsing</a></span><span class="word_count">(53w~1m)</span></li>
</ul>
</div>
<h4 id="should-we-blame-left-recursion-on-naive-operational-semantics"><span class="section_number">3.11.1</span><span class="section_title">Should we blame left-recursion on naive operational semantics?</span></h4>
<p>Mathematics has no problem with left-recursion. Why should computers have problem with left-recursion?</p>
<h4 id="handling-left-recursion"><span class="section_number">3.11.2</span><span class="section_title">Handling left-recursion</span></h4>
<p>Laurent and Mens 2016 <span class="citation" data-cites="laurent2016taming">[<a href="#ref-laurent2016taming">4</a>]</span> (some emphasis ours): &quot;When a parser invokes itself (either directly or indirectly through intermediate parsers) without intervening state changes, the result is an infinite loop of parser invocations. This is a well-known problem of top-down recursive parsers, called <em>left-recursion</em>. Fortunately, it can be <em>mitigated</em> as follows: start by running the left-recursive parser <em>while failing all left-recursive invocations</em>, then re-run it, using the result of the initial parse as the result of all left-recursive invocations.&quot;</p>
<p>Avoiding left-recursion means always consuming something before recursing.</p>
<h4 id="left-recursive-parsing"><span class="section_number">3.11.3</span><span class="section_title">Left-recursive parsing</span></h4>
<p>2009 Direct Left-Recursive Parsing Expressing Grammars <a href="https://www.semanticscholar.org/paper/Direct-Left-Recursive-Parsing-Expressing-Grammars-Tratt/b1e8309db5537fb15f51071fcdc39e139659ed15">https://www.semanticscholar.org/paper/Direct-Left-Recursive-Parsing-Expressing-Grammars-Tratt/b1e8309db5537fb15f51071fcdc39e139659ed15</a></p>
<p>2008 Packrat Parsers Can Support Left Recursion</p>
<p>Naive recognizer + memoization</p>
<p>list_not_empty</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb18-1" title="1">exp(<span class="dt">S</span>) <span class="kw">:-</span> is_list(<span class="dt">S</span>)<span class="kw">,</span> append([<span class="dt">A</span>,[<span class="bn">0&#39;+</span>],<span class="dt">C</span>]<span class="kw">,</span><span class="dt">S</span>)<span class="kw">,</span> exp(<span class="dt">A</span>)<span class="kw">,</span> exp(<span class="dt">C</span>)<span class="kw">.</span></a></code></pre></div>
<p>Consume before recursing?</p>
<p>We can't piggyback Prolog's unification for lambda calculus substitution, because Prolog unifies same-named variables while lambda-calculus shadows same-named variables.</p>
<p>If the recursive call has smaller arguments than the parent call does, then the predicate should terminate.</p>
<h3 id="inconclusive"><span class="section_number">3.12</span><span class="section_title">Inconclusive</span></h3>
<p>1997 inconclusive discussion &quot;Prolog Parser in Prolog&quot; <a href="https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/parser.html">https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/parser.html</a></p>
<h3 id="parsing"><span class="section_number">3.13</span><span class="section_title">Parsing</span></h3>
<p>&quot;Parsing in Prolog&quot; <a href="http://www.cs.sfu.ca/~cameron/Teaching/383/DCG.html">http://www.cs.sfu.ca/~cameron/Teaching/383/DCG.html</a></p>
<p>&quot;Jacc's LR-Parsing with Dynamic Operators&quot; &quot;This part of the Jacc documentation explains the modifications we can make to a basic table-driven LR parser generator à la yacc to accommodate support for Prolog's dynamic operators.&quot; <a href="http://www.hassan-ait-kaci.net/hlt/doc/hlt/jaccdoc/dynamicLR.html">http://www.hassan-ait-kaci.net/hlt/doc/hlt/jaccdoc/dynamicLR.html</a></p>
<h2 id="conferences"><span class="section_number">4</span><span class="section_title">Conferences</span></h2>
<p>ACM SIGPLAN SLE <a href="http://www.sleconf.org/blog/11-20-2013-parsing-at-sle-2013">http://www.sleconf.org/blog/11-20-2013-parsing-at-sle-2013</a></p>
<div id="refs" class="references">
<div id="ref-alimarine2005there">
<p>[1] Alimarine, A. et al. 2005. There and back again: Arrows for invertible programming. <em>Proceedings of the 2005 acm sigplan workshop on haskell</em> (2005), 86–97. url: &lt;<a href="https://www.cs.ru.nl/~marko/research/pubs/2005/bi-arrows.pdf">https://www.cs.ru.nl/~marko/research/pubs/2005/bi-arrows.pdf</a>&gt;.</p>
</div>
<div id="ref-caballero1999functional">
<p>[2] Caballero, R. and López-Fraguas, F.J. 1999. A functional-logic perspective of parsing. <em>International symposium on functional and logic programming</em> (1999), 85–99. url: &lt;<a href="https://pdfs.semanticscholar.org/a87f/56ad2113060650afb230aa9182cbe845041e.pdf">https://pdfs.semanticscholar.org/a87f/56ad2113060650afb230aa9182cbe845041e.pdf</a>&gt;.</p>
</div>
<div id="ref-Kourzanov2014BidirectionalPA">
<p>[3] Kourzanov, P. 2014. Bidirectional parsing a functional / logic perspective. (2014). url: &lt;<a href="https://ifl2014.github.io/submissions/ifl2014_submission_18.pdf">https://ifl2014.github.io/submissions/ifl2014_submission_18.pdf</a>&gt;.</p>
</div>
<div id="ref-laurent2016taming">
<p>[4] Laurent, N. and Mens, K. 2016. Taming context-sensitive languages with principled stateful parsing. <em>Proceedings of the 2016 acm sigplan international conference on software language engineering</em> (2016), 15–27. url: &lt;<a href="http://arxiv.org/abs/1609.05365">http://arxiv.org/abs/1609.05365</a>&gt;.</p>
</div>
<div id="ref-Matsuda2013FliPprAP">
<p>[5] Matsuda, K. and Wang, M. 2013. FliPpr: A prettier invertible printing system. <em>ESOP</em> (2013). url: &lt;<a href="http://www2.sf.ecei.tohoku.ac.jp/~kztk/papers/kztk_esop2013.pdf">http://www2.sf.ecei.tohoku.ac.jp/~kztk/papers/kztk_esop2013.pdf</a>&gt;.</p>
</div>
<div id="ref-Mu2004AnIL">
<p>[6] Mu, S.-C. et al. 2004. An injective language for reversible computation. <em>MPC</em> (2004). url: &lt;<a href="http://takeichi.ipl-lab.org/~scm/pub/reversible.pdf">http://takeichi.ipl-lab.org/~scm/pub/reversible.pdf</a>&gt;.</p>
</div>
<div id="ref-rendel2010invertible">
<p>[7] Rendel, T. and Ostermann, K. 2010. Invertible syntax descriptions: Unifying parsing and pretty printing. <em>ACM sigplan notices</em> (2010), 1–12. url: &lt;<a href="http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf">http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf</a>&gt;.</p>
</div>
<div id="ref-Tan2016BidirectionalGF">
<p>[8] Tan, G. and Morrisett, J.G. 2016. Bidirectional grammars for machine-code decoding and encoding. <em>Journal of Automated Reasoning</em>. 60, (2016), 257–277. url: &lt;<a href="http://www.cse.psu.edu/~gxt29/papers/bigrammar_jar.pdf">http://www.cse.psu.edu/~gxt29/papers/bigrammar_jar.pdf</a>&gt;.</p>
</div>
<div id="ref-zaytsev2014parsing">
<p>[9] Zaytsev, V. and Bagge, A.H. 2014. Parsing in a broad sense. <em>International conference on model driven engineering languages and systems</em> (2014), 50–67. url: &lt;<a href="https://bora.uib.no/bitstream/handle/1956/8938/zaytsev-bagge-models14-parsing.pdf">https://bora.uib.no/bitstream/handle/1956/8938/zaytsev-bagge-models14-parsing.pdf</a>&gt;.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://www.etymonline.com/word/parse">https://www.etymonline.com/word/parse</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><a href="https://en.wikipedia.org/wiki/Degeneracy_(mathematics)">https://en.wikipedia.org/wiki/Degeneracy_(mathematics)</a><a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><a href="http://matt.might.net/articles/parsing-with-derivatives/">http://matt.might.net/articles/parsing-with-derivatives/</a><a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><a href="https://github.com/webyrd/relational-parsing-with-derivatives/blob/master/README.md">https://github.com/webyrd/relational-parsing-with-derivatives/blob/master/README.md</a><a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><a href="https://blog.github.com/2018-10-31-atoms-new-parsing-system/">https://blog.github.com/2018-10-31-atoms-new-parsing-system/</a><a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><a href="http://lambda-the-ultimate.org/node/3704">http://lambda-the-ultimate.org/node/3704</a><a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p><a href="https://www.cis.upenn.edu/~bcpierce/papers/lenses-etapsslides.pdf">https://www.cis.upenn.edu/~bcpierce/papers/lenses-etapsslides.pdf</a><a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p><a href="https://en.wikipedia.org/wiki/Bidirectional_transformation">https://en.wikipedia.org/wiki/Bidirectional_transformation</a><a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p><a href="https://topps.diku.dk/pirc/?id=janus">https://topps.diku.dk/pirc/?id=janus</a><a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p><a href="https://en.wikipedia.org/wiki/Janus_(time-reversible_computing_programming_language)">https://en.wikipedia.org/wiki/Janus_(time-reversible_computing_programming_language)</a><a href="#fnref10" class="footnote-back">↩</a></p></li>
</ol>
</section>
                </div>
            </div>
        </main>
                        <div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
var disqus_config = function () {
    this.page.url = "https://edom.github.io/parse.html";  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = "https://edom.github.io/parse.html"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://edom-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                        <footer class="site-footer h-card">
            <data class="u-url" href="/"></data>
            <div class="wrapper">
                <p>This page was created on 2018-04-11 00:00 +0700.</p>
                <p class="rss-subscribe">There is an
                    <a href="/feed.xml">RSS feed</a>, but it's unused because this site is a wiki, not a blog.</p>
                <p>Stop writing books, papers, and blogs!
                    Write a personal wiki instead!
                    Or, even better, contribute to a community wiki.
                </p>
            </div>
        </footer>
    </body>
</html>
