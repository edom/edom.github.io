<!DOCTYPE html>
<html lang="en">

    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Relational-bidirectional-logic programming in Prolog</title>
  <meta name="description" content="Personal website">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://edom.github.io/prolog.html">
  <link rel="alternate" type="application/rss+xml" title="Erik Dominikus&#39;s wiki" href="/feed.xml">

  

    <script>
// Help the reader estimate how much time the reading is going to take.
// Show word count and reading time estimation in TOC entry.
//
// TOC = table of contents
//
// Known issue: This janks: this DOM manipulation is done after the page is rendered.
// If we don't want jank, we have to manipulate the HTML source before it reaches the browser.
// We assume that the user doesn't refresh the page while reading.
// The benefit of fixing that jank is not enough for me to justify trying to fix it.
document.addEventListener("DOMContentLoaded", function () {
    function count_word (string) {
        return string.trim().split(/\s+/).length;
    }
    function show_quantity (count, singular) {
        let plural = singular + "s"; // For this script only.
        return count + " " + ((count == 1) ? singular : plural);
    }
    function create_length_indicator (word, minute) {
        let e = document.createElement("span");
        e.className = "toc_entry__length_indicator";
        e.textContent = " (" + show_quantity(word, "word") + " ~ " + show_quantity(minute, "minute") + ")";
        return e;
    }
    // We assume that readers read this many words per minute with 100% comprehension.
    // This assumption may not hold for dense texts such as philosophy and mathematics.
    const wpm_assumption = 200;
    // We assume a certain Jekyll template.
    let page = document.querySelector("main.page-content");
    if (page === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"main.page-content\" does not match anything");
        return;
    }
    let page_title = document.querySelector("header.post-header h1.post-title");
    if (page_title === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"header.post-header h1.post-title\" does not match anything");
        return;
    }
    let page_word = count_word(page.textContent);
    let page_minute = Math.ceil(page_word / wpm_assumption);
    page_title.insertAdjacentElement("afterend", create_length_indicator(page_word, page_minute));
    // We violate the HTML specification.
    // The page may have several elements with the same ID.
    // We assume that Org HTML Export generates a DIV element with ID "table-of-contents".
    // We assume that Jekyll Markdown-to-HTML generates a UL element with ID "markdown-toc".
    // This only works for Org HTML Export's TOC.
    let toc_entries = document.querySelectorAll("#table-of-contents a, #text-table-of-contents a");
    toc_entries.forEach((toc_entry_a) => {
        let href = toc_entry_a.getAttribute("href"); // We assume that this is a string like "#org0123456".
        if (href.charAt(0) !== '#') {
            console.log("toc_generate_estimate: Impossible: " + href + " does not begin with hash sign");
            return;
        }
        // We can't just document.querySelector(href) because target_id may contain invalid ID characters such as periods.
        let target_id = href.substring(1);
        let id_escaped = target_id.replace("\"", "\\\"");
        let h_elem = document.querySelector("[id=\"" + id_escaped + "\"]"); // We assume that this is the h1/h2/h3 element referred by the TOC entry.
        if (h_elem === null) { // We assume that this is impossible.
            console.log("toc_generate_estimate: Impossible: " + href + " does not refer to anything");
            return;
        }
        let section = h_elem.parentNode;
        let section_word = count_word(section.textContent);
        let section_minute = Math.ceil(section_word / wpm_assumption);
        toc_entry_a.insertAdjacentElement("afterend", create_length_indicator(section_word, section_minute));
    });
});
    </script>

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-12628443-6', 'auto');
  ga('send', 'pageview');

</script>
  

  

  
</head>


  <body>

    <header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Erik Dominikus&#39;s wiki</a>
  </div>
</header>


    

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Relational-bidirectional-logic programming in Prolog</h1>
  </header>

  <div class="post-content">
    <div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgecb35de">1. Before you go full Prolog</a></li>
<li><a href="#orgc26ad3e">2. <span class="todo TODO">TODO</span> Writing elegant Prolog knowledge bases</a></li>
<li><a href="#orgcf45bfd">3. Using SWI-Prolog</a></li>
<li><a href="#org1338566">4. <span class="todo TODO">TODO</span> Half-baked things to shuffle around</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgecb35de" class="outline-2">
<h2 id="orgecb35de"><span class="section-number-2">1</span> Before you go full Prolog</h2>
<div class="outline-text-2" id="text-1">
<div id="text-table-of-contents">
<ul>
<li><a href="#org389588e">1.1. <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-11-30&gt; </span></span> This is a book in progress! I don't know whether I will ever finish this.</a></li>
<li><a href="#orge0528f6">1.2. Let me warn you about the woes and blockers.</a></li>
<li><a href="#org5f3d733">1.3. Let me hype you up.</a></li>
<li><a href="#org3b2124a">1.4. Not sure yet? Try Prolog with minimal investment.</a></li>
<li><a href="#orgc07e142">1.5. Comparison of Prolog implementations</a></li>
</ul>
</div>
</div>
<div id="outline-container-org389588e" class="outline-3">
<h3 id="org389588e"><span class="section-number-3">1.1</span> <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-11-30&gt; </span></span> This is a book in progress! I don't know whether I will ever finish this.</h3>
</div>
<div id="outline-container-orge0528f6" class="outline-3">
<h3 id="orge0528f6"><span class="section-number-3">1.2</span> Let me warn you about the woes and blockers.</h3>
<div class="outline-text-3" id="text-1-2">
<p>
I'm selling you Prolog here, but let me be honest:
Don't buy it if any of these year-2018 deal-breakers are an issue for you.
Prolog isn't ready for these use cases in 2018; I hope these will change.
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2018-11-30&gt;</span></span>
No arrays.
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2018-11-30&gt;</span></span>
SWI-Prolog is honest:
"The main weakness of Prolog are algorithms that require destructive assignment,
intensive array processing or bare-metal performance for e.g., processing pixels."
<a href="http://www.swi-prolog.org/FAQ/PrologLAMP.txt">http://www.swi-prolog.org/FAQ/PrologLAMP.txt</a>
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2018-10-24&gt;</span></span>
There is no standard date/time/calendar library?
There may be one?
I'm still looking.
</p>
<ul class="org-ul">
<li>Java 8 has "java.util.time"; previous Java versions can use "Joda Time".</li>
<li>Haskell has the "time" package ("Data.Time" module).</li>
</ul>
</div>
</div>
<div id="outline-container-org5f3d733" class="outline-3">
<h3 id="org5f3d733"><span class="section-number-3">1.3</span> Let me hype you up.</h3>
<div class="outline-text-3" id="text-1-3">
<p>
(You can skip this.)
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2018-11-30&gt;</span></span>
Don't take this too seriously.
I'm on a honeymoon with Prolog.
</p>

<p>
Prolog is a <i>mind augmentation language</i>.
Prolog is a mental prosthesis.
With prosthetic arms, I can beat you in arm wrestling.
With prosthetic legs, I can beat you in running.
With prosthetic minds, I can beat you in thinking.
If logic is the language of thought, then Prolog is the closest thing we have to mind dump.
Offload your reasoning to computers.
As Leibniz said, "Let us calculate!"
</p>

<p>
You love Lisp macros?
Prolog has term_expansion/2, goal_expansion/2, op/2, and the infix operators that you have been dreaming of!
</p>

<p>
You love Haskell type system?
In Prolog you can write your own type systems!
</p>

<p>
You love C++ operator overloading?
In Prolog you can define your own operators with their precedences and associativities!
</p>

<p>
You want to beat/outdo/one-up your coworkers?
Prolog is perfect for that!
Unless you're low-level-programming,
Prolog is the secret weapon that multiplies your productivity by 20 compared to a low-level programming language such as C, C++, Java.
When you build your home, you don't build your own bricks.
</p>

<p>
Your coworkers are beating you with Prolog?
Well, what the hell are you waiting for?
Learn Prolog now, or lose your job and die in oblivion!
</p>

<p>
Things that I haven't found in Prolog:
the speed of C,
the toolchain of Go.
</p>

<p>
There are two camps in programming:
the bottom-up camp and the top-down camp.
</p>

<p>
The bottom-up camp starts from machines and goes up toward mathematics.
This camp produces Assembly, Fortran, Cobol, Pascal, C, C++, Go.
This camp produced fast but ugly implementations.
Haphazard incremental improvements.
</p>

<p>
The top-down camp starts from mathematics and goes down toward machines.
This camp produces Lisp, Scheme, Prolog, ML, Ocaml, Haskell, Coq, Idris, Agda, Lean.
This camp produced elegant but slow implementations.
Big design up front.
</p>

<p>
They seem to be converging to a middle ground: ugly and slow.
</p>

<p>
Why can't we get fast and elegant?
</p>
</div>
</div>
<div id="outline-container-org3b2124a" class="outline-3">
<h3 id="org3b2124a"><span class="section-number-3">1.4</span> Not sure yet? Try Prolog with minimal investment.</h3>
<div class="outline-text-3" id="text-1-4">
<p>
If you're not sure yet, I suggest that you
read <a href="https://www.metalevel.at/prolog">Markus Triska's book "The power of Prolog"</a>
while doodling some code on <a href="http://pengines.swi-prolog.org/apps/swish/index.html">SWISH online Prolog interpreter</a>.
</p>
</div>
</div>
<div id="outline-container-orgc07e142" class="outline-3">
<h3 id="orgc07e142"><span class="section-number-3">1.5</span> Comparison of Prolog implementations</h3>
<div class="outline-text-3" id="text-1-5">
<p>
<a href="https://en.wikipedia.org/wiki/Comparison_of_Prolog_implementations">https://en.wikipedia.org/wiki/Comparison_of_Prolog_implementations</a>
</p>

<p>
Comparison between SWI Prolog, YAP, GNU Prolog.
<a href="http://www.david-reitter.com/compling/prolog/compare.html">http://www.david-reitter.com/compling/prolog/compare.html</a>
</p>

<p>
There are many Prolog implementations.
Some companies have their own Prolog implementations.
</p>

<p>
I use SWI-Prolog because it's what I use in university, and because of this <a href="http://www.swi-prolog.org/features.html">SWI-Prolog sales pitch</a>.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc26ad3e" class="outline-2">
<h2 id="orgc26ad3e"><span class="section-number-2">2</span> <span class="todo TODO">TODO</span> Writing elegant Prolog knowledge bases</h2>
<div class="outline-text-2" id="text-2">
<div id="text-table-of-contents">
<ul>
<li><a href="#orga74a36a">2.1. Prolog predicate parameter ordering convention: Order the parameters from the most likely to be bound</a></li>
<li><a href="#org1658c83">2.2. Prolog throw vs fail</a></li>
<li><a href="#orgcd563af">2.3. Zero-arity compound term</a></li>
<li><a href="#org5a9568b">2.4. Naming the parts of a list: head, tail, and butt</a></li>
<li><a href="#orgfa3bcf2">2.5. Total relational programming? Relational programs that can be proven to terminate?</a></li>
<li><a href="#org09b6661">2.6. Prolog procedural semantics</a>
<ul>
<li><a href="#org7f63ae4">2.6.1. Swapped phrases</a></li>
<li><a href="#org9f5c130">2.6.2. Understanding depth-first search, backtracking, choice points, performance, and cuts</a></li>
<li><a href="#org57e49f0">2.6.3. Prolog is a depth-first brute-forcer</a></li>
</ul>
</li>
<li><a href="#org330b62f">2.7. <span class="todo TODO">TODO</span> Error handling</a></li>
</ul>
</div>
</div>
<div id="outline-container-orga74a36a" class="outline-3">
<h3 id="orga74a36a"><span class="section-number-3">2.1</span> Prolog predicate parameter ordering convention: Order the parameters from the most likely to be bound</h3>
<div class="outline-text-3" id="text-2-1">
<p>
If parameter A is more likely to be more bound than parameter B, then A should come before B.
Example: Write list_length/2 instead of length_list/2.
</p>

<p>
Not everyone follows this convention.
</p>
</div>
</div>

<div id="outline-container-org1658c83" class="outline-3">
<h3 id="org1658c83"><span class="section-number-3">2.2</span> Prolog throw vs fail</h3>
<div class="outline-text-3" id="text-2-2">
<p>
If backtracking doesn't make sense, then throw, don't fail
Fail means try the next alternative
</p>
</div>
</div>

<div id="outline-container-orgcd563af" class="outline-3">
<h3 id="orgcd563af"><span class="section-number-3">2.3</span> Zero-arity compound term</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Use compound_name_arity/3 instead of functor/3, but this seems to be an SWI-Prolog extension.
</p>

<p>
<a href="http://www.swi-prolog.org/pldoc/man?section=ext-compound-zero">http://www.swi-prolog.org/pldoc/man?section=ext-compound-zero</a>
</p>
</div>
</div>
<div id="outline-container-org5a9568b" class="outline-3">
<h3 id="org5a9568b"><span class="section-number-3">2.4</span> Naming the parts of a list: head, tail, and butt</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>"head" is the first element</li>
<li>"tail" is everything but the head</li>
<li>"butt" is the last element</li>
</ul>
</div>
</div>
<div id="outline-container-orgfa3bcf2" class="outline-3">
<h3 id="orgfa3bcf2"><span class="section-number-3">2.5</span> Total relational programming? Relational programs that can be proven to terminate?</h3>
<div class="outline-text-3" id="text-2-5">
<p>
A total relation is a relation that is defined for every element in its domain.
</p>

<p>
If there is total functional programming, then there should be total relational programming.
</p>

<p>
It is too easy to write a Prolog program that doesn't terminate.
</p>
</div>
</div>
<div id="outline-container-org09b6661" class="outline-3">
<h3 id="org09b6661"><span class="section-number-3">2.6</span> Prolog procedural semantics</h3>
<div class="outline-text-3" id="text-2-6">
</div>
<div id="outline-container-org7f63ae4" class="outline-4">
<h4 id="org7f63ae4"><span class="section-number-4">2.6.1</span> Swapped phrases</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
There is only a small syntactic difference between <code>dfs</code> and <code>bfs</code> (it's just flipped order).
</p>

<p>
Which one exploits tail call optimization (last call optimization)?
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">bit</span>(0).
<span style="color: #0000ff;">bit</span>(1).

<span style="color: #0000ff;">dfs</span>(<span style="color: #a020f0;">[]</span>).
<span style="color: #0000ff;">dfs</span>(<span style="color: #a020f0;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #a020f0;">]</span>) :- bit(<span style="color: #a0522d;">H</span>), dfs(<span style="color: #a0522d;">T</span>).

<span style="color: #0000ff;">bfs</span>(<span style="color: #a020f0;">[]</span>).
<span style="color: #0000ff;">bfs</span>(<span style="color: #a020f0;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #a020f0;">]</span>) :- bfs(<span style="color: #a0522d;">T</span>), bit(<span style="color: #a0522d;">H</span>).
</pre>
</div>
</div>
</div>
<div id="outline-container-org9f5c130" class="outline-4">
<h4 id="org9f5c130"><span class="section-number-4">2.6.2</span> Understanding depth-first search, backtracking, choice points, performance, and cuts</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
Save this knowledge base into a file, and load it into Prolog.
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">a</span>(0).
<span style="color: #0000ff;">a</span>(1).

<span style="color: #0000ff;">b</span>(0).
<span style="color: #0000ff;">b</span>(1).
</pre>
</div>

<p>
Run the query <code>a(A), b(B).</code> and press <code>;</code> until Prolog fails.
</p>

<p>
This is what Prolog finds (we remove the newlines to make it more readable):
</p>
<pre class="example">
A = B, B = 0 ;
A = 0, B = 1 ;
A = 1, B = 0 ;
A = B, B = 1.
</pre>

<p>
This is the search space (search tree) of that query.
</p>
<pre class="example">
       ?- a(A), b(B).
      /              \
    A = 0           A = 1
   /     \         /     \
B = 0   B = 1   B = 0   B = 1
</pre>

<p>
Prolog traverses that tree in depth-first order as follows:
</p>
<pre class="example">
- ?- a(A), b(B).
  - A = 0
    - B = 0
    - B = 1
  - A = 1
    - B = 0
    - B = 1
</pre>

<p>
The important things to infer from this experiment are:
</p>
<ul class="org-ul">
<li>Prolog repeats the work on <code>b</code> as many times as the number of ways of satisfying <code>a</code>.
If <code>a</code> can be satisfied in N ways, and satisfying <code>b</code> is a lot of work,
then Prolog may do that work N times,
although the work produces the same result.</li>
<li>Everything to the right of an infinite branch will never be visited.</li>
</ul>

<p>
What is a choice point?
</p>

<p>
A cut makes <code>a(A), b(B)</code> and <code>b(B), a(A)</code> return different results.
</p>

<p>
How far does a cut cut?
</p>

<p>
"The craft of Prolog" defines three kinds of cuts: red, green, and blue.
</p>
<ul class="org-ul">
<li>A red cut destroys the logical meaning of a program.
Green and blue cuts don't.</li>
</ul>
</div>
</div>
<div id="outline-container-org57e49f0" class="outline-4">
<h4 id="org57e49f0"><span class="section-number-4">2.6.3</span> Prolog is a depth-first brute-forcer</h4>
<div class="outline-text-4" id="text-2-6-3">
<p>
But you can emulate other search algorithms too.
</p>
</div>
<ol class="org-ol">
<li><a id="org7aa584c"></a>Non-termination pitfalls, and how to generate terms correctly<br />
<div class="outline-text-5" id="text-2-6-3-1">
<p>
Sometimes we forget that Prolog, on failure, backtracks (retries), not stops.
</p>

<p>
Sometimes we focus too much on the logical reading and neglect the procedural reading.
</p>

<p>
For example, suppose that you want to generate all lists whose length doesn't exceed 2.
</p>

<p>
The following is a mathematically correct statement about that fact,
but it doesn't work in Prolog.
It has correct logical reading, but incorrect procedural reading.
If you keep pressing <code>;</code>, this will fail to terminate.
</p>
<div class="org-src-container">
<pre class="src src-prolog">?- length(<span style="color: #a0522d;">A</span>, <span style="color: #a0522d;">LA</span>), <span style="color: #a0522d;">LA</span> =&lt; 2.
</pre>
</div>

<p>
The correct way to do that is to use <code>between/3</code> (inclusive):
</p>
<div class="org-src-container">
<pre class="src src-prolog">?- between(0, 2, <span style="color: #a0522d;">LA</span>), length(<span style="color: #a0522d;">A</span>, <span style="color: #a0522d;">LA</span>).
</pre>
</div>

<p>
We can also use the <code>clpfd</code> library:
</p>
<div class="org-src-container">
<pre class="src src-prolog">:- use_module(library(clpfd)).

?- <span style="color: #a0522d;">LA</span> in 0..2, indomain(<span style="color: #a0522d;">LA</span>), length(<span style="color: #a0522d;">A</span>, <span style="color: #a0522d;">LA</span>).
</pre>
</div>

<p>
We shouldn't have to resort to cuts:
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #b22222;">% </span><span style="color: #b22222;">Don't do this.</span>
?- length(<span style="color: #a0522d;">A</span>, <span style="color: #a0522d;">LA</span>), (<span style="color: #a0522d;">LA</span> =&lt; 2 <span style="color: #a020f0;">-&gt;</span> true<span style="color: #a020f0;">;</span> <span style="color: #a020f0;">!</span>, fail).
</pre>
</div>

<p>
See also:
</p>
<ul class="org-ul">
<li><a href="https://www.metalevel.at/prolog/nontermination">https://www.metalevel.at/prolog/nontermination</a>
<ul class="org-ul">
<li>"[Non-termination is] common among beginners, and often lead them to perceive Prolog as 'slow', when in fact their program does not terminate <i>at all</i>."</li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org330b62f" class="outline-3">
<h3 id="org330b62f"><span class="section-number-3">2.7</span> <span class="todo TODO">TODO</span> Error handling</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li><a href="http://www.pathwayslms.com/swipltuts/message/index.html">http://www.pathwayslms.com/swipltuts/message/index.html</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcf45bfd" class="outline-2">
<h2 id="orgcf45bfd"><span class="section-number-2">3</span> Using SWI-Prolog</h2>
<div class="outline-text-2" id="text-3">
<div id="text-table-of-contents">
<ul>
<li><a href="#org52e23ad">3.1. <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-10-20&gt; </span></span> Installing SWI-Prolog 7.6.4 on Ubuntu 14.04</a></li>
<li><a href="#org886945a">3.2. Loading files</a></li>
<li><a href="#org1124d06">3.3. Interacting with SWI-Prolog</a></li>
<li><a href="#org42e02a7">3.4. Warnings are errors!</a></li>
<li><a href="#orgf1e542b">3.5. <span class="todo TODO">TODO</span> debugging: spy/1, tspy/1, trace/0, gtrace/0, notrace/0, debug/0, nodebug/0; stepping: creep, skip, and leap</a></li>
<li><a href="#org8991268">3.6. <span class="todo TODO">TODO</span> <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-11-30&gt; </span></span> Prolog needs static checking like Erlang Dialyzer.</a></li>
<li><a href="#org8a2d1ea">3.7. How do I use SWI-Prolog?</a></li>
<li><a href="#orgeed882e">3.8. Which string representation should I use?</a>
<ul>
<li><a href="#orgefd1380">3.8.1. The answer: Dedicated double-quoted string type (SWI-Prolog 7)</a></li>
<li><a href="#org3fca09d">3.8.2. Non-answers</a></li>
</ul>
</li>
<li><a href="#orgb5a4dc9">3.9. Profiling in SWI-Prolog; find where your program spends time; find where it is slow; diagnose slowness</a></li>
<li><a href="#org07fd13b">3.10. SWI-Prolog, PostgreSQL, and ODBC</a></li>
</ul>
</div>
</div>
<div id="outline-container-org52e23ad" class="outline-3">
<h3 id="org52e23ad"><span class="section-number-3">3.1</span> <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-10-20&gt; </span></span> Installing SWI-Prolog 7.6.4 on Ubuntu 14.04</h3>
<div class="outline-text-3" id="text-3-1">
<p>
If you are using Ubuntu 14.04, follow my instructions below.
</p>

<p>
If your operating system has packaged SWI-Prolog 7.6.4 or newer, use it.
(Thank you, volunteer package maintainers!)
</p>

<p>
If you aren't using Ubuntu 14.04, follow the <a href="http://www.swi-prolog.org/Download.html">official instructions</a>.
Choose the current stable release.
</p>

<p>
The following guide is for installing SWI-Prolog 7.6.4 on Ubuntu 14.04.
</p>

<p>
Uninstall existing SWI-Prolog installations.
The version packaged with Ubuntu 14.04 is too old (6.6.4).
SWI-Prolog 7 fixes a lot of issues with strings in SWI-Prolog 6.
</p>

<p>
Install dependencies.
I take this from the <a href="http://www.swi-prolog.org/build/Debian.html">Debian build instructions</a> with these changes.
I replace <code>libunwind-dev</code> with <code>libunwind8-dev</code>.
I remove <code>openjdk-8-jdk</code> and <code>junit</code>.
I add <code>libreadline-dev</code>.
</p>
<pre class="example">
sudo apt-get install \
        build-essential autoconf curl chrpath pkg-config \
        ncurses-dev libreadline-dev libedit-dev \
        libunwind8-dev \
        libgmp-dev \
        libssl-dev \
        unixodbc-dev \
        zlib1g-dev libarchive-dev \
        libossp-uuid-dev \
        libxext-dev libice-dev libjpeg-dev libxinerama-dev libxft-dev \
        libxpm-dev libxt-dev \
        libdb-dev \
        libpcre3-dev \
        libyaml-dev \
        libreadline-dev
</pre>

<p>
That doesn't include the documentation dependencies because they are too big.
Just read the documentation online.
</p>

<p>
After apt-get finishes, for security (avoiding sudo cache), close that terminal, and open a new one.
</p>

<p>
Download the <a href="http://www.swi-prolog.org/download/stable">source</a>.
</p>

<p>
Check the checksum using sha256sum.
</p>

<p>
<code>cp -p build.templ build</code>
</p>

<p>
<code>mkdir -p $HOME/.local</code>
</p>

<p>
Edit <code>build</code> script.
Set <code>PREFIX</code> to <code>$HOME/.local</code>.
Uncomment the <code>--link</code> option in <code>EXTRACFG</code> variable.
</p>

<p>
Run <code>./build</code>.
It should take a few minutes (about 5 minutes on my 4-core 8-GB-RAM machine).
</p>

<p>
Ensure that <code>$HOME/.local/bin</code> is in your <code>PATH</code>.
For example, I have this line somewhere near the end of my <code>~/.bashrc</code> file:
</p>
<pre class="example">
export PATH=$PATH:$HOME/.local/bin
</pre>

<p>
If you edit your bashrc, close your terminal and open a new one.
Entering <code>swipl --version</code> should print this:
</p>
<pre class="example">
SWI-Prolog version 7.6.4 for x86_64-linux
</pre>

<p>
If you don't want to edit your bashrc, you can run swipl by its full path <code>~/.local/bin/swipl</code>.
</p>

<p>
Tell SWI-Prolog to use readline.
Create a FILE containing this:
</p>
<pre class="example">
:- set_prolog_flag(readline, readline).
</pre>

<p>
Add <code>-f FILE</code> switch to the command line you use to start <code>swipl</code>.
Related GitHub issue <a href="https://github.com/SWI-Prolog/issues/issues/72">https://github.com/SWI-Prolog/issues/issues/72</a>.
</p>
</div>
</div>
<div id="outline-container-org886945a" class="outline-3">
<h3 id="org886945a"><span class="section-number-3">3.2</span> Loading files</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><code>:- [foo].</code> is shorthand for <code>:- consult(foo).</code>.
<ul class="org-ul">
<li><a href="http://www.swi-prolog.org/pldoc/man?predicate=consult/1">http://www.swi-prolog.org/pldoc/man?predicate=consult/1</a></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1124d06" class="outline-3">
<h3 id="org1124d06"><span class="section-number-3">3.3</span> Interacting with SWI-Prolog</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>To show the canonical representation of a term, query <code>write_canonical(Term)</code>.</li>
<li>To show the source of a predicate, query <code>listing(Module:Name)</code> or <code>listing(Name)</code>.</li>
</ul>
</div>
</div>
<div id="outline-container-org42e02a7" class="outline-3">
<h3 id="org42e02a7"><span class="section-number-3">3.4</span> Warnings are errors!</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Singleton variables most likely mean there's a typo.
</p>
</div>
</div>
<div id="outline-container-orgf1e542b" class="outline-3">
<h3 id="orgf1e542b"><span class="section-number-3">3.5</span> <span class="todo TODO">TODO</span> debugging: spy/1, tspy/1, trace/0, gtrace/0, notrace/0, debug/0, nodebug/0; stepping: creep, skip, and leap</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Fixing programming errors:
</p>
<ul class="org-ul">
<li><a href="https://www.cs.ucsb.edu/~kyledewey/cs162w15/debugging_prolog.html">https://www.cs.ucsb.edu/~kyledewey/cs162w15/debugging_prolog.html</a></li>
<li><a href="http://www.swi-prolog.org/pldoc/man?section=debugoverview">http://www.swi-prolog.org/pldoc/man?section=debugoverview</a>
<ul class="org-ul">
<li>Type <code>/f</code> in the tracer prompt to run to the next failure.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8991268" class="outline-3">
<h3 id="org8991268"><span class="section-number-3">3.6</span> <span class="todo TODO">TODO</span> <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-11-30&gt; </span></span> Prolog needs static checking like Erlang Dialyzer.</h3>
<div class="outline-text-3" id="text-3-6">
<p>
SWI-Prolog has check library?
</p>

<p>
Is there a Prolog totality/determinism checker?
</p>

<p>
Prolog typechecking is vital to prevent stupid mistakes in a large knowledge base?
</p>

<p>
1997 inconclusive discussion "Prolog Type Checker"
<a href="https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/typing/types.html">https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/typing/types.html</a>
</p>
</div>
</div>
<div id="outline-container-org8a2d1ea" class="outline-3">
<h3 id="org8a2d1ea"><span class="section-number-3">3.7</span> How do I use SWI-Prolog?</h3>
<div class="outline-text-3" id="text-3-7">
<ul class="org-ul">
<li>Write a <code>load.pro</code> script that loads your files.</li>
<li>To start a query interpreter, <code>swipl -l load.pro</code>.</li>
<li>You write <i>rules</i> in files.
You write <i>queries</i> in the query interpreter.
<ul class="org-ul">
<li>Pasting a file into the interpreter does <i>not</i> load the file.
<ul class="org-ul">
<li>This is contrary to Lisp/Python/Ruby interpreters.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgeed882e" class="outline-3">
<h3 id="orgeed882e"><span class="section-number-3">3.8</span> Which string representation should I use?</h3>
<div class="outline-text-3" id="text-3-8">
</div>
<div id="outline-container-orgefd1380" class="outline-4">
<h4 id="orgefd1380"><span class="section-number-4">3.8.1</span> The answer: Dedicated double-quoted string type (SWI-Prolog 7)</h4>
<div class="outline-text-4" id="text-3-8-1">
<ul class="org-ul">
<li>"Strings are distinct from lists" <a href="http://www.swi-prolog.org/pldoc/man?section=strings">http://www.swi-prolog.org/pldoc/man?section=strings</a></li>
<li>"Why has the representation of double quoted text changed?" <a href="http://www.swi-prolog.org/pldoc/man?section=ext-dquotes-motivation">http://www.swi-prolog.org/pldoc/man?section=ext-dquotes-motivation</a></li>
<li>2013 article "Strings in ECLiPSe 6.2, SWI-7 and YAP" <a href="http://eclipseclp.org/wiki/Prolog/Strings">http://eclipseclp.org/wiki/Prolog/Strings</a>
<ul class="org-ul">
<li>"With SWI-7 and ECLiPSe 6.2 string support has been harmonized, and YAP is expected to agree as well."</li>
<li>"Agreed Common Functionality"</li>
<li>"Situation before December 2013"</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3fca09d" class="outline-4">
<h4 id="org3fca09d"><span class="section-number-4">3.8.2</span> Non-answers</h4>
<div class="outline-text-4" id="text-3-8-2">
</div>
<ol class="org-ol">
<li><a id="orgc93a5c0"></a>Edinburgh style: Double-quoted string as list of integer codes (default mode of SWI-Prolog 6.6.4 on Ubuntu 14.04)<br />
<div class="outline-text-5" id="text-3-8-2-1">
<ul class="org-ul">
<li>A Unicode character is represented as an integer that is the code of that character.</li>
<li>A string is represented as a list of codes.
Example: <code>"aaa" = [97,97,97]</code>.</li>
<li>Inconvenient to debug.</li>
<li>This behavior changes in SWI-Prolog 7.</li>
<li>This was in 1993 ISO standard draft. <a href="http://fsl.cs.illinois.edu/images/9/9c/PrologStandard.pdf">http://fsl.cs.illinois.edu/images/9/9c/PrologStandard.pdf</a>
<ul class="org-ul">
<li>This wasn't in the final version?</li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org2c1de1d"></a>Double-quoted string as list of one-character atoms<br />
<div class="outline-text-5" id="text-3-8-2-2">
<ul class="org-ul">
<li>A Unicode character is represented as a one-character atom.</li>
<li>A string is represented as a list of one-character atoms.
Example: <code>"aaa" = [a,a,a]</code>.</li>
<li>This assumes that the Prolog implementation garbage-collects atoms.</li>
<li>More convenient to debug.</li>
</ul>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgb5a4dc9" class="outline-3">
<h3 id="orgb5a4dc9"><span class="section-number-3">3.9</span> Profiling in SWI-Prolog; find where your program spends time; find where it is slow; diagnose slowness</h3>
<div class="outline-text-3" id="text-3-9">
<p>
To run your <code>Goal</code> with profiling, simply query <code>profile(Goal)</code>.
</p>

<p>
Profiling couldn't be any simpler than this!
</p>
</div>
</div>
<div id="outline-container-org07fd13b" class="outline-3">
<h3 id="org07fd13b"><span class="section-number-3">3.10</span> SWI-Prolog, PostgreSQL, and ODBC</h3>
<div class="outline-text-3" id="text-3-10">
<p>
Install the Ubuntu 14.04 package <code>odbc-postgresql</code>.
</p>

<p>
I want my application to self-contain its configuration.
I don't configure ODBC INI files.
</p>

<p>
ODBC Data Source Name (DSN) connection string
</p>

<p>
Relevant commands: <code>odbcinst -j</code>
</p>

<p>
The file <code>/etc/odbcinst.ini</code> contains a list of driver names.
</p>
</div>
</div>
</div>
<div id="outline-container-org1338566" class="outline-2">
<h2 id="org1338566"><span class="section-number-2">4</span> <span class="todo TODO">TODO</span> Half-baked things to shuffle around</h2>
<div class="outline-text-2" id="text-4">
<div id="text-table-of-contents">
<ul>
<li><a href="#orga2b3e1b">4.1. Functional/expression style sometimes beats relational/unification style</a></li>
<li><a href="#org6260cbe">4.2. Embedding Prolog/Haskell in Haskell/Prolog</a>
<ul>
<li><a href="#org96eedd4">4.2.1. Embedding Prolog in Haskell</a></li>
<li><a href="#org4a0c336">4.2.2. Embedding Haskell in Prolog: Nobody is talking about this.</a></li>
</ul>
</li>
<li><a href="#orgff76257">4.3. Directives like <code>:- op</code> complicate parsing a Prolog source code.</a></li>
<li><a href="#org931ca1c">4.4. Defining your own operators</a></li>
<li><a href="#orgda69842">4.5. Meta-programming</a></li>
<li><a href="#org8eef091">4.6. Use clpfd #=/2 instead of is/2?</a></li>
<li><a href="#org853cdaa">4.7. Comparison between what is difficult in various programming languages</a></li>
<li><a href="#orgaba238f">4.8. Difference lists</a></li>
<li><a href="#orgd6b7309">4.9. What? 99 Prolog problems?</a></li>
<li><a href="#org4b775c7">4.10. Iterative deepening search with length/1</a></li>
<li><a href="#org71915a3">4.11. <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-10-20&gt; </span></span> How do we make sense of this counterintuitive module syntax?</a></li>
<li><a href="#orga52d884">4.12. Comparison between ontology, relational programming, and database programming</a>
<ul>
<li><a href="#org1c7aa9c">4.12.1. Open World Assumption vs Closed World Assumption</a></li>
</ul>
</li>
<li><a href="#org1701963">4.13. Discover the wonderful world of Prolog / logic programming / relational programming</a>
<ul>
<li><a href="#org9ba8c58">4.13.1. Symbolic AI is the easiest AI approach.</a></li>
<li><a href="#orge2c5e32">4.13.2. Dreams</a></li>
</ul>
</li>
<li><a href="#orgf71d684">4.14. Comparison with other relational programming languages</a></li>
<li><a href="#org56b9135">4.15. Reminder for those who already know</a></li>
<li><a href="#org08ac6ad">4.16. "Universal-transpiler": Similar to what we want</a></li>
<li><a href="#orga93cc9a">4.17. Logic programming vs theorem proving</a></li>
<li><a href="#orgbbbadf1">4.18. Knowledge representation and software specification</a>
<ul>
<li><a href="#orgf5826c1">4.18.1. Their relationships</a></li>
<li><a href="#org772a721">4.18.2. Executable specification?</a></li>
</ul>
</li>
<li><a href="#org946e3fa">4.19. Combine closed-world assumption (logic programming / relational database) and open-world assumption (web ontology)</a></li>
<li><a href="#orge4f7af2">4.20. Making compilers</a></li>
<li><a href="#org6fe9637">4.21. Declarative programming languages</a></li>
<li><a href="#org1289834">4.22. How are Prolog and Lisp similar?</a></li>
<li><a href="#org3c37b19">4.23. Speculative</a>
<ul>
<li><a href="#org9f4de94">4.23.1. Fast logic programming?</a></li>
<li><a href="#orgedb661a">4.23.2. Lambda-prolog?</a></li>
</ul>
</li>
<li><a href="#org8864f0c">4.24. Resources</a>
<ul>
<li><a href="#org3358571">4.24.1. For beginners</a></li>
<li><a href="#orge83f5ba">4.24.2. Not for beginners</a></li>
</ul>
</li>
<li><a href="#org574abf4">4.25. What?</a>
<ul>
<li><a href="#orge795ae4">4.25.1. P# translates Prolog to C#.</a></li>
<li><a href="#org52d5d28">4.25.2. "Real World Programming in SWI-Prolog"</a></li>
<li><a href="#org1975287">4.25.3. "Frequently Asked Questions for ##Prolog"</a></li>
</ul>
</li>
<li><a href="#org3a7676e">4.26. What are these trying to say?</a></li>
<li><a href="#org4a50502">4.27. Books?</a></li>
</ul>
</div>
</div>
<div id="outline-container-orga2b3e1b" class="outline-3">
<h3 id="orga2b3e1b"><span class="section-number-3">4.1</span> Functional/expression style sometimes beats relational/unification style</h3>
<div class="outline-text-3" id="text-4-1">
<pre class="example">
-- Functional/expression style
g (f0 x0) (f1 x1) (f2 x2)

% Relational/unification style
f0(X0, Y0), f1(X1, Y1), f2(X2, Y2), g(Y0, Y1, Y2, Z).
</pre>
<p>
Example where functional style wins:
</p>
<ul class="org-ul">
<li>string formatting</li>
<li>number crunching</li>
</ul>

<p>
If backtracking isn't involved, functional style wins (is more concise than relational style).
</p>

<p>
If computation is reversible, relational style wins (half the amount of code of functional style).
</p>

<p>
We should use both styles depending on circumstances.
</p>

<p>
We can define a functional/expression/applicative/evaluative sublanguage in Prolog, roughly like this:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">eval</span>((<span style="color: #a0522d;">A</span> = <span style="color: #a0522d;">B</span>), <span style="color: #a0522d;">Val</span>) :- <span style="color: #a0522d;">A</span> = <span style="color: #a0522d;">B</span>, eval(<span style="color: #a0522d;">B</span>, <span style="color: #a0522d;">Val</span>), <span style="color: #a020f0;">!</span>.
<span style="color: #0000ff;">eval</span>(<span style="color: #a0522d;">F</span>, <span style="color: #a0522d;">Val</span>) :- callable(<span style="color: #a0522d;">F</span>), call(<span style="color: #a0522d;">F</span>, <span style="color: #a0522d;">Val</span>), <span style="color: #a020f0;">!</span>. <span style="color: #b22222;">% </span><span style="color: #b22222;">lots of hand-waving here</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">etc.</span>
</pre>
</div>

<p>
Haskell is weak against the AST decoration problem.
Dynamic languages (Scheme, JavaScript, Prolog) / gradual-typed languages (TypeScript) beat static languages (Haskell) on the AST decoration problem.
How about Ocaml polymorphic variants?
</p>

<p>
Should we move from Prolog to Scheme/miniKanren or Mercury?
</p>
</div>
</div>
<div id="outline-container-org6260cbe" class="outline-3">
<h3 id="org6260cbe"><span class="section-number-3">4.2</span> Embedding Prolog/Haskell in Haskell/Prolog</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org96eedd4" class="outline-4">
<h4 id="org96eedd4"><span class="section-number-4">4.2.1</span> Embedding Prolog in Haskell</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>1999 article "Embedding Prolog in Haskell" <a href="https://pdfs.semanticscholar.org/7c46/5d25205830735d0a034532746b7243221eca.pdf">https://pdfs.semanticscholar.org/7c46/5d25205830735d0a034532746b7243221eca.pdf</a>
<ul class="org-ul">
<li>"We propose an embedding of logic programming into lazy functional programming
in which each predicate in a Prolog program becomes a Haskell function,
in such a way that both the declarative and the procedural reading of the Prolog predicate are preserved."</li>
</ul></li>
<li>1988 article "Towards functional programming in Prolog" <a href="ftp://obaluae.inf.puc-rio.br/pub/docs/Publications/88_AI_Furtado_SINPLAN.Not.pdf">ftp://obaluae.inf.puc-rio.br/pub/docs/Publications/88_AI_Furtado_SINPLAN.Not.pdf</a></li>
</ul>
</div>
</div>
<div id="outline-container-org4a0c336" class="outline-4">
<h4 id="org4a0c336"><span class="section-number-4">4.2.2</span> Embedding Haskell in Prolog: Nobody is talking about this.</h4>
</div>
</div>
<div id="outline-container-orgff76257" class="outline-3">
<h3 id="orgff76257"><span class="section-number-3">4.3</span> Directives like <code>:- op</code> complicate parsing a Prolog source code.</h3>
</div>
<div id="outline-container-org931ca1c" class="outline-3">
<h3 id="org931ca1c"><span class="section-number-3">4.4</span> Defining your own operators</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li><code>:- op(Precedence, Type, Name)</code></li>
</ul>
</div>
</div>
<div id="outline-container-orgda69842" class="outline-3">
<h3 id="orgda69842"><span class="section-number-3">4.5</span> Meta-programming</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>To define 'macros', use <code>term_expansion</code> or <code>goal_expansion</code>.</li>
</ul>
</div>
</div>
<div id="outline-container-org8eef091" class="outline-3">
<h3 id="org8eef091"><span class="section-number-3">4.6</span> Use clpfd #=/2 instead of is/2?</h3>
<div class="outline-text-3" id="text-4-6">
<p>
But it's good to have minimal dependencies.
</p>
</div>
</div>
<div id="outline-container-org853cdaa" class="outline-3">
<h3 id="org853cdaa"><span class="section-number-3">4.7</span> Comparison between what is difficult in various programming languages</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>2014 presentation "That scripting language called Prolog" <a href="https://www.slideshare.net/SergeiWinitzki/prolog-talk">https://www.slideshare.net/SergeiWinitzki/prolog-talk</a>
<ul class="org-ul">
<li>It compares what is difficult in various programming languages.</li>
<li>It defines "declarative": 'Programming is "declarative" when <i>specifications are programs</i>.'
<ul class="org-ul">
<li>Slide 29: "declarative programming = creating a good DSL for your domain"</li>
</ul></li>
<li>Slide 24 compares SQL, Datalog, and Prolog.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgaba238f" class="outline-3">
<h3 id="orgaba238f"><span class="section-number-3">4.8</span> Difference lists</h3>
<div class="outline-text-3" id="text-4-8">
<ul class="org-ul">
<li>Who invented difference lists when?</li>
</ul>

<p>
A "difference list" is a term of the form <code>A - B</code> where <code>A</code> is a list and <code>B</code> is a list.
</p>

<p>
A difference list represents a list.
</p>

<p>
The difference list <code>A - []</code> represents the list <code>A</code>.
</p>

<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Difference_list">https://en.wikipedia.org/wiki/Difference_list</a></li>
<li><a href="https://en.wikibooks.org/wiki/Prolog/Difference_Lists">https://en.wikibooks.org/wiki/Prolog/Difference_Lists</a>
<ul class="org-ul">
<li>Difference list has constant-time append.
Ordinary list has linear-time append.</li>
</ul></li>
<li><a href="https://wiki.haskell.org/Difference_list">https://wiki.haskell.org/Difference_list</a>
<ul class="org-ul">
<li>"Whether this kind of difference list is more efficient than another list representations depends on usage patterns."</li>
</ul></li>
<li><a href="http://homepages.inf.ed.ac.uk/pbrna/prologbook/node180.html">http://homepages.inf.ed.ac.uk/pbrna/prologbook/node180.html</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgd6b7309" class="outline-3">
<h3 id="orgd6b7309"><span class="section-number-3">4.9</span> What? 99 Prolog problems?</h3>
<div class="outline-text-3" id="text-4-9">
<ul class="org-ul">
<li>99 Prolog problems <a href="http://www.ic.unicamp.br/~meidanis/courses/problemas-prolog/">http://www.ic.unicamp.br/~meidanis/courses/problemas-prolog/</a></li>
</ul>
</div>
</div>
<div id="outline-container-org4b775c7" class="outline-3">
<h3 id="org4b775c7"><span class="section-number-3">4.10</span> Iterative deepening search with length/1</h3>
<div class="outline-text-3" id="text-4-10">
<p>
Prolog uses depth-first search.
It isn't complete.
(What does that mean?)
</p>

<p>
If you have a query <code>goal(List)</code> where <code>List</code> is a list,
then you can query <code>length(List, _), goal(List)</code> to make the search complete.
</p>

<p>
<a href="https://en.wikibooks.org/wiki/Prolog/Search_techniques">https://en.wikibooks.org/wiki/Prolog/Search_techniques</a>
</p>
</div>
</div>
<div id="outline-container-org71915a3" class="outline-3">
<h3 id="org71915a3"><span class="section-number-3">4.11</span> <span class="timestamp-wrapper"><span class="timestamp">&lt;2018-10-20&gt; </span></span> How do we make sense of this counterintuitive module syntax?</h3>
<div class="outline-text-3" id="text-4-11">
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/42399020/how-to-get-a-listing-of-a-specific-knowledge-base">https://stackoverflow.com/questions/42399020/how-to-get-a-listing-of-a-specific-knowledge-base</a></li>
</ul>
</div>
</div>
<div id="outline-container-orga52d884" class="outline-3">
<h3 id="orga52d884"><span class="section-number-3">4.12</span> Comparison between ontology, relational programming, and database programming</h3>
<div class="outline-text-3" id="text-4-12">
</div>
<div id="outline-container-org1c7aa9c" class="outline-4">
<h4 id="org1c7aa9c"><span class="section-number-4">4.12.1</span> Open World Assumption vs Closed World Assumption</h4>
<div class="outline-text-4" id="text-4-12-1">
<ul class="org-ul">
<li><a href="http://www.mkbergman.com/852/the-open-world-assumption-elephant-in-the-room/">http://www.mkbergman.com/852/the-open-world-assumption-elephant-in-the-room/</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1701963" class="outline-3">
<h3 id="org1701963"><span class="section-number-3">4.13</span> Discover the wonderful world of Prolog / logic programming / relational programming</h3>
<div class="outline-text-3" id="text-4-13">
</div>
<div id="outline-container-org9ba8c58" class="outline-4">
<h4 id="org9ba8c58"><span class="section-number-4">4.13.1</span> Symbolic AI is the easiest AI approach.</h4>
<div class="outline-text-4" id="text-4-13-1">
<ul class="org-ul">
<li>Connectionist AI (neural networks) excels at tasks that are difficult to describe in formal logic.</li>
<li>Symbolic AI (Prolog) is much more understandable and predictable than connectionist AI.
<ul class="org-ul">
<li>Understanding connectionist AI requires probability, statistics, and real analysis.</li>
</ul></li>
<li>Why not both?
2017 article "SLDR-DL: A Framework for SLD-Resolution with Deep Learning" <a href="https://arxiv.org/pdf/1705.02210.pdf">https://arxiv.org/pdf/1705.02210.pdf</a>?</li>
</ul>
</div>
</div>
<div id="outline-container-orge2c5e32" class="outline-4">
<h4 id="orge2c5e32"><span class="section-number-4">4.13.2</span> Dreams</h4>
<div class="outline-text-4" id="text-4-13-2">
<ul class="org-ul">
<li>offload/scale/formalize thinking/cognition</li>
<li>transform reasoning into data entry</li>
<li>brain prosthetics; cognitive prosthetics</li>
<li>Leibniz, "Let us calculate!", calculus ratiocinator
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Calculus_ratiocinator">https://en.wikipedia.org/wiki/Calculus_ratiocinator</a></li>
<li><a href="https://publicdomainreview.org/2016/11/10/let-us-calculate-leibniz-llull-and-computational-imagination/">https://publicdomainreview.org/2016/11/10/let-us-calculate-leibniz-llull-and-computational-imagination/</a></li>
</ul></li>
<li>probabilistic logic programming</li>
<li><a href="https://softwareengineering.stackexchange.com/questions/275680/the-dream-of-declarative-programming">https://softwareengineering.stackexchange.com/questions/275680/the-dream-of-declarative-programming</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf71d684" class="outline-3">
<h3 id="orgf71d684"><span class="section-number-3">4.14</span> Comparison with other relational programming languages</h3>
<div class="outline-text-3" id="text-4-14">
<p>
Comparison with miniKanren:
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/28467011/what-are-the-main-technical-differences-between-prolog-and-minikanren-with-resp">https://stackoverflow.com/questions/28467011/what-are-the-main-technical-differences-between-prolog-and-minikanren-with-resp</a>
<ul class="org-ul">
<li>William E. Byrd's answer:
<ul class="org-ul">
<li>Prolog is practical; miniKanren is pure.</li>
<li>Prolog unification doesn't use occurs check; miniKanren unification uses occurs check.</li>
<li>Prolog uses depth-first search; miniKanren uses complete interleaving search.</li>
<li>'[&#x2026;] miniKanren is being used for research in "relational" programming.'</li>
<li>"Over time miniKanren has added more symbolic constraints, really becoming a symbolically-oriented Constraint Logic Programming language."</li>
<li>"There are other very interesting logic programming languages as well, such as Mercury, Curry, and Gödel, each of which has its own take on logic programming."</li>
</ul></li>
</ul></li>
</ul>

<p>
Mercury vs Prolog
</p>
<ul class="org-ul">
<li><a href="http://lambda-the-ultimate.org/node/890">http://lambda-the-ultimate.org/node/890</a></li>
<li><span class="timestamp-wrapper"><span class="timestamp">&lt;2018-10-21&gt; </span></span> "The Prolog to Mercury transition guide" <a href="https://www.mercurylang.org/information/doc-latest/transition_guide.pdf">https://www.mercurylang.org/information/doc-latest/transition_guide.pdf</a></li>
</ul>

<p>
SQL? Datalog?
</p>
</div>
</div>
<div id="outline-container-org56b9135" class="outline-3">
<h3 id="org56b9135"><span class="section-number-3">4.15</span> Reminder for those who already know</h3>
<div class="outline-text-3" id="text-4-15">
<p>
Elucidating
<a href="https://en.wikipedia.org/wiki/Prolog_syntax_and_semantics">https://en.wikipedia.org/wiki/Prolog_syntax_and_semantics</a>
</p>
</div>
</div>
<div id="outline-container-org08ac6ad" class="outline-3">
<h3 id="org08ac6ad"><span class="section-number-3">4.16</span> "Universal-transpiler": Similar to what we want</h3>
<div class="outline-text-3" id="text-4-16">
<ul class="org-ul">
<li>"Universal-transpiler"
<ul class="org-ul">
<li><a href="https://github.com/jarble/transpiler">https://github.com/jarble/transpiler</a>
<ul class="org-ul">
<li>it also has links to similar projects</li>
</ul></li>
<li><a href="http://www.swi-prolog.org/pack/list?p=transpiler">http://www.swi-prolog.org/pack/list?p=transpiler</a></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga93cc9a" class="outline-3">
<h3 id="orga93cc9a"><span class="section-number-3">4.17</span> Logic programming vs theorem proving</h3>
<div class="outline-text-3" id="text-4-17">
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/36335633/difference-between-logic-programming-and-automated-theorem-proving">https://stackoverflow.com/questions/36335633/difference-between-logic-programming-and-automated-theorem-proving</a></li>
<li><a href="https://en.wikipedia.org/wiki/Automated_theorem_proving">https://en.wikipedia.org/wiki/Automated_theorem_proving</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgbbbadf1" class="outline-3">
<h3 id="orgbbbadf1"><span class="section-number-3">4.18</span> Knowledge representation and software specification</h3>
<div class="outline-text-3" id="text-4-18">
</div>
<div id="outline-container-orgf5826c1" class="outline-4">
<h4 id="orgf5826c1"><span class="section-number-4">4.18.1</span> Their relationships</h4>
<div class="outline-text-4" id="text-4-18-1">
<ul class="org-ul">
<li>2010, "Functional-Logic Programming Lecture Notes", Harold Boley, slides, <a href="http://www.cs.unb.ca/~boley/FLP/cs6905FLP.pdf">pdf</a>
<ul class="org-ul">
<li>Knowledge representation in AI roughly corresponds to software specification in software engineering.</li>
<li>Declarative programs can be thought as executable specifications.</li>
<li>Invertibility principle (slide 36)</li>
<li>Nesting/conjunction principle (slide 46)</li>
<li>Unification principle (slide 50)</li>
<li>Amalgamation/integration principle (slide 55)</li>
<li>That's a long deck: 270 slides.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org772a721" class="outline-4">
<h4 id="org772a721"><span class="section-number-4">4.18.2</span> Executable specification?</h4>
<div class="outline-text-4" id="text-4-18-2">
<ul class="org-ul">
<li>lightweight executable mathematics <a href="https://www.cl.cam.ac.uk/~pes20/lem/">https://www.cl.cam.ac.uk/~pes20/lem/</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org946e3fa" class="outline-3">
<h3 id="org946e3fa"><span class="section-number-3">4.19</span> Combine closed-world assumption (logic programming / relational database) and open-world assumption (web ontology)</h3>
</div>
<div id="outline-container-orge4f7af2" class="outline-3">
<h3 id="orge4f7af2"><span class="section-number-3">4.20</span> Making compilers</h3>
<div class="outline-text-3" id="text-4-20">
<ul class="org-ul">
<li><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/9em9jf/future_directions_for_optimizing_compilers/">https://www.reddit.com/r/ProgrammingLanguages/comments/9em9jf/future_directions_for_optimizing_compilers/</a>
<ul class="org-ul">
<li>"Future Directions for Optimizing Compilers" <a href="https://arxiv.org/abs/1809.02161">https://arxiv.org/abs/1809.02161</a></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6fe9637" class="outline-3">
<h3 id="org6fe9637"><span class="section-number-3">4.21</span> Declarative programming languages</h3>
<div class="outline-text-3" id="text-4-21">
<p>
<a href="http://www.cse.chalmers.se/~oloft/Papers/wm96/node2.html">Declarative Programming Languages</a>, functional logic programming, two ways it is done (narrowing and residuation);
definitional programming, GCLA language (separate definition and control)
</p>

<ul class="org-ul">
<li>1995, "Functional Logic Programming in GCLA", <a href="http://www.cse.chalmers.se/~oloft/Papers/wm95.pdf">pdf</a></li>
</ul>
</div>
</div>
<div id="outline-container-org1289834" class="outline-3">
<h3 id="org1289834"><span class="section-number-3">4.22</span> How are Prolog and Lisp similar?</h3>
<div class="outline-text-3" id="text-4-22">
<ul class="org-ul">
<li>Both Prolog and Lisp have symbols and cons cells.
<ul class="org-ul">
<li>This is a Lisp cons cell: <code>(cons 'a 'b)</code> or <code>'(a . b)</code>.</li>
<li>This is the corresponding SWI-Prolog cons cell: <code>[a|b]</code> (the canonical form is <code>'[|]'(a,b)</code>).</li>
</ul></li>
<li>Both have macros.
<ul class="org-ul">
<li>Lisp has defmacro.</li>
<li>Prolog has term_expansion/2 and goal_expansion/2.</li>
</ul></li>
</ul>

<p>
I'd say Prolog = Lisp + unification + backtracking - lambda.
</p>
</div>
</div>
<div id="outline-container-org3c37b19" class="outline-3">
<h3 id="org3c37b19"><span class="section-number-3">4.23</span> Speculative</h3>
<div class="outline-text-3" id="text-4-23">
</div>
<div id="outline-container-org9f4de94" class="outline-4">
<h4 id="org9f4de94"><span class="section-number-4">4.23.1</span> Fast logic programming?</h4>
<div class="outline-text-4" id="text-4-23-1">
<ul class="org-ul">
<li><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/9fgv3v/can_logic_programming_execute_as_fast_as/">https://www.reddit.com/r/ProgrammingLanguages/comments/9fgv3v/can_logic_programming_execute_as_fast_as/</a>
<ul class="org-ul">
<li><a href="https://www.info.ucl.ac.be/~pvr/Peter.thesis/Peter.thesis.html">https://www.info.ucl.ac.be/~pvr/Peter.thesis/Peter.thesis.html</a></li>
</ul></li>
<li><a href="https://stackoverflow.com/questions/23711790/comparision-of-abstract-machines-for-execution-of-prolog">https://stackoverflow.com/questions/23711790/comparision-of-abstract-machines-for-execution-of-prolog</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgedb661a" class="outline-4">
<h4 id="orgedb661a"><span class="section-number-4">4.23.2</span> Lambda-prolog?</h4>
<div class="outline-text-4" id="text-4-23-2">
<ul class="org-ul">
<li>lambda-prolog <a href="http://www.lix.polytechnique.fr/~dale/lProlog/">http://www.lix.polytechnique.fr/~dale/lProlog/</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8864f0c" class="outline-3">
<h3 id="org8864f0c"><span class="section-number-3">4.24</span> Resources</h3>
<div class="outline-text-3" id="text-4-24">
</div>
<div id="outline-container-org3358571" class="outline-4">
<h4 id="org3358571"><span class="section-number-4">4.24.1</span> For beginners</h4>
</div>
<div id="outline-container-orge83f5ba" class="outline-4">
<h4 id="orge83f5ba"><span class="section-number-4">4.24.2</span> Not for beginners</h4>
<div class="outline-text-4" id="text-4-24-2">
<ul class="org-ul">
<li>1990 book "The craft of Prolog" by Richard A. O'Keefe
<ul class="org-ul">
<li>from the preface:
"There are a lot of introductory Prolog books around.
This is not one of them.
Think of it as "second steps in Prolog".
If you have already read one of the introductory books, if you have taken an introductory course on Prolog, if you have written one or two Prolog programs, and if you are wondering why it is still hard to writegood Prolog programs, this book is meant to help you.
The purpose of the book is to show you how you can write Prolog programs that work, that don't take an unreasonable amount of time, and that are clean enough to show to your friends."</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org574abf4" class="outline-3">
<h3 id="org574abf4"><span class="section-number-3">4.25</span> What?</h3>
<div class="outline-text-3" id="text-4-25">
</div>
<div id="outline-container-orge795ae4" class="outline-4">
<h4 id="orge795ae4"><span class="section-number-4">4.25.1</span> P# translates Prolog to C#.</h4>
<div class="outline-text-4" id="text-4-25-1">
<p>
<a href="https://pdfs.semanticscholar.org/12ec/568a6583d3d66b6821f28269f06937a9f2eb.pdf">https://pdfs.semanticscholar.org/12ec/568a6583d3d66b6821f28269f06937a9f2eb.pdf</a>
</p>
</div>
</div>
<div id="outline-container-org52d5d28" class="outline-4">
<h4 id="org52d5d28"><span class="section-number-4">4.25.2</span> "Real World Programming in SWI-Prolog"</h4>
<div class="outline-text-4" id="text-4-25-2">
<p>
<a href="http://www.pathwayslms.com/swipltuts/index.html">http://www.pathwayslms.com/swipltuts/index.html</a>
</p>
</div>
</div>
<div id="outline-container-org1975287" class="outline-4">
<h4 id="org1975287"><span class="section-number-4">4.25.3</span> "Frequently Asked Questions for ##Prolog"</h4>
<div class="outline-text-4" id="text-4-25-3">
<p>
<a href="http://www.pathwayslms.com/swipltuts/student/">http://www.pathwayslms.com/swipltuts/student/</a>
</p>
</div>
</div>
</div>
<div id="outline-container-org3a7676e" class="outline-3">
<h3 id="org3a7676e"><span class="section-number-3">4.26</span> What are these trying to say?</h3>
<div class="outline-text-3" id="text-4-26">
<ul class="org-ul">
<li>1991 article "Logic Programming, Functional Programming, and Inductive Definitions" <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-205.pdf">https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-205.pdf</a>
<ul class="org-ul">
<li>"The unification of logic and functional programming, like the Holy Grail, is sought by countless people"</li>
<li>"More generally, we suggest that the traditional paradigm — logic programming as first-order logic — is seriously out of step with practice.
We offer an alternative paradigm. We view the logic program as an <i>inductive definition</i> of sets and relations."</li>
<li>"To justify the Closed World Assumption, we propose that logic programs should be viewed as inductive definitions, not as first-order theories.
Some people refuse to abandon the dream of programming in first-order logic.
But we have to ask whether this dream is possible — even whether it is desirable.
The first-order paradigm does not deal adequately with negation in databases, and seems to be an unreliable guide in research on program correctness and language design.
Inductive definitions are more fundamental than first-order logic, and perhaps easier to understand."</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4a50502" class="outline-3">
<h3 id="org4a50502"><span class="section-number-3">4.27</span> Books?</h3>
<div class="outline-text-3" id="text-4-27">
<ul class="org-ul">
<li>1995 book "Prolog Programming in Depth" <a href="http://www.lsv.fr/~reichert/Enseignement/2012/PPL/Prolog_Programming_In_Depth.pdf">http://www.lsv.fr/~reichert/Enseignement/2012/PPL/Prolog_Programming_In_Depth.pdf</a>
<ul class="org-ul">
<li>1.16 Styles of encoding knowledge, p. 28
<ul class="org-ul">
<li>parent, male, female vs. father, mother</li>
<li>"Which style is computationally more efficient depends on the kinds of queries to be answered."</li>
<li>"Unlike other knowledge representation languages, Prolog does not force the knowledge base builder to state information in a particular logical style.
Information can be entered in whatever form is most convenient, and then appropriate rules can be added to retrieve the information in a different form."</li>
<li>"We could use a 'data-record' format to encode the family tree like [person(Name,Sex,Father,Mother)]"
<ul class="org-ul">
<li>"The only advantage of this style is that the multi-argument facts are often easy to generate from conventional databases,
by simply printing out the data in a format that conforms to Prolog syntax."</li>
</ul></li>
</ul></li>
<li>5.12 Grand Finale: Reading a Lotus Spreadsheet, p. 148</li>
<li>5.13 Language and Metalanguage, p. 153
<ul class="org-ul">
<li>"A Prolog program can extend and modify the inference engine that controls program execution.
Thus, the language can change itself in ways that go beyond superficial syntax."
<ul class="org-ul">
<li>Really? How?</li>
</ul></li>
</ul></li>
<li>5.17 Intensional and Extensional Queries, p. 159</li>
<li>5.19 Giving Meaning to Operators, p. 163
<ul class="org-ul">
<li>"How to make the ampersand mean 'and' in Prolog"</li>
</ul></li>
<li>5.20 Prolog in Prolog, p. 165
<ul class="org-ul">
<li>"Meta-interpreter for Prolog"</li>
</ul></li>
<li>5.21 Extending the inference engine, p. 167
<ul class="org-ul">
<li>biconditionals</li>
</ul></li>
<li>11 Defeasible Prolog, p. 347
<ul class="org-ul">
<li>11.1 Nonmonotonic reasoning and Prolog, p. 347
<ul class="org-ul">
<li>"If our reasoning is monotonic, the set of conclusions we draw from the information we have only gets larger as we get more and more information.
Once we reach a conclusion, no additional information will cause us to reject it.
When our reasoning is nonmonotonic, we may reject an earlier conclusion on the basis of new information."</li>
<li>"Human reasoning is notoriously nonmonotonic. We make plans based on what we expect to happen,
but we constantly revise our expectations, and our plans, as events unfold."</li>
<li>"The Prolog inference engine is nonmonotonic because of the way it handles negation."</li>
<li>Why is "defeasible" not spelled "defeatable"?</li>
</ul></li>
<li>11.2 New syntax for defeasible reasoning, p. 348
<ul class="org-ul">
<li>"Although Prolog can perform some kinds of nonmonotonic reasoning, Prolog rules are not defeasible."</li>
<li>"Some instances of defeasible reasoning cannot be reproduced in ordinary Prolog."</li>
<li>"What we need is a new way to represent defeasible rules and presumptions and
an inference engine that knows how to use them. We also need a negation operator
that is different from negation-as-failure so we can represent rules that tell us
when something is positively not the case rather than just that we cannot <i>prove</i> that it is the case.
These negative rules are needed to tell us when we have an exception to a defeasible rule, but they are desirable in their own right as well."
<ul class="org-ul">
<li>The second sentence is too long.</li>
</ul></li>
</ul></li>
<li>(I haven't read it.)</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>

  </div>

</article>

      </div>
    </main>

    
    
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
var disqus_config = function () {
    this.page.url = "https://edom.github.io/prolog.html";  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = "https://edom.github.io/prolog.html"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://edom-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    

    <footer class="site-footer h-card">
    <data class="u-url" href="/"></data>

    <div class="wrapper">
        <p>This page was created on 2018-04-11 00:00 +0700.</p>
        <p class="rss-subscribe">There is an <a href="/feed.xml">RSS feed</a>,
        but it's unused because this site is a wiki, not a blog.</p>
        <p>Stop writing books, papers, and blogs! Write a personal wiki instead! Or, even better, contribute to a community wiki.</p>
    </div>

</footer>


  </body>

</html>
