<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Using the Prolog programming language</title>
        <link rel="stylesheet" href="/assets/main.css"/>
        <script>
// Help the reader estimate how much time the reading is going to take.
// Show word count and reading time estimation in TOC entry.
//
// TOC = table of contents
//
// Known issue: This janks: this DOM manipulation is done after the page is rendered.
// If we don't want jank, we have to manipulate the HTML source before it reaches the browser.
// We assume that the user doesn't refresh the page while reading.
// The benefit of fixing that jank is not enough for me to justify trying to fix it.
document.addEventListener("DOMContentLoaded", function () {
    function count_word (string) {
        return string.trim().split(/\s+/).length;
    }
    function show_quantity (count, singular) {
        let plural = singular + "s"; // For this script only.
        return count + " " + ((count == 1) ? singular : plural);
    }
    function create_length_indicator (word, minute) {
        let e = document.createElement("div");
        e.className = "toc_entry__length_indicator";
        e.textContent = " (" + show_quantity(word, "word") + " ~ " + show_quantity(minute, "minute") + ")";
        return e;
    }
    // We assume that readers read this many words per minute with 100% comprehension.
    // This assumption may not hold for dense texts such as philosophy and mathematics.
    const wpm_assumption = 200;
    // We assume a certain Jekyll template.
    let page = document.querySelector("main.page-content");
    if (page === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"main.page-content\" does not match anything");
        return;
    }
    let page_title = document.querySelector("header.post-header h1.post-title");
    if (page_title === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"header.post-header h1.post-title\" does not match anything");
        return;
    }
    let page_word = count_word(page.textContent);
    let page_minute = Math.ceil(page_word / wpm_assumption);
    page_title.insertAdjacentElement("afterend", create_length_indicator(page_word, page_minute));
    // We violate the HTML specification.
    // The page may have several elements with the same ID.
    // We assume that Org HTML Export generates a DIV element with ID "table-of-contents".
    // We assume that Jekyll Markdown-to-HTML generates a UL element with ID "markdown-toc".
    // This only works for Org HTML Export's TOC.
    let toc_entries = document.querySelectorAll("#table-of-contents a, #text-table-of-contents a");
    toc_entries.forEach((toc_entry_a) => {
        let href = toc_entry_a.getAttribute("href"); // We assume that this is a string like "#org0123456".
        if (href.charAt(0) !== '#') {
            console.log("toc_generate_estimate: Impossible: " + href + " does not begin with hash sign");
            return;
        }
        // We can't just document.querySelector(href) because target_id may contain invalid ID characters such as periods.
        let target_id = href.substring(1);
        let id_escaped = target_id.replace("\"", "\\\"");
        let h_elem = document.querySelector("[id=\"" + id_escaped + "\"]"); // We assume that this is the h1/h2/h3 element referred by the TOC entry.
        if (h_elem === null) { // We assume that this is impossible.
            console.log("toc_generate_estimate: Impossible: " + href + " does not refer to anything");
            return;
        }
        let section = h_elem.parentNode;
        let section_word = count_word(section.textContent);
        let section_minute = Math.ceil(section_word / wpm_assumption);
        toc_entry_a.insertAdjacentElement("afterend", create_length_indicator(section_word, section_minute));
    });
});
        </script>

        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12628443-6"></script>
<script>
  window['ga-disable-UA-12628443-6'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-12628443-6');
</script>
        
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            jax: ["input/TeX","input/MathML","input/AsciiMath",
            "output/CommonHTML"
            ],
            extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "a11y/accessibility-menu.js"],
            TeX: {
                extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
                , equationNumbers: {
                    autoNumber: "AMS"
                }
            },
            "CommonHTML": {
                scale: 100
            },
            "fast-preview": {
                disabled: true,
            }
        });
        </script>
        <style>
            /*
            PreviewHTML produces small Times New Roman text.
            PreviewHTML scale doesn't work.
            */
            .MathJax_PHTML { font-size: 110%; }
        </style>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js" async defer></script>
    </head>
    <body>
        <header class="site-header" role="banner">
            <div class="wrapper">
                <a class="site-title" rel="author" href="/">Erik Dominikus Research Group</a>
            </div>
        </header>
    <div style="display:none;">\(
    \renewcommand\emptyset{\varnothing}
    \newcommand\abs[1]{\left|#1\right|}
    \newcommand\dom{\textrm{dom}}
    \newcommand\cod{\textrm{cod}}
    \newcommand\Bernoulli{\textrm{Bernoulli}}
    \newcommand\Binomial{\textrm{Binomial}}
    \newcommand\Expect[1]{\mathbb{E}[#1]}
    \newcommand\Nat{\mathbb{N}}
    \newcommand\Integers{\mathbb{Z}}
    \newcommand\Real{\mathbb{R}}
    \newcommand\Rational{\mathbb{Q}}
    \newcommand\Complex{\mathbb{C}}
    \newcommand\Pr{\mathrm{P}}
    \newcommand\Time{\text{Time}}
    \newcommand\DTime{\text{DTime}}
    \newcommand\NTime{\text{NTime}}
    \newcommand\TimeP{\text{P}}
    \newcommand\TimeNP{\text{NP}}
    \newcommand\TimeExp{\text{ExpTime}}
    \newcommand\norm[1]{\left\lVert#1\right\rVert}
    \newcommand\bbA{\mathbb{A}}
    \newcommand\bbC{\mathbb{C}}
    \newcommand\bbD{\mathbb{D}}
    \newcommand\bbE{\mathbb{E}}
    \newcommand\bbN{\mathbb{N}}
    \newcommand\frakI{\mathfrak{I}}
    % deprecated; use TimeExp
    \newcommand\ExpTime{\text{ExpTime}}
    \newcommand\Compute{\text{Compute}}
    \newcommand\Search{\text{Search}}
    % model theory structure
    \newcommand\struc[1]{\mathcal{#1}}
    \newcommand\SetBuilder[2]{\{#1 ~|~ #2\}}
    \newcommand\Set[1]{\{#1\}}
    \newcommand\semantics[1]{\langle #1 \rangle}
    \newcommand\bigsemantics[1]{S\left(#1\right)}
    \)</div>
        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
                    <header class="post-header">
                        <h1 class="post-title">Using the Prolog programming language</h1>
                    </header>
                </article>
                <div class="post-content">
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1</span><span class="section_title"><a href="#finding-psychological-security-before-going-full-prolog">Finding psychological security before going full Prolog</a></span><span class="word_count">(1197w~6m)</span></li>
<li><span class="section_number">2</span><span class="section_title"><a href="#set-up-and-workflow">Set-up and workflow</a></span><span class="word_count">(815w~5m)</span></li>
<li><span class="section_number">3</span><span class="section_title"><a href="#understanding-prolog">Understanding Prolog</a></span><span class="word_count">(2684w~14m)</span></li>
<li><span class="section_number">4</span><span class="section_title"><a href="#graphical-user-interface-programming">Graphical-user-interface programming</a></span><span class="word_count">(455w~3m)</span></li>
<li><span class="section_number">5</span><span class="section_title"><a href="#maintaining-large-knowledge-bases">Maintaining large knowledge bases</a></span><span class="word_count">(707w~4m)</span></li>
<li><span class="section_number">6</span><span class="section_title"><a href="#logtalk-1">Logtalk</a></span><span class="word_count">(54w~1m)</span></li>
<li><span class="section_number">7</span><span class="section_title"><a href="#ugly-things-awkward-squads-states-and-errors">Ugly things, awkward squads, states and errors</a></span><span class="word_count">(955w~5m)</span></li>
<li><span class="section_number">8</span><span class="section_title"><a href="#object-logic-programming">Object-logic programming?</a></span><span class="word_count">(623w~4m)</span></li>
<li><span class="section_number">9</span><span class="section_title"><a href="#writing-enterprise-web-applications">Writing enterprise web applications</a></span><span class="word_count">(1212w~7m)</span></li>
<li><span class="section_number">10</span><span class="section_title"><a href="#dsl-meta-programming-optimizing-checking-multi-paradigm-whatnot">DSL, meta-programming, optimizing, checking, multi-paradigm, whatnot</a></span><span class="word_count">(826w~5m)</span></li>
<li><span class="section_number">11</span><span class="section_title"><a href="#theoretical-foundations-of-logic-programming">Theoretical foundations of logic programming</a></span><span class="word_count">(467w~3m)</span></li>
<li><span class="section_number">12</span><span class="section_title"><a href="#artificial-intelligence">Artificial intelligence?</a></span><span class="word_count">(149w~1m)</span></li>
<li><span class="section_number">13</span><span class="section_title"><a href="#what-mess">What mess?</a></span><span class="word_count">(1702w~9m)</span></li>
<li><span class="section_number">14</span><span class="section_title"><a href="#rethinking-module-systems-especially-of-prolog">Rethinking module systems, especially of Prolog</a></span><span class="word_count">(3617w~19m)</span></li>
<li><span class="section_number">15</span><span class="section_title"><a href="#the-problems-with-prolog">The problems with Prolog</a></span><span class="word_count">(1224w~7m)</span></li>
<li><span class="section_number">16</span><span class="section_title"><a href="#extending-prolog">Extending Prolog</a></span><span class="word_count">(91w~1m)</span></li>
<li><span class="section_number">17</span><span class="section_title"><a href="#program-checking">Program checking</a></span><span class="word_count">(294w~2m)</span></li>
<li><span class="section_number">18</span><span class="section_title"><a href="#sometimes-we-want-function-and-determinism">Sometimes we want function and determinism</a></span><span class="word_count">(57w~1m)</span></li>
<li><span class="section_number">19</span><span class="section_title"><a href="#prolog-implementation">Prolog implementation</a></span><span class="word_count">(572w~3m)</span></li>
<li><span class="section_number">20</span><span class="section_title"><a href="#swi-prolog-packs">SWI-Prolog packs</a></span><span class="word_count">(95w~1m)</span></li>
<li><span class="section_number">21</span><span class="section_title"><a href="#what-i-like-about-prolog-and-lisp">What I like about Prolog and Lisp</a></span><span class="word_count">(54w~1m)</span></li>
<li><span class="section_number">22</span><span class="section_title"><a href="#namespacing-atoms">Namespacing atoms</a></span><span class="word_count">(47w~1m)</span></li>
<li><span class="section_number">23</span><span class="section_title"><a href="#parsing-prolog">Parsing Prolog?</a></span><span class="word_count">(11w~1m)</span></li>
<li><span class="section_number">24</span><span class="section_title"><a href="#other-resources">Other resources</a></span><span class="word_count">(12w~1m)</span></li>
<li><span class="section_number">25</span><span class="section_title"><a href="#bibliography">Bibliography</a></span><span class="word_count">(543w~3m)</span></li>
</ul>
</div>
<h2 id="finding-psychological-security-before-going-full-prolog"><span class="section_number">1</span><span class="section_title">Finding psychological security before going full Prolog</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.1</span><span class="section_title"><a href="#this-is-a-book-in-progress">&lt;2018-11-30&gt; This is a book in progress!</a></span><span class="word_count">(138w~1m)</span></li>
<li><span class="section_number">1.2</span><span class="section_title"><a href="#warning-about-the-woes-and-blockers">Warning about the woes and blockers</a></span><span class="word_count">(239w~2m)</span></li>
<li><span class="section_number">1.3</span><span class="section_title"><a href="#if-you-need-to-be-hyped-up">If you need to be hyped up</a></span><span class="word_count">(350w~2m)</span></li>
<li><span class="section_number">1.4</span><span class="section_title"><a href="#not-sure-yet-try-prolog-with-minimal-investment.">Not sure yet? Try Prolog with minimal investment.</a></span><span class="word_count">(33w~1m)</span></li>
<li><span class="section_number">1.5</span><span class="section_title"><a href="#comparing-prolog-implementations">Comparing Prolog implementations?</a></span><span class="word_count">(133w~1m)</span></li>
<li><span class="section_number">1.6</span><span class="section_title"><a href="#is-there-any-prolog-ide">&lt;2019-03-26&gt; Is there any Prolog IDE?</a></span><span class="word_count">(171w~1m)</span></li>
<li><span class="section_number">1.7</span><span class="section_title"><a href="#prolog-community">Prolog community</a></span><span class="word_count">(80w~1m)</span></li>
<li><span class="section_number">1.8</span><span class="section_title"><a href="#recommended-learning-sequence">Recommended learning sequence</a></span><span class="word_count">(54w~1m)</span></li>
</ul>
</div>
<h3 id="this-is-a-book-in-progress"><span class="section_number">1.1</span><span class="section_title">&lt;2018-11-30&gt; This is a book in progress!</span></h3>
<p>I don't know whether I will ever finish this.</p>
<p>By &quot;See file X&quot; I mean a file somewhere in <a href="https://github.com/edom/work">my Github repository</a>.</p>
<p>Who might you be? How might this book serve you?</p>
<ul>
<li>a programmer used to C, C++, Java, PHP, Ruby, Python</li>
<li>a programmer used to Lisp, Scheme, Haskell</li>
<li>a Prolog believer</li>
<li>a Prolog evangelist</li>
<li>someone who used to write Prolog codes</li>
<li>a dreamer who thinks machines should do more</li>
<li>a researcher, theoretician, computer scientist, mathematician, logician, philosopher?</li>
<li>(Who else might you be, why the hell are you here, and how should I write for you?)</li>
</ul>
<p>We are wearing multiple hats:</p>
<ul>
<li>mathematician</li>
<li>philosopher</li>
<li>engineer</li>
</ul>
<p>The goal of this book is to convince you that you should use Prolog to create your next system (what system? game? enterprise application? shell script?).</p>
<p>Ivan Bratko has a &quot;Prolog programming for artificial intelligence&quot; book. I want a &quot;Prolog programming for everything&quot; book.</p>
<h3 id="warning-about-the-woes-and-blockers"><span class="section_number">1.2</span><span class="section_title">Warning about the woes and blockers</span></h3>
<p>I'm selling you Prolog here, but let me be honest: Don't buy it if any of these year-2018 deal-breakers are an issue for you. Prolog isn't ready for these use cases in 2018; I hope these will change.</p>
<p>&lt;2018-12-09&gt; Somewhat fatal: ISO Prolog open/4 has no way to open a file for writing without truncating it. (How the hell did they overlook such a common use case?) But some implementations have extensions to work around that:</p>
<ul>
<li>Prolog implementations that can open a file for both reading and writing:
<ul>
<li>&lt;2018-12-09&gt; Amzi! Prolog open/4 has &quot;readwrite&quot; mode<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></li>
</ul></li>
<li>Prolog implementations that can open a file for writing without truncating it, but not for both reading and writing:
<ul>
<li>&lt;2018-12-09&gt; SWI-Prolog open/4 has &quot;update&quot; mode<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></li>
<li>&lt;2018-12-09&gt; ECLiPSe Prolog open/4 has &quot;update&quot; mode<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></li>
</ul></li>
<li>Prolog implementations that <em>cannot</em> open a file for writing without truncating it:
<ul>
<li>&lt;2018-12-09&gt; GNU Prolog<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></li>
<li>&lt;2018-12-09&gt; SICStus Prolog<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></li>
<li>&lt;2018-12-09&gt; Ciao Prolog<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></li>
</ul></li>
</ul>
<p>&lt;2018-11-30&gt; No arrays.</p>
<p>&lt;2018-11-30&gt; SWI-Prolog is honest: &quot;The main weakness of Prolog are algorithms that require destructive assignment, intensive array processing or bare-metal performance for e.g., processing pixels.&quot;<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a></p>
<p>&lt;2018-10-24&gt; There is no standard date/time/calendar library? There may be one? I'm still looking. library(julian)?</p>
<ul>
<li>Java 8 has &quot;java.util.time&quot;. Previous Java versions can use &quot;Joda Time&quot;.</li>
<li>Haskell has the &quot;time&quot; package (&quot;Data.Time&quot; module).</li>
</ul>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.2.1</span><span class="section_title"><a href="#prolog-weakness-binary-array-and-low-level-input-output">&lt;2018-11-22&gt; Prolog weakness: binary array and low-level input-output</a></span><span class="word_count">(41w~1m)</span></li>
</ul>
</div>
<h4 id="prolog-weakness-binary-array-and-low-level-input-output"><span class="section_number">1.2.1</span><span class="section_title">&lt;2018-11-22&gt; Prolog weakness: binary array and low-level input-output</span></h4>
<p>Prolog doesn't have arrays.</p>
<p>Workaround: we can fake an array: Allocate with functor(T,F,N), read with arg(N,T,A), and write with nb_setarg(N,T,A).</p>
<p>Prolog doesn't have unsigned integers.</p>
<p>How fast is this?</p>
<p>This requires that the implementation doesn't limit functor arguments.</p>
<h3 id="if-you-need-to-be-hyped-up"><span class="section_number">1.3</span><span class="section_title">If you need to be hyped up</span></h3>
<p>(You can skip this.)</p>
<p>&lt;2018-11-30&gt; Don't take this too seriously. I'm on a honeymoon with Prolog.</p>
<p>Prolog is a <em>mind augmentation language</em>. Prolog is a mental prosthesis. With prosthetic arms, I can beat you in arm wrestling. With prosthetic legs, I can beat you in running. With prosthetic minds, I can beat you in thinking. If logic is the language of thought, then Prolog is the closest thing we have to mind dump. Offload your reasoning to computers. As Leibniz said, &quot;Let us calculate!&quot;</p>
<p>You love Lisp macros? Prolog has term_expansion/2, goal_expansion/2, op/2, and the infix operators that you have been dreaming of!</p>
<p>You love Haskell type system? In Prolog you can write your own type systems!</p>
<p>You love C++ operator overloading? In Prolog you can define your own operators with their precedences and associativities!</p>
<p>You want to beat/outdo/one-up your coworkers? Prolog is perfect for that! Unless you're low-level-programming, Prolog is the secret weapon that multiplies your productivity by 20 compared to a low-level programming language such as C, C++, Java. When you build your home, you don't build your own bricks.</p>
<p>Your coworkers are beating you with Prolog? Well, what the hell are you waiting for? Learn Prolog now, or lose your job and die in oblivion!</p>
<p>&quot;Prolog is a convenient language in which to express the semantics of other languages.&quot;<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a></p>
<p>Why logic programming? Because logic is the internal language of thought. It is the highest level programming possible, until we invent telepathy. Don't we dream about programming directly in the language of thought?</p>
<p>A paragraph from Kowalski 1974 <span class="citation" data-cites="kowalski1974predicate">[<a href="#ref-kowalski1974predicate">12</a>]</span>:</p>
<blockquote>
<p>As a programming language, predicate logic is the only language which is entirely user-oriented. It differs from existing high-level languages in that it possesses no features which are meaningful in only machine-level terms. It differs from functional languages like LISP, based on the <span class="math inline">\(\lambda\)</span>-calculus, in that it derives from the normative study of human logic, rather than from investigations into the mathematical logic of functions.&quot;<span class="citation" data-cites="kowalski1974predicate">[<a href="#ref-kowalski1974predicate">12</a>]</span></p>
</blockquote>
<p>&quot;Prolog is an excellent programming contest language: Prolog is close enough to the ultimate specification language (logic), so that the distance between problem and solution is not too big.&quot; <span class="citation" data-cites="demoen2005first">[<a href="#ref-demoen2005first">7</a>]</span></p>
<h3 id="not-sure-yet-try-prolog-with-minimal-investment."><span class="section_number">1.4</span><span class="section_title">Not sure yet? Try Prolog with minimal investment.</span></h3>
<p>If you're not sure yet, I suggest that you read <a href="https://www.metalevel.at/prolog">Markus Triska's book &quot;The power of Prolog&quot;</a> while doodling some code on <a href="http://pengines.swi-prolog.org/apps/swish/index.html">SWISH online Prolog interpreter</a>.</p>
<h3 id="comparing-prolog-implementations"><span class="section_number">1.5</span><span class="section_title">Comparing Prolog implementations?</span></h3>
<p>I use SWI-Prolog because it's what I used in university, and because of this <a href="http://www.swi-prolog.org/features.html">SWI-Prolog sales pitch</a>.</p>
<p>This book assumes that the reader uses SWI-Prolog 7.6.4.</p>
<p>There are many Prolog implementations. Some companies have their own Prolog implementations.</p>
<p>GNU Prolog is &quot;a native-code compiler which produces standalone executables which don’t rely on any byte-code emulator or meta-interpreter.&quot;<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> But as of 2019 GNU Prolog does not have a module system.</p>
<p>What can we conclude from Wikipedia?<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>?</p>
<p>Comparison between SWI Prolog, YAP, GNU Prolog.<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a></p>
<p>How current is this?<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a></p>
<p>Prolog in JavaScript/browser<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a></p>
<p>Questions that we should answer, for each implementation:</p>
<ul>
<li>Who uses it? How many people use it?</li>
<li>What is its strengths?</li>
<li>What is its weaknesses?</li>
<li>Where is its source code?</li>
<li>Does the project seem alive?</li>
<li>Where is the community?</li>
</ul>
<p>The first impression to me is that XSB Prolog has stronger theoretical foundation and SWI-Prolog has stronger practical implementation.</p>
<h3 id="is-there-any-prolog-ide"><span class="section_number">1.6</span><span class="section_title">&lt;2019-03-26&gt; Is there any Prolog IDE?</span></h3>
<p>SWISH?<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a><a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a></p>
<p>I use VSCode. There may be other IDEs, but I don't know which one is supported. It's one of the woes of using an unpopular language: Few people are working on the tools.</p>
<p>&lt;2018-12-10&gt; Smart editors are dangerous! Arbitrary code execution!</p>
<p>I use the VSCode extension VSC-Prolog, but I disabled its linter after I realize that it may execute arbitrary code. I only use its syntax highlighting and documentation popup feature. Fortunately the plugin is still very useful without the linter.</p>
<p>Imagine this file:</p>
<pre class="example"><code>% doom.pro
:- shell(&#39;touch ~/doomed&#39;).
</code></pre>
<p>I loaded that file into VSCode, and a file named <code>doomed</code> appeared in my home directory. I'd be really doomed if someone replaced that command with 'rm -rf /'.</p>
<p>Perhaps we should make a whitelist of allowed directives?</p>
<p>Vim suffers the same thing with its modelines. I think it's now disabled by default?</p>
<p>However, this doesn't affect you if you only open what you write yourself, and never open a criminal's Prolog code. But this is an accident waiting to happen!</p>
<p>I reported this:</p>
<ul>
<li><a href="https://github.com/arthwang/vsc-prolog/issues/31">https://github.com/arthwang/vsc-prolog/issues/31</a></li>
</ul>
<p>I hear some things about Eclipse PDT.</p>
<h3 id="prolog-community"><span class="section_number">1.7</span><span class="section_title">Prolog community</span></h3>
<p>Questions, answers, discussions, news:</p>
<ul>
<li>SWI-Prolog Discourse Group<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>. &lt;2019-04-03&gt; The old SWI-Prolog Google Groups<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a> has been deprecated. They are moving.</li>
<li>IRC requires login. Where is the chat log?</li>
<li>comp.lang.prolog <a href="https://groups.google.com/forum/#!forum/comp.lang.prolog">https://groups.google.com/forum/#!forum/comp.lang.prolog</a></li>
<li>StackOverflow tag swi-prolog <a href="https://stackoverflow.com/questions/tagged/swi-prolog">https://stackoverflow.com/questions/tagged/swi-prolog</a></li>
<li><a href="https://www.reddit.com/r/prolog/">https://www.reddit.com/r/prolog/</a></li>
</ul>
<p>What:</p>
<ul>
<li>SWI-Prolog roadmap <a href="https://github.com/SWI-Prolog/roadmap">https://github.com/SWI-Prolog/roadmap</a></li>
<li><a href="http://www.swi-prolog.org/Links.html">http://www.swi-prolog.org/Links.html</a></li>
</ul>
<p>Unclear links:</p>
<ul>
<li><a href="http://prolog-commons.org">http://prolog-commons.org</a></li>
</ul>
<p>&quot;Conference on the practical application of Prolog&quot;: When was it last held? It seems no more.</p>
<p>Twitter LOPSTR: Logic Based Program Synthesis and Transformation: 13th International…</p>
<p>Who uses Prolog?</p>
<p>Gerrit has prolog? <a href="https://gerrit-review.googlesource.com/Documentation/prolog-cookbook.html">https://gerrit-review.googlesource.com/Documentation/prolog-cookbook.html</a></p>
<p>I hate &quot;awesome&quot; lists like this &quot;awesome Prolog&quot;<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a> list because such lists do not explain <em>why</em> something is awesome.</p>
<h3 id="recommended-learning-sequence"><span class="section_number">1.8</span><span class="section_title">Recommended learning sequence</span></h3>
<ul>
<li>Know how to read Prolog programs.
<ul>
<li>Know basic Prolog syntax.
<ul>
<li>Know what a Prolog <em>term</em> is.</li>
<li>Know what a Prolog <em>clause</em> is.
<ul>
<li>prolog headless clause<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a></li>
</ul></li>
</ul></li>
<li>Know how to read/interpret the meaning of a Prolog clause as an English sentence.</li>
</ul></li>
<li>Know the operational semantics of Prolog.</li>
<li>Know some declarative semantics of Prolog.</li>
<li>Come up with alternative declarative semantics for Prolog programs.</li>
</ul>
<pre class="example"><code>p(0,1).

% is the same as

p(0,1) :- true.
</code></pre>
<h2 id="set-up-and-workflow"><span class="section_number">2</span><span class="section_title">Set-up and workflow</span></h2>
<p>We assume that you have installed SWI-Prolog 7.6.4.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">2.1</span><span class="section_title"><a href="#things-to-do-in-each-os-reinstall">Things to do in each OS reinstall</a></span><span class="word_count">(319w~2m)</span></li>
<li><span class="section_number">2.2</span><span class="section_title"><a href="#workflow">Workflow</a></span><span class="word_count">(488w~3m)</span></li>
</ul>
</div>
<h3 id="things-to-do-in-each-os-reinstall"><span class="section_number">2.1</span><span class="section_title">Things to do in each OS reinstall</span></h3>
<p>This has to be at least once. This may have to be redone every time we replace our operating system, such as when replacing Ubuntu 14.04 with Debian 9.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">2.1.1</span><span class="section_title"><a href="#installing-swi-prolog-7.6.4-on-ubuntu-14.04">&lt;2018-10-20&gt; Installing SWI-Prolog 7.6.4 on Ubuntu 14.04</a></span><span class="word_count">(225w~2m)</span></li>
<li><span class="section_number">2.1.2</span><span class="section_title"><a href="#enabling-readline">Enabling readline</a></span><span class="word_count">(61w~1m)</span></li>
</ul>
</div>
<h4 id="installing-swi-prolog-7.6.4-on-ubuntu-14.04"><span class="section_number">2.1.1</span><span class="section_title">&lt;2018-10-20&gt; Installing SWI-Prolog 7.6.4 on Ubuntu 14.04</span></h4>
<p>If you are using Ubuntu 14.04, follow my instructions below. If your operating system has packaged SWI-Prolog 7.6.4 or newer, use it. Otherwise, follow the <a href="http://www.swi-prolog.org/Download.html">official instructions</a> and find SWI-Prolog 7.6.4.</p>
<p>The following guide is for installing SWI-Prolog 7.6.4 on Ubuntu 14.04.</p>
<p>Uninstall existing SWI-Prolog installations. The version packaged with Ubuntu 14.04 is too old (6.6.4). SWI-Prolog 7 introduces a new double-quoted string type.</p>
<p>Install dependencies. I take this from the <a href="http://www.swi-prolog.org/build/Debian.html">Debian build instructions</a> with these changes. I replace <code>libunwind-dev</code> with <code>libunwind8-dev</code>. I remove <code>openjdk-8-jdk</code> and <code>junit</code>. I add <code>libreadline-dev</code>.</p>
<pre class="example"><code>sudo apt-get install \
        build-essential autoconf curl chrpath pkg-config \
        ncurses-dev libreadline-dev libedit-dev \
        libunwind8-dev \
        libgmp-dev \
        libssl-dev \
        unixodbc-dev \
        zlib1g-dev libarchive-dev \
        libossp-uuid-dev \
        libxext-dev libice-dev libjpeg-dev libxinerama-dev libxft-dev \
        libxpm-dev libxt-dev \
        libdb-dev \
        libpcre3-dev \
        libyaml-dev \
        libreadline-dev
</code></pre>
<p>That doesn't include the documentation dependencies because they are too big. Just read the documentation online.</p>
<p>After apt-get finishes, for security (avoiding sudo cache), close that terminal, and open a new one.</p>
<p>Download the <a href="http://www.swi-prolog.org/download/stable">source</a>.</p>
<p>Check the checksum using sha256sum.</p>
<p><code>cp -p build.templ build</code></p>
<p><code>mkdir -p $HOME/.local</code></p>
<p>Edit <code>build</code> script. Set <code>PREFIX</code> to <code>$HOME/.local</code>. Uncomment the <code>--link</code> option in <code>EXTRACFG</code> variable.</p>
<p>Run <code>./build</code>. It should take a few minutes (about 5 minutes on my 4-core 8-GB-RAM machine).</p>
<p>Ensure that <code>$HOME/.local/bin</code> is in your <code>PATH</code>. For example, I have this line somewhere near the end of my <code>~/.bashrc</code> file:</p>
<pre class="example"><code>export PATH=&quot;$PATH:$HOME/.local/bin&quot;
</code></pre>
<p>If you edit your bashrc, close your terminal and open a new one. Then enter <code>swipl --version</code> in the new terminal. The program should show something like this:</p>
<pre class="example"><code>SWI-Prolog version 7.6.4 for x86_64-linux
</code></pre>
<p>If you don't want to edit your bashrc, you can run swipl by its full path <code>~/.local/bin/swipl</code>.</p>
<h4 id="enabling-readline"><span class="section_number">2.1.2</span><span class="section_title">Enabling readline</span></h4>
<p>We want readline for history (Ctrl+R, Ctrl+S) and completion (Tab, Ctrl+P/Up, Ctrl+N/Down).</p>
<p>To keep the entire codebase under BSD license, SWI-Prolog doesn't enable the GPL-licensed GNU readline by default. But you can tell SWI-Prolog to use readline. First, install your distro's libreadline-dev package. Then, put this line in your <code>~/.swiplrc</code>:</p>
<pre class="example"><code>:- set_prolog_flag(readline, readline).
</code></pre>
<p>Related: <a href="https://github.com/SWI-Prolog/issues/issues/72">GitHub issue #72</a>: &quot;how to build with GNU readline on linux&quot;.</p>
<h3 id="workflow"><span class="section_number">2.2</span><span class="section_title">Workflow</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">2.2.1</span><span class="section_title"><a href="#starting-the-interpreter-and-the-documentation-server">Starting the interpreter and the documentation server</a></span><span class="word_count">(22w~1m)</span></li>
<li><span class="section_number">2.2.2</span><span class="section_title"><a href="#thinking-and-editing">Thinking and editing</a></span><span class="word_count">(70w~1m)</span></li>
<li><span class="section_number">2.2.3</span><span class="section_title"><a href="#rebuilding">Rebuilding</a></span><span class="word_count">(70w~1m)</span></li>
<li><span class="section_number">2.2.4</span><span class="section_title"><a href="#trying-and-manual-testing">Trying and manual testing</a></span><span class="word_count">(121w~1m)</span></li>
<li><span class="section_number">2.2.5</span><span class="section_title"><a href="#seeing-source-codes-and-finding-definitions">Seeing source codes and finding definitions</a></span><span class="word_count">(49w~1m)</span></li>
<li><span class="section_number">2.2.6</span><span class="section_title"><a href="#troubleshooting-tracing-and-spying">Troubleshooting: tracing and spying</a></span><span class="word_count">(130w~1m)</span></li>
<li><span class="section_number">2.2.7</span><span class="section_title"><a href="#committing-to-a-git-repository">Committing to a Git repository</a></span><span class="word_count">(32w~1m)</span></li>
</ul>
</div>
<h4 id="starting-the-interpreter-and-the-documentation-server"><span class="section_number">2.2.1</span><span class="section_title">Starting the interpreter and the documentation server</span></h4>
<p>I start SWI-Prolog with this command line:</p>
<pre class="example"><code>swipl --pldoc=DocPort -l PrologFile
</code></pre>
<p>I use 4002 for DocPort.</p>
<p>I open <a href="http://localhost:4002/pldoc/">http://localhost:4002/pldoc/</a> in my browser.</p>
<h4 id="thinking-and-editing"><span class="section_number">2.2.2</span><span class="section_title">Thinking and editing</span></h4>
<p>I edit some Prolog source files in Visual Studio Code with vim key bindings because I often need to duplicate a line when adding a new clause.</p>
<p>I add statements or comments.</p>
<p>I think a lot about names, representations, and relations.</p>
<p>To edit the source of a thing in PceEmacs, we have several options:</p>
<ul>
<li>click the &quot;Edit file&quot; or &quot;Edit predicate&quot; button in pldoc server, or</li>
<li>query <code>edit(Name)</code> or <code>edit(Name/Arity)</code> in the interpreter.</li>
</ul>
<h4 id="rebuilding"><span class="section_number">2.2.3</span><span class="section_title">Rebuilding</span></h4>
<p>To see the updated documentation, I click &quot;Make &amp; Reload&quot; button in my pldoc website, if I haven't done so. If I have clicked that button, I simply refresh my browser with F5 or Ctrl+R.</p>
<p>To test the program, I query <code>make.</code> in the interactive prompt, and I enter some queries.</p>
<p>Warnings are errors. If there is a warning, I go back to editing. &quot;Singleton variables&quot; most likely mean there's a typo.</p>
<h4 id="trying-and-manual-testing"><span class="section_number">2.2.4</span><span class="section_title">Trying and manual testing</span></h4>
<p>Important: <em>Prolog source file and Prolog query prompt have different syntax.</em> A Prolog source file contains <em>statements</em>. The Prolog interpreter accepts <em>queries</em>. Pasting a file into the interpreter does <em>not</em> load the file; this is contrary to Lisp/Python/Ruby interpreters.</p>
<p>The prompt <code>?-</code> means that the interpreter is expecting a <em>query</em>. However, we can enter temporary statements:</p>
<ul>
<li>Type the query <code>[user].</code>. The prompt changes to <code>|:</code>. We're now at the statement prompt. (The syntax <code>:- [foo].</code> is shorthand for <code>:- consult(foo).</code> which is documented in <a href="http://www.swi-prolog.org/pldoc/man?predicate=consult/1">consult/1</a>.)</li>
<li>Enter several lines of statements.</li>
<li>End with a new line and Control+D. We're now back at the query prompt.</li>
</ul>
<p>Those temporary statements disappear when the interpreter quits.</p>
<p>Usually, after trying my changes, I go back to thinking and editing.</p>
<h4 id="seeing-source-codes-and-finding-definitions"><span class="section_number">2.2.5</span><span class="section_title">Seeing source codes and finding definitions</span></h4>
<p>To show the canonical representation (properly-parenthesized tree form) of a term, query <code>write_canonical(Term)</code>.</p>
<p>To see the source code of a predicate, query <code>edit(Name)</code> or <code>edit(Name/Arity)</code> or <code>listing(Module:Name)</code> or <code>listing(Name)</code>. We can see the source code of libraries. We can easily find where things are defined.</p>
<h4 id="troubleshooting-tracing-and-spying"><span class="section_number">2.2.6</span><span class="section_title">Troubleshooting: tracing and spying</span></h4>
<p>Having to use the tracer means I have failed to design unsurprising programs. It means that my past self have failed to communicate to my future self.</p>
<p>Sometimes I query debug/0 to disable optimizations so that errors have full stack trace. Sometimes I need to restart the interpreter and query debug/0 before running my development web server. See also nodebug/0.</p>
<p>I start tracing a goal with the query <code>trace, Goal.</code> In the tracer prompt:</p>
<ul>
<li><code>a</code> aborts (calls abort/0; goes back to toplevel interpreter prompt)</li>
<li><code>c</code> creeps (&quot;step into&quot; in modern debugger parlance)</li>
<li><code>s</code> skips (&quot;step over&quot; in modern debugger parlance)</li>
<li><code>l</code> leaps (&quot;run&quot; in modern debugger parlance)</li>
<li>Type <code>/f</code> in the tracer prompt to run to the next failure.</li>
</ul>
<p>I stop tracing by notrace/0.</p>
<p>TODO spy/1, tspy/1</p>
<p>trace/0, gtrace/0, notrace/0</p>
<p>These resources say something about fixing programming errors:</p>
<ul>
<li><a href="https://www.cs.ucsb.edu/~kyledewey/cs162w15/debugging_prolog.html">https://www.cs.ucsb.edu/~kyledewey/cs162w15/debugging_prolog.html</a></li>
<li><a href="http://www.swi-prolog.org/pldoc/man?section=debugoverview">http://www.swi-prolog.org/pldoc/man?section=debugoverview</a></li>
<li><a href="https://www.metalevel.at/prolog/testing">https://www.metalevel.at/prolog/testing</a></li>
<li><a href="https://www.metalevel.at/prolog/debugging">https://www.metalevel.at/prolog/debugging</a></li>
</ul>
<h4 id="committing-to-a-git-repository"><span class="section_number">2.2.7</span><span class="section_title">Committing to a Git repository</span></h4>
<p>I commit my work to Git repository with Emacs Magit or git-gui. I sanity-check the tree with <code>gitk --all</code>. I push my work to my GitHub work repository.</p>
<h2 id="understanding-prolog"><span class="section_number">3</span><span class="section_title">Understanding Prolog</span></h2>
<p>There are several models (ways of understanding what a Prolog program does):</p>
<ul>
<li>procedural</li>
<li>database/relational</li>
<li>functional</li>
<li>logic</li>
</ul>
<p>The procedural way is what <em>actually</em> happens.</p>
<p>Sometimes an abstraction fails, and we have to know what is really going on under the abstraction.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.1</span><span class="section_title"><a href="#should-we-introduce-prolog-as-a-database-or-as-a-programming-language">Should we introduce Prolog as a database or as a programming language?</a></span><span class="word_count">(77w~1m)</span></li>
<li><span class="section_number">3.2</span><span class="section_title"><a href="#what-does-prolog-code-look-like-and-what-does-it-mean">What does Prolog code look like and what does it mean?</a></span><span class="word_count">(351w~2m)</span></li>
<li><span class="section_number">3.3</span><span class="section_title"><a href="#what-actually-happens-under-the-hood">What actually happens under the hood?</a></span><span class="word_count">(340w~2m)</span></li>
<li><span class="section_number">3.4</span><span class="section_title"><a href="#why-was-prolog-invented">Why was Prolog invented?</a></span><span class="word_count">(190w~1m)</span></li>
<li><span class="section_number">3.5</span><span class="section_title"><a href="#how-to-present-prolog-to-newcomers">&lt;2018-12-05&gt; How to present Prolog to newcomers</a></span><span class="word_count">(349w~2m)</span></li>
<li><span class="section_number">3.6</span><span class="section_title"><a href="#why-use-prolog-for-ai">Why use Prolog for AI?</a></span><span class="word_count">(9w~1m)</span></li>
<li><span class="section_number">3.7</span><span class="section_title"><a href="#prolog-as-database-programming-language">Prolog as database programming language</a></span><span class="word_count">(420w~3m)</span></li>
<li><span class="section_number">3.8</span><span class="section_title"><a href="#prolog-as-logic-programming-language">Prolog as logic programming language</a></span><span class="word_count">(458w~3m)</span></li>
<li><span class="section_number">3.9</span><span class="section_title"><a href="#prolog-as-procedural-programming-language">Prolog as procedural programming language</a></span><span class="word_count">(464w~3m)</span></li>
</ul>
</div>
<h3 id="should-we-introduce-prolog-as-a-database-or-as-a-programming-language"><span class="section_number">3.1</span><span class="section_title">Should we introduce Prolog as a database or as a programming language?</span></h3>
<p>Perhaps it helps to introduce Prolog as a deductive <em>database</em> instead of as a <em>programming</em> language.</p>
<p>The working of Prolog can be summarized this way:</p>
<ul>
<li>A database is a collection of Horn clauses.
<ul>
<li>A Horn clause is an implication whose antecedent is an atomic formula.</li>
</ul></li>
<li>To prove A <em>and</em> B, prove A <em>then</em> prove B. (Prolog operational semantics.)
<ul>
<li>The order of clauses matters. Prolog tries clauses in the order they appear.</li>
</ul></li>
</ul>
<h3 id="what-does-prolog-code-look-like-and-what-does-it-mean"><span class="section_number">3.2</span><span class="section_title">What does Prolog code look like and what does it mean?</span></h3>
<p>A Prolog program is a collection of Horn clauses?</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.2.1</span><span class="section_title"><a href="#reading-prolog-programs-and-a-crash-course-to-logic">Reading Prolog programs, and a crash course to logic</a></span><span class="word_count">(54w~1m)</span></li>
<li><span class="section_number">3.2.2</span><span class="section_title"><a href="#the-meanings-of-a-horn-clause">The meanings of a Horn clause</a></span><span class="word_count">(223w~2m)</span></li>
<li><span class="section_number">3.2.3</span><span class="section_title"><a href="#the-procedural-provability-logic-interpretation-of-prolog-horn-clauses">The procedural-provability-logic interpretation of Prolog Horn clauses</a></span><span class="word_count">(58w~1m)</span></li>
</ul>
</div>
<h4 id="reading-prolog-programs-and-a-crash-course-to-logic"><span class="section_number">3.2.1</span><span class="section_title">Reading Prolog programs, and a crash course to logic</span></h4>
<p>What is the meaning/interpretation of a Prolog program?</p>
<p>A <em>clause</em> has the shape <code>Head :- Body</code>.</p>
<p>Usually we begin with genealogy like Abraham's<a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a>. Family tree is actually not a tree but a directed graph: Families sometimes inbreed.</p>
<p>The words &quot;father&quot; and &quot;mother&quot; are to be interpreted as verbs here.</p>
<pre class="example"><code>father(abraham, isaac).
father(abraham, ishmael).
father(isaac, esau).
father(isaac, jacob).

mother(sarah, isaac).
mother(hagar, ishmael).
mother(rebecca, esau).
mother(rebecca, jacob).

parent(A, B) :- father(A,B) ; mother(A,B).
</code></pre>
<h4 id="the-meanings-of-a-horn-clause"><span class="section_number">3.2.2</span><span class="section_title">The meanings of a Horn clause</span></h4>
<p>A Horn clause in Prolog looks like <code>A :- B</code>.</p>
<p>A Horn clause can be thought of in several ways.</p>
<p>The operational meaning of <code>A :- B1, ..., Bn</code> is that calling the procedure A causes B1, …, Bn to be called in that order. This is the actual meaning of Prolog programs. All other meanings are useful fantasies.</p>
<p>The classical-logic reading of <code>A :- B</code> is <span class="math inline">\(A \leftarrow B\)</span>, that is, &quot;A is true if B is true&quot; or &quot;A is implied by B&quot;.</p>
<p>The proof-theoretic reading of <code>A :- B</code> is &quot;to prove <span class="math inline">\(A\)</span>, it is enough to prove <span class="math inline">\(B\)</span>&quot;.</p>
<p>The search-tree reading of <code>A :- B1, ..., Bn</code> is that the tree node A has the children B1, …, Bn.</p>
<p>These multiple readings are confusing. For example, the classical-logic reading implies that querying <code>a</code> against the following knowledge base should succeed because in classical logic <span class="math inline">\( A \leftarrow (B \wedge A) \equiv A \leftarrow B \)</span>, but the query <code>a</code> actually does not terminate.</p>
<pre class="example"><code>a :- b, a.
b.
</code></pre>
<p>In classical logic but not in Prolog, that knowledge base is equivalent to this:</p>
<pre class="example"><code>a :- b.
b.
</code></pre>
<p>Enhancing the declarativeness of Prolog requires <em>memoization</em>.</p>
<p>What is the relationship between logic programming, relational programming, logic, Horn clauses, theorem proving, searching, and backtracking?</p>
<p>If each phrase is deterministic (always succeeds exactly once and never fails), then Prolog becomes a procedural programming language with assign-once variables and unification.</p>
<h4 id="the-procedural-provability-logic-interpretation-of-prolog-horn-clauses"><span class="section_number">3.2.3</span><span class="section_title">The procedural-provability-logic interpretation of Prolog Horn clauses</span></h4>
<p><code>p :- q, r</code> can be interpreted as &quot;to prove p, first prove q, and then prove r&quot;.</p>
<ol>
<li><p>Problem: Horn clauses and biimplications</p>
<p>Classical propositional logic formula <span class="math inline">\( a \iff b \)</span> (which is equivalent to <span class="math inline">\((a \to b) \wedge (b \to a)\)</span>) does <em>not</em> translate to this Prolog program:</p>
<pre class="example"><code>a :- b.
b :- a.
</code></pre>
<p>Querying <code>?- a</code> does not terminate.</p>
<p>This terminates:</p>
<pre class="example"><code>% H is the hypothesis bag.

a(H) :- member(a,H).
a(H) :- \+ member(a,H), b(H).

b(H) :- member(b,H).
b(H) :- \+ member(b,H), a(H).
</code></pre></li>
</ol>
<h3 id="what-actually-happens-under-the-hood"><span class="section_number">3.3</span><span class="section_title">What actually happens under the hood?</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.3.1</span><span class="section_title"><a href="#prolog-is-a-depth-first-brute-forcer">Prolog is a depth-first brute-forcer</a></span><span class="word_count">(136w~1m)</span></li>
<li><span class="section_number">3.3.2</span><span class="section_title"><a href="#swapped-phrases-depth-first-breadth-first">Swapped phrases, depth-first, breadth-first?</a></span><span class="word_count">(30w~1m)</span></li>
<li><span class="section_number">3.3.3</span><span class="section_title"><a href="#understanding-depth-first-search-backtracking-choice-points-performance-and-cuts">Understanding depth-first search, backtracking, choice points, performance, and cuts</a></span><span class="word_count">(171w~1m)</span></li>
</ul>
</div>
<h4 id="prolog-is-a-depth-first-brute-forcer"><span class="section_number">3.3.1</span><span class="section_title">Prolog is a depth-first brute-forcer</span></h4>
<p>But you can emulate other search algorithms too.</p>
<ol>
<li><p>Non-termination pitfalls, and how to generate terms correctly</p>
<p>Sometimes we forget that Prolog, on failure, backtracks (retries), not stops.</p>
<p>Sometimes we focus too much on the logical reading and neglect the procedural reading.</p>
<p>For example, suppose that you want to generate all lists whose length doesn't exceed 2.</p>
<p>The following is a mathematically correct statement about that fact, but it doesn't work in Prolog. It has correct logical reading, but incorrect procedural reading. If you keep pressing <code>;</code>, this will fail to terminate.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb13-1" title="1"><span class="fu">?-</span> length(<span class="dt">A</span><span class="kw">,</span> <span class="dt">LA</span>)<span class="kw">,</span> <span class="dt">LA</span> <span class="dt">=&lt;</span> <span class="dv">2</span><span class="kw">.</span></a></code></pre></div>
<p>The correct way to do that is to use <code>between/3</code> (inclusive):</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb14-1" title="1"><span class="fu">?-</span> between(<span class="dv">0</span><span class="kw">,</span> <span class="dv">2</span><span class="kw">,</span> <span class="dt">LA</span>)<span class="kw">,</span> length(<span class="dt">A</span><span class="kw">,</span> <span class="dt">LA</span>)<span class="kw">.</span></a></code></pre></div>
<p>We can also use the <code>clpfd</code> library:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">:-</span> use_module(library(clpfd))<span class="kw">.</span></a>
<a class="sourceLine" id="cb15-2" title="2"></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="fu">?-</span> <span class="dt">LA</span> in <span class="dv">0</span>..<span class="dv">2</span><span class="kw">,</span> indomain(<span class="dt">LA</span>)<span class="kw">,</span> length(<span class="dt">A</span><span class="kw">,</span> <span class="dt">LA</span>)<span class="kw">.</span></a></code></pre></div>
<p>We shouldn't have to resort to cuts:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb16-1" title="1"><span class="co">% Don&#39;t do this.</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="fu">?-</span> length(<span class="dt">A</span><span class="kw">,</span> <span class="dt">LA</span>)<span class="kw">,</span> (<span class="dt">LA</span> <span class="dt">=&lt;</span> <span class="dv">2</span> <span class="kw">-&gt;</span> <span class="kw">true;</span> <span class="kw">!,</span> <span class="kw">fail</span>)<span class="kw">.</span></a></code></pre></div>
<p>See also:</p>
<ul>
<li><a href="https://www.metalevel.at/prolog/nontermination">https://www.metalevel.at/prolog/nontermination</a>
<ul>
<li>&quot;[Non-termination is] common among beginners, and often lead them to perceive Prolog as 'slow', when in fact their program does not terminate <em>at all</em>.&quot;</li>
</ul></li>
</ul></li>
</ol>
<h4 id="swapped-phrases-depth-first-breadth-first"><span class="section_number">3.3.2</span><span class="section_title">Swapped phrases, depth-first, breadth-first?</span></h4>
<p>In this example, there is only a small syntactic difference between <code>dfs</code> and <code>bfs</code> (it's just flipped order). Which one exploits tail call optimization (last call optimization)?</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb17-1" title="1">bit(<span class="dv">0</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb17-2" title="2">bit(<span class="dv">1</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb17-3" title="3"></a>
<a class="sourceLine" id="cb17-4" title="4">dfs([])<span class="kw">.</span></a>
<a class="sourceLine" id="cb17-5" title="5">dfs([<span class="dt">H</span><span class="fu">|</span><span class="dt">T</span>]) <span class="kw">:-</span> bit(<span class="dt">H</span>)<span class="kw">,</span> dfs(<span class="dt">T</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb17-6" title="6"></a>
<a class="sourceLine" id="cb17-7" title="7">bfs([])<span class="kw">.</span></a>
<a class="sourceLine" id="cb17-8" title="8">bfs([<span class="dt">H</span><span class="fu">|</span><span class="dt">T</span>]) <span class="kw">:-</span> bfs(<span class="dt">T</span>)<span class="kw">,</span> bit(<span class="dt">H</span>)<span class="kw">.</span></a></code></pre></div>
<h4 id="understanding-depth-first-search-backtracking-choice-points-performance-and-cuts"><span class="section_number">3.3.3</span><span class="section_title">Understanding depth-first search, backtracking, choice points, performance, and cuts</span></h4>
<p>Save this knowledge base into a file, and load it into Prolog.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb18-1" title="1">a(<span class="dv">0</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb18-2" title="2">a(<span class="dv">1</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4">b(<span class="dv">0</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb18-5" title="5">b(<span class="dv">1</span>)<span class="kw">.</span></a></code></pre></div>
<p>Run the query <code>a(A), b(B).</code> and press <code>;</code> until Prolog fails.</p>
<p>This is what Prolog finds (we remove the newlines to make it more readable):</p>
<pre class="example"><code>A = B, B = 0 ;
A = 0, B = 1 ;
A = 1, B = 0 ;
A = B, B = 1.
</code></pre>
<p>This is the search space (search tree) of that query.</p>
<pre class="example"><code>       ?- a(A), b(B).
      /              \
    A = 0           A = 1
   /     \         /     \
B = 0   B = 1   B = 0   B = 1
</code></pre>
<p>Prolog traverses that tree in depth-first order as follows:</p>
<pre class="example"><code>- ?- a(A), b(B).
  - A = 0
    - B = 0
    - B = 1
  - A = 1
    - B = 0
    - B = 1
</code></pre>
<p>The important things to infer from this experiment are:</p>
<ul>
<li>Prolog repeats the work on <code>b</code> as many times as the number of ways of satisfying <code>a</code>. If <code>a</code> can be satisfied in N ways, and satisfying <code>b</code> is a lot of work, then Prolog may do that work N times, although the work produces the same result.</li>
<li>Everything to the right of an infinite branch will never be visited.</li>
</ul>
<p>What is a choice point?</p>
<p>A cut makes <code>a(A), b(B)</code> and <code>b(B), a(A)</code> return different results.</p>
<p>How far does a cut cut?</p>
<p>&quot;The craft of Prolog&quot; defines three kinds of cuts: red, green, and blue.</p>
<ul>
<li>A red cut destroys the logical meaning of a program. Green and blue cuts don't.</li>
</ul>
<h3 id="why-was-prolog-invented"><span class="section_number">3.4</span><span class="section_title">Why was Prolog invented?</span></h3>
<p>If Prolog is the answer, what is the problem? The problem was the creation of natural-language user-interface. Colmerauer &amp; Roussel 1996 <span class="citation" data-cites="colmerauer1996birth">[<a href="#ref-colmerauer1996birth">6</a>]</span>: &quot;It can be said that Prolog was the offspring of a successful marriage between natural language processing and automated theorem-proving.&quot;</p>
<p>Philippe Roussel coined the name &quot;Prolog&quot; in Marseilles in 1972. <span class="citation" data-cites="colmerauer1996birth">[<a href="#ref-colmerauer1996birth">6</a>]</span></p>
<p>Robinson 1965 <span class="citation" data-cites="robinson1965machine">[<a href="#ref-robinson1965machine">24</a>]</span></p>
<p>The key idea of logic programming is the interpretation of a Horn clause as a procedure declaration (Kowalski 1974 <span class="citation" data-cites="kowalski1974predicate">[<a href="#ref-kowalski1974predicate">12</a>]</span>).</p>
<p>Logic seems to be the internal language of thought.</p>
<p>Elaborated in van Emden &amp; Kowalski 1976 <span class="citation" data-cites="van1976semantics">[<a href="#ref-van1976semantics">28</a>]</span>.</p>
<p>Predicate logic can be used both for programming and for knowledge representation.</p>
<p>What is &quot;refutation-complete&quot;<a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a>?</p>
<p><a href="http://www.prolog-heritage.org/en/ph1.html">http://www.prolog-heritage.org/en/ph1.html</a></p>
<p>SWI-Prolog goes back to 1986.<a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a></p>
<p>Did logic programming emerge from automated theorem proving? What is computational logic? What is automated reasoning?</p>
<p>Maarten van Emden has a blog<a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a>.</p>
<p>The relationship between Lisp and lambda calculus is superficial: van Emden<a href="#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a>) wrote that John McCarthy wrote (emphasis mine):</p>
<blockquote>
<p>To use functions as arguments, one needs a notation for functions, and it seemed natural to use the lambda notation of Church (1941). <em>I didn’t understand the rest of his book</em>, so I wasn’t tempted to try to implement his more general mechanism for defining functions.</p>
</blockquote>
<h3 id="how-to-present-prolog-to-newcomers"><span class="section_number">3.5</span><span class="section_title">&lt;2018-12-05&gt; How to present Prolog to newcomers</span></h3>
<p>This is a draft. These are slides. Assume that one section is one slide.</p>
<p>There are several ways to introduce Prolog:</p>
<ul>
<li>as a deductive database</li>
<li>as a logic programming language</li>
<li>as a procedural programming language with backtracking</li>
<li>as a natural language processing tool, which is its original reason of existence <span class="citation" data-cites="colmerauer1996birth">[<a href="#ref-colmerauer1996birth">6</a>]</span></li>
<li>as an artifical intelligence tool (what? automated reasoning?)</li>
</ul>
<p>It may be best to introduce Prolog as a deductive database. We want people to have understanding and good habit.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.5.1</span><span class="section_title"><a href="#talking-with-the-computer">&quot;Talking&quot; with the computer</a></span><span class="word_count">(144w~1m)</span></li>
<li><span class="section_number">3.5.2</span><span class="section_title"><a href="#write-once-run-in-several-directions">Write once, run in several directions</a></span><span class="word_count">(99w~1m)</span></li>
<li><span class="section_number">3.5.3</span><span class="section_title"><a href="#another-declarative-example-palindromes">Another declarative example: palindromes</a></span><span class="word_count">(15w~1m)</span></li>
<li><span class="section_number">3.5.4</span><span class="section_title"><a href="#learning-resources">Learning resources?</a></span><span class="word_count">(17w~1m)</span></li>
</ul>
</div>
<h4 id="talking-with-the-computer"><span class="section_number">3.5.1</span><span class="section_title">&quot;Talking&quot; with the computer</span></h4>
<p>We can think of an interactive Prolog session as a <em>conversation</em> with the computer.</p>
<p>The Prolog phrase &quot;append(A, B, C)&quot; means the English clause &quot;appending list A and list B produces list C&quot;.</p>
<p>Here we show some ways of calling append/3.</p>
<p>Here we show how to read Prolog fragments in English.</p>
<p>&quot;Prolog, does appending [1] and [2,3] produce [1,2,3]?&quot;</p>
<pre class="example"><code>?- append([1], [2,3], [1,2,3]).
true.
</code></pre>
<p>&quot;Prolog, what does appending [1] and [2,3] produce?&quot;</p>
<pre class="example"><code>?- append([1], [2,3], C).
C = [1,2,3].
</code></pre>
<p>&quot;Prolog, what list do I have to append to [1] in order to produce [1,2,3]?&quot;</p>
<pre class="example"><code>?- append([1], B, [1,2,3]).
B = [2,3].
</code></pre>
<p>&quot;Prolog, what list produces [1,2,3] when appended with [2,3]?&quot;</p>
<pre class="example"><code>?- append(A, [2,3], [1,2,3]).
A = [1] ;
false.
</code></pre>
<p>&quot;Prolog, does appending [1] and [2] produce [1,2,3]?&quot;</p>
<pre class="example"><code>?- append([1], [2], [1,2,3]).
false.
</code></pre>
<p>We press &quot;;&quot; to ask Prolog to find another solution. Prolog prints &quot;false&quot; when it doesn't find any more solutions.</p>
<p>&quot;Prolog, what list produces [1] when appended with itself?&quot;</p>
<pre class="example"><code>?- append(A, A, [1]).
false.
</code></pre>
<p>&quot;Prolog, what list produces [1,2,1,2] when appended with itself?&quot;</p>
<p>&quot;[1,2].&quot;</p>
<p>&quot;Is there any other such list?&quot;</p>
<p>&quot;No.&quot;</p>
<pre class="example"><code>?- append(A, A, [1,2,1,2]).
A = [1,2] ;
false.
</code></pre>
<p>&quot;Prolog, what two lists A and B produce [1,2,3] when appended?&quot;</p>
<pre class="example"><code>append(A, B, [1,2,3]).
A = [], B = [1,2,3] ;
A = [1], B = [2,3] ;
A = [1,2], B = [3] ;
A = [1,2,3], B = [] ;
false.
</code></pre>
<h4 id="write-once-run-in-several-directions"><span class="section_number">3.5.2</span><span class="section_title">Write once, run in several directions</span></h4>
<p>The Prolog code for append/3 seems simple. We can see in SWI-Prolog library/lists.pl <a href="http://www.swi-prolog.org/pldoc/doc/_SWI_/library/lists.pl?show=src#append/3">append/3</a> (I renamed some variables):</p>
<pre class="example"><code>append([], B, B).
append([H|A], B, [H|C]) :- append(A, B, C).
</code></pre>
<p>Haskell seems simpler:</p>
<pre class="example"><code>append [] b = b
append (h : a) b = h : append a b
</code></pre>
<p>But those fragments differ. In Prolog we can run the code in other <em>directions</em>. There are 3 parameters, each with two directions (input/bound or output/unbound); thus there are 2^3 = 8 possible directions. The Prolog predicate translates to at least 5 Haskell functions, for the 5 ways of using append/3 we saw earlier.</p>
<p>We write append/3 once, and we get at least five ways of calling it.</p>
<p>But this beautiful dream crumbles outside pure symbolic logic programming.</p>
<h4 id="another-declarative-example-palindromes"><span class="section_number">3.5.3</span><span class="section_title">Another declarative example: palindromes</span></h4>
<p>&quot;A list L is a palindrome iff L is its own reverse.&quot;</p>
<pre class="example"><code>palindrome(L) :- reverse(L, L).
</code></pre>
<h4 id="learning-resources"><span class="section_number">3.5.4</span><span class="section_title">Learning resources?</span></h4>
<p>2015 Approaches for Learning Prolog Programming <a href="https://www.tandfonline.com/doi/full/10.11120/ital.2007.06040088">https://www.tandfonline.com/doi/full/10.11120/ital.2007.06040088</a></p>
<p><a href="http://kti.ms.mff.cuni.cz/~bartak/prolog/index.html">Roman Barták's &quot;On-line Guide to Prolog Programming&quot;</a></p>
<p><a href="https://www.cis.upenn.edu/~matuszek/Concise%20Guides/Concise%20Prolog.html">https://www.cis.upenn.edu/~matuszek/Concise%20Guides/Concise%20Prolog.html</a></p>
<p>display/1 vs write_canonical/2? <a href="https://swi-prolog.discourse.group/t/re-swipl-re-pedagogy/48/10">https://swi-prolog.discourse.group/t/re-swipl-re-pedagogy/48/10</a></p>
<h3 id="why-use-prolog-for-ai"><span class="section_number">3.6</span><span class="section_title">Why use Prolog for AI?</span></h3>
<p>Because Prolog produces <em>explainable</em> AI.</p>
<h3 id="prolog-as-database-programming-language"><span class="section_number">3.7</span><span class="section_title">Prolog as database programming language</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.7.1</span><span class="section_title"><a href="#prolog-and-ontology">Prolog and ontology</a></span><span class="word_count">(44w~1m)</span></li>
<li><span class="section_number">3.7.2</span><span class="section_title"><a href="#pure-relation-built-from-impure-parts">&quot;Pure&quot; relation built from impure parts</a></span><span class="word_count">(39w~1m)</span></li>
<li><span class="section_number">3.7.3</span><span class="section_title"><a href="#knowledge-representation-designing-predicates-naming-is-hard">Knowledge representation; designing predicates; naming is hard</a></span><span class="word_count">(156w~1m)</span></li>
<li><span class="section_number">3.7.4</span><span class="section_title"><a href="#knowledge-representation-and-software-specification">Knowledge representation and software specification</a></span><span class="word_count">(54w~1m)</span></li>
<li><span class="section_number">3.7.5</span><span class="section_title"><a href="#total-relational-programming-relational-programs-that-can-be-proven-to-terminate">Total relational programming? Relational programs that can be proven to terminate?</a></span><span class="word_count">(48w~1m)</span></li>
<li><span class="section_number">3.7.6</span><span class="section_title"><a href="#the-meaning-of-a-pure-prolog-predicate">The meaning of a pure Prolog predicate</a></span><span class="word_count">(80w~1m)</span></li>
</ul>
</div>
<h4 id="prolog-and-ontology"><span class="section_number">3.7.1</span><span class="section_title">Prolog and ontology</span></h4>
<p>Writing a Prolog knowledge base is an exercise in ontology (a branch of philosophy, that studies beings and relationships). We ask these all the time:</p>
<ul>
<li>What exist?</li>
<li>How do they relate?</li>
<li>How do we model all those entities and relationships in Prolog for not-too-slow computation?</li>
</ul>
<h4 id="pure-relation-built-from-impure-parts"><span class="section_number">3.7.2</span><span class="section_title">&quot;Pure&quot; relation built from impure parts</span></h4>
<p>We can define a truly relational plus/3 that works for all mode combinations for natural numbers, but the code seems too much and illogical.</p>
<pre class="example"><code>nat(A) :- integer(A), A &gt;= 0.

plus(A, B, C) :- nat(A), nat(B), nat(C), !, C =:= A + B.
plus(A, B, C) :- nat(A), nat(B), !, C is A+B.
plus(A, B, C) :- nat(A), nat(C), !, B is C-A.
plus(A, B, C) :- nat(B), nat(C), !, A is C-B.
plus(A, B, C) :- nat(A), !, between(0, inf, C), plus(A, B, C).
plus(A, B, C) :- nat(B), !, between(0, inf, C), plus(A, B, C).
plus(A, B, C) :- nat(C), !, between(0, C, A), plus(A, B, C).
plus(A, B, C) :- between(0, inf, C), plus(A, B, C).
</code></pre>
<p>We can write that shorter in miniKanren which uses iterative-deepening search?</p>
<h4 id="knowledge-representation-designing-predicates-naming-is-hard"><span class="section_number">3.7.3</span><span class="section_title">Knowledge representation; designing predicates; naming is hard</span></h4>
<p>One possible mapping is:</p>
<ul>
<li>a noun maps to a term</li>
<li>a verb maps to a predicate</li>
</ul>
<p>Come to think of it, a transitive verb indeed denotes a relation between two nouns.</p>
<p>The name of a predicate is less important than its mapping and its meaning.</p>
<pre class="example"><code>father(abraham, isaac).
beget(abraham, issac).
papa(abraham, issac).
spawn(abraham, issac).
mystery_predicate(abraham, issac).
</code></pre>
<p>&quot;A bird eats an apple&quot; means <span class="math inline">\( \exists x \exists y ( bird(x) \wedge apple(y) \wedge eat(x,y) ) \)</span>.</p>
<p>The name of a relation should describe the relationship.</p>
<p>If we intend that there is only one relation between A and B that makes sense, then we may name that relation A_B. But:</p>
<ul>
<li>What if A or B contains underscores?</li>
<li>Why do we prefer <code>father_child</code> to <code>beget</code> or <code>sire</code>?</li>
</ul>
<p>is_thing(A).</p>
<p>A procedure's name should begin with a verb.</p>
<p>Order the parameters from the most likely to be bound. If parameter A is more likely to be more bound than parameter B, then A should come before B. Example: Write list_length/2 instead of length_list/2. Unfortunately not everyone follows this convention.</p>
<h4 id="knowledge-representation-and-software-specification"><span class="section_number">3.7.4</span><span class="section_title">Knowledge representation and software specification</span></h4>
<ol>
<li><p>Their relationships</p>
<ul>
<li>2010, &quot;Functional-Logic Programming Lecture Notes&quot;, Harold Boley, slides, <a href="http://www.cs.unb.ca/~boley/FLP/cs6905FLP.pdf">pdf</a>
<ul>
<li>Knowledge representation in AI roughly corresponds to software specification in software engineering.</li>
<li>Declarative programs can be thought of as executable specifications.</li>
<li>Invertibility principle (slide 36)</li>
<li>Nesting/conjunction principle (slide 46)</li>
<li>Unification principle (slide 50)</li>
<li>Amalgamation/integration principle (slide 55)</li>
<li>That's a long deck: 270 slides.</li>
</ul></li>
</ul></li>
<li><p>Executable specification?</p>
<ul>
<li>lightweight executable mathematics <a href="https://www.cl.cam.ac.uk/~pes20/lem/">https://www.cl.cam.ac.uk/~pes20/lem/</a></li>
</ul></li>
</ol>
<h4 id="total-relational-programming-relational-programs-that-can-be-proven-to-terminate"><span class="section_number">3.7.5</span><span class="section_title">Total relational programming? Relational programs that can be proven to terminate?</span></h4>
<p>A total relation is a relation that is defined for every element in its domain.</p>
<p>If there is total functional programming, then there should be total relational programming.</p>
<p>It is too easy to write a Prolog program that doesn't terminate.</p>
<h4 id="the-meaning-of-a-pure-prolog-predicate"><span class="section_number">3.7.6</span><span class="section_title">The meaning of a pure Prolog predicate</span></h4>
<p>The meaning of a predicate is the set of all ground terms that satisfy that predicate. Formally, the meaning of the predicate <span class="math inline">\(p\)</span> is the set <span class="math inline">\( \SetBuilder{x}{p(x)} \)</span>. Such set is called the <em>extension</em><a href="#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a> of the predicate.</p>
<p>In this example, what is the meaning of t/2 supposed to be? Declaratively, the query <code>?- t(A,B)</code> means the finite set <code>{(1,1)}</code>, and thus the query should terminate. But with SLD-resolution operational semantics, the query does not terminate.</p>
<pre class="example"><code>e(1,1).

t(A,B) :- e(A,M), t(M,B).
</code></pre>
<h3 id="prolog-as-logic-programming-language"><span class="section_number">3.8</span><span class="section_title">Prolog as logic programming language</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.8.1</span><span class="section_title"><a href="#multi-directional-predicates">Multi-directional predicates</a></span><span class="word_count">(81w~1m)</span></li>
<li><span class="section_number">3.8.2</span><span class="section_title"><a href="#functional-deterministic-relation">Functional (deterministic) relation</a></span><span class="word_count">(3w~1m)</span></li>
<li><span class="section_number">3.8.3</span><span class="section_title"><a href="#how-to-read-declarative-prolog-programs">How to read declarative Prolog programs</a></span><span class="word_count">(186w~1m)</span></li>
<li><span class="section_number">3.8.4</span><span class="section_title"><a href="#epistemic-interpretation-of-prolog-programs-failure-as-ignorance">Epistemic interpretation of Prolog programs: Failure as ignorance</a></span><span class="word_count">(159w~1m)</span></li>
<li><span class="section_number">3.8.5</span><span class="section_title"><a href="#naming-the-parts-of-a-list-head-tail-and-butt">Naming the parts of a list: head, tail, and butt</a></span><span class="word_count">(23w~1m)</span></li>
<li><span class="section_number">3.8.6</span><span class="section_title"><a href="#defining-your-own-operators">Defining your own operators</a></span><span class="word_count">(7w~1m)</span></li>
</ul>
</div>
<h4 id="multi-directional-predicates"><span class="section_number">3.8.1</span><span class="section_title">Multi-directional predicates</span></h4>
<p>A predicate has several uses: iteration, searching, testing, and other computation. A predicate can be used both to enumerate/iterate a finite set, to search for a satisfier, and to test membership.</p>
<pre class="example"><code>person(alice).
person(bob).

?- person(charlie). % test membership
?- once(person(A)). % satisfy
?- person(A), !. % satisfy
?- person(A). % iterate
</code></pre>
<p>A predicate can be used both to enumerate some infinite sets and to test membership. The programmer is reponsible to ensure that the recursion terminates.</p>
<pre class="example"><code>nat(z).
nat(s(A)) :- nat(A).
</code></pre>
<pre class="example"><code>succ(A, s(A)).

succ(A, s(A)) :- nat(A).
</code></pre>
<p>For non-pure Prolog programs, we have to do some repetition if we want a multi-directional relation.</p>
<pre class="example"><code>succ(A, B) :- integer(A), !, B is A+1.
succ(A, B) :- integer(B), !, A is B-1.
succ(A, B) :- !, type_error(succ, succ(A,B)).
</code></pre>
<p>But that can be done more elegantly with <em>constraint logic programming</em>.</p>
<pre class="example"><code>succ(A, B) :- A + 1 #= B.
</code></pre>
<h4 id="functional-deterministic-relation"><span class="section_number">3.8.2</span><span class="section_title">Functional (deterministic) relation</span></h4>
<pre class="example"><code>f(In1, Out1) :- Guard1, !, Body1.
...
f(InN, OutN) :- GuardN, !, BodyN.
f(In, _) :- !, type_error(Type, In).
</code></pre>
<h4 id="how-to-read-declarative-prolog-programs"><span class="section_number">3.8.3</span><span class="section_title">How to read declarative Prolog programs</span></h4>
<p>A <em>Horn clause</em> <code>A :- B</code> means &quot;to prove A, prove B&quot;. The left-arrow <code>:-</code> can be read as &quot;if&quot;.</p>
<pre class="example"><code>wet :- rain.
wet :- sprinkle.

% The same.

wet :- rain ; sprinkle.
</code></pre>
<p>The conjunction <code>A,B</code> means prove A <em>and then</em> prove B. Prolog proves them in sequence.</p>
<p>Example: The fire triangle<a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a>:</p>
<pre class="example"><code>% A line comment begins with a percent sign.

fire :- oxygen, heat, fuel.

oxygen.
heat.
</code></pre>
<p>Prolog complains about undefined predicate fuel/0.</p>
<p>An alternative in which Prolog does not complain about undefined predicates:</p>
<pre class="example"><code>known(oxygen).
known(heat).
known(fire) :- known((oxygen,heat,fuel)).
known((A,B)) :- known(A), known(B).
</code></pre>
<p>We have just defined a small <em>world</em>, a small <em>ontology</em>. (Is this too fast-paced for beginners?)</p>
<p>The disjunction <code>A;B</code> means prove A <em>or</em> prove B. If A fails, Prolog backtracks and tries to prove B.</p>
<p>Non-variables in clause head abbreviate unification. For example, <code>p(a,b) :- Q</code> abbreviates <code>p(A,B) :- A=a, B=b, Q</code>.</p>
<p><code>A :- B</code> is pure iff all reordering of the phrases of B doesn't change the result?</p>
<p><code>\+A</code> means &quot;fail to prove A&quot;. It is not classical-logical negation.</p>
<p>Every variable is implicitly universally quantified.</p>
<p>The prompt <code>?- Q</code> means we ask Prolog to prove <code>Q</code>.</p>
<p>Perhaps elucidating <a href="https://en.wikipedia.org/wiki/Prolog_syntax_and_semantics">https://en.wikipedia.org/wiki/Prolog_syntax_and_semantics</a></p>
<p>We often define a set <span class="math inline">\(A\)</span> with the set-builder notation <span class="math inline">\( \SetBuilder{x}{\phi_A(x)} \)</span>. We should not conflate a set <span class="math inline">\(A\)</span> and its membership-testing predicate <span class="math inline">\(\phi_A\)</span>.</p>
<p>A set can be thought of as all the ground terms that satisfy a predicate.</p>
<pre class="example"><code>% person ~ {joe}
person(joe).

% natural ~ {0, 1, 2, ...}
natural(N) :- integer(N), N &gt;= 0.
</code></pre>
<h4 id="epistemic-interpretation-of-prolog-programs-failure-as-ignorance"><span class="section_number">3.8.4</span><span class="section_title">Epistemic interpretation of Prolog programs: Failure as ignorance</span></h4>
<p>Sometimes a Prolog program should be interpreted epistemically, in which Prolog's <em>fail</em> is treated as <em>unknown</em> instead of <em>false</em>. In this interpretation:</p>
<ul>
<li>Succeeding to prove a goal G means that we know that G is true.</li>
<li>Failing to prove a goal G means that we do not know anything about G.</li>
</ul>
<p>There are two negations: There is a difference between not/1 and \+/1. In the epistemic interpretation, &quot;\+&quot; should be read as &quot;unknown&quot;.</p>
<p><code>\+G</code> means we do not know G.</p>
<p>Succeeding to prove not(G) means that we know that G is false.</p>
<pre class="example"><code>:- multifile not/1.
</code></pre>
<p>We waive the law of excluded middle. In our Prolog program it does not hold that G ; not(G).</p>
<p>Suppose is_big(john). If is_big(X) fails, it simply means that we don't know whether X is big.</p>
<p>Suppose that is_big(john,true) means we know that John is big. And is_big(john,false) means we know that John is not big. If is_big(john,_) fails, then we don't know whether John is big or not.</p>
<h4 id="naming-the-parts-of-a-list-head-tail-and-butt"><span class="section_number">3.8.5</span><span class="section_title">Naming the parts of a list: head, tail, and butt</span></h4>
<ul>
<li>&quot;head&quot; is the first element</li>
<li>&quot;tail&quot; is everything but the head</li>
<li>&quot;butt&quot; is the last element</li>
</ul>
<h4 id="defining-your-own-operators"><span class="section_number">3.8.6</span><span class="section_title">Defining your own operators</span></h4>
<ul>
<li><code>:- op(Precedence, Type, Name)</code></li>
</ul>
<h3 id="prolog-as-procedural-programming-language"><span class="section_number">3.9</span><span class="section_title">Prolog as procedural programming language</span></h3>
<p>Some ugly things are unfortunately necessary. There are always some dirty jobs in real-world programming. Example dirty jobs are input-output and error handling.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.9.1</span><span class="section_title"><a href="#cuts">Cuts</a></span><span class="word_count">(9w~1m)</span></li>
<li><span class="section_number">3.9.2</span><span class="section_title"><a href="#speeding-things-up">Speeding things up</a></span><span class="word_count">(43w~1m)</span></li>
<li><span class="section_number">3.9.3</span><span class="section_title"><a href="#functionalexpression-style-sometimes-beats-relationalunification-style">Functional/expression style sometimes beats relational/unification style</a></span><span class="word_count">(93w~1m)</span></li>
<li><span class="section_number">3.9.4</span><span class="section_title"><a href="#operators-complicate-parsing-a-prolog-source-code">Operators complicate parsing a Prolog source code</a></span><span class="word_count">(7w~1m)</span></li>
<li><span class="section_number">3.9.5</span><span class="section_title"><a href="#zero-arity-compound-term">Zero-arity compound term</a></span><span class="word_count">(134w~1m)</span></li>
<li><span class="section_number">3.9.6</span><span class="section_title"><a href="#some-prolog-negation-tricks">Some Prolog negation tricks?</a></span><span class="word_count">(62w~1m)</span></li>
<li><span class="section_number">3.9.7</span><span class="section_title"><a href="#purifying-prolog">Purifying Prolog?</a></span><span class="word_count">(11w~1m)</span></li>
<li><span class="section_number">3.9.8</span><span class="section_title"><a href="#states-and-dynamic-predicates">States and dynamic predicates</a></span><span class="word_count">(86w~1m)</span></li>
</ul>
</div>
<h4 id="cuts"><span class="section_number">3.9.1</span><span class="section_title">Cuts</span></h4>
<ul>
<li>slide 5-28, pitfalls in implementing abs with cut <a href="http://users.informatik.uni-halle.de/~brass/lp06/c5_propr.pdf">http://users.informatik.uni-halle.de/~brass/lp06/c5_propr.pdf</a></li>
</ul>
<h4 id="speeding-things-up"><span class="section_number">3.9.2</span><span class="section_title">Speeding things up</span></h4>
<p>The first thing to do is to get an unbiased profiler.</p>
<p>(Is SWI-Prolog profiler unbiased?)</p>
<p>Profiling: finding where your program spends time; finding where it is slow; diagnosing slowness</p>
<p>To run your <code>Goal</code> with profiling, simply query <code>profile(Goal)</code>.</p>
<p>Profiling couldn't be any simpler than this!</p>
<h4 id="functionalexpression-style-sometimes-beats-relationalunification-style"><span class="section_number">3.9.3</span><span class="section_title">Functional/expression style sometimes beats relational/unification style</span></h4>
<pre class="example"><code>-- Functional/expression style
g (f0 x0) (f1 x1) (f2 x2)

% Relational/unification style
f0(X0, Y0), f1(X1, Y1), f2(X2, Y2), g(Y0, Y1, Y2, Z).
</code></pre>
<p>Example where functional style wins:</p>
<ul>
<li>string formatting</li>
<li>number crunching</li>
</ul>
<p>If backtracking isn't involved, functional style wins (is more concise than relational style).</p>
<p>If computation is reversible, relational style wins (half the amount of code of functional style).</p>
<p>We should use both styles depending on circumstances.</p>
<p>We can define a functional/expression/applicative/evaluative sublanguage in Prolog, roughly like this:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb48-1" title="1">eval((<span class="dt">A</span> <span class="kw">=</span> <span class="dt">B</span>)<span class="kw">,</span> <span class="dt">Val</span>) <span class="kw">:-</span> <span class="dt">A</span> <span class="kw">=</span> <span class="dt">B</span><span class="kw">,</span> eval(<span class="dt">B</span><span class="kw">,</span> <span class="dt">Val</span>)<span class="kw">,</span> <span class="kw">!.</span></a>
<a class="sourceLine" id="cb48-2" title="2">eval(<span class="dt">F</span><span class="kw">,</span> <span class="dt">Val</span>) <span class="kw">:-</span> <span class="dt">callable</span>(<span class="dt">F</span>)<span class="kw">,</span> <span class="kw">call</span>(<span class="dt">F</span><span class="kw">,</span> <span class="dt">Val</span>)<span class="kw">,</span> <span class="kw">!.</span> <span class="co">% lots of hand-waving here</span></a>
<a class="sourceLine" id="cb48-3" title="3"><span class="co">% etc.</span></a></code></pre></div>
<p>Haskell is weak against the AST decoration problem. Dynamic languages (Scheme, JavaScript, Prolog) / gradual-typed languages (TypeScript) beat static languages (Haskell) on the AST decoration problem. How about Ocaml polymorphic variants?</p>
<p>Should we move from Prolog to Scheme/miniKanren or Mercury?</p>
<h4 id="operators-complicate-parsing-a-prolog-source-code"><span class="section_number">3.9.4</span><span class="section_title">Operators complicate parsing a Prolog source code</span></h4>
<h4 id="zero-arity-compound-term"><span class="section_number">3.9.5</span><span class="section_title">Zero-arity compound term</span></h4>
<p>SWI-Prolog extension compound_name_arity/3 vs ISO standard functor/3.<a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a></p>
<ul>
<li>A function symbol with arity 2 looks like f(x,y).</li>
<li>A function symbol with arity 1 looks like f(x).</li>
<li>A function symbol with arity 0 should look like f().</li>
</ul>
<p>Thus, indeed, SWI-Prolog's extension is the logical way, but unfortunately we are stuck for historical reasons. This makes sense if we are coming from mathematics, in which it is common to conflate constants and 0-ary function symbols. The formal logic literature conflates f() and f.</p>
<p>Problem arises when we want to distinguish between the x that is a variable reference and the x() that is a procedure call. We can introduce additional abstract syntax to wrap and disambiguate them: var(x) and call(x,[]).</p>
<p>It is embarrassing that we have known zero for at least 2,000 years and yet we still have problems with zero.</p>
<h4 id="some-prolog-negation-tricks"><span class="section_number">3.9.6</span><span class="section_title">Some Prolog negation tricks?</span></h4>
<p>Prolog <code>\+</code> can be used to limit the scope of unification, although not the scope of the variable itself. This exploits the fact that throw/1 does not backtrack in the way fail/0 does.</p>
<p>When using Prolog procedurally, we often want throw/1 instead of fail/0.</p>
<p>It makes more sense to design a procedural DSL on Prolog than to use Prolog itself procedurally.</p>
<h4 id="purifying-prolog"><span class="section_number">3.9.7</span><span class="section_title">Purifying Prolog?</span></h4>
<ul>
<li>assert/2 can be replaced with two parameters (state and next-state).</li>
</ul>
<h4 id="states-and-dynamic-predicates"><span class="section_number">3.9.8</span><span class="section_title">States and dynamic predicates</span></h4>
<p>Suppose that we want to write SQL connection pool. We need state. How do we write states in Prolog? Dynamic predicates is one way of having states in Prolog. The other is threading two extra state variables in each predicate that uses the state. But this time purism seems to lose. In the case of writing connection pools, procedural programming seems to be the paradigm that produces the most concise and understandable code.</p>
<p>A stateless system is of limited use: They can't store data!</p>
<h2 id="graphical-user-interface-programming"><span class="section_number">4</span><span class="section_title">Graphical-user-interface programming</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">4.1</span><span class="section_title"><a href="#what-are-the-options">&lt;2019-04-02&gt; What are the options?</a></span><span class="word_count">(143w~1m)</span></li>
<li><span class="section_number">4.2</span><span class="section_title"><a href="#selecting-a-gui-library">Selecting a GUI library?</a></span><span class="word_count">(107w~1m)</span></li>
<li><span class="section_number">4.3</span><span class="section_title"><a href="#enlarge-the-fonts">Enlarge the fonts</a></span><span class="word_count">(62w~1m)</span></li>
<li><span class="section_number">4.4</span><span class="section_title"><a href="#saving-pcexpce-by-porting-it-as-much-as-possible-to-pure-prolog">Saving PCE/XPCE by porting it as much as possible to pure Prolog?</a></span><span class="word_count">(116w~1m)</span></li>
<li><span class="section_number">4.5</span><span class="section_title"><a href="#declarative-gui">Declarative GUI?</a></span><span class="word_count">(24w~1m)</span></li>
<li><span class="section_number">4.6</span><span class="section_title"><a href="#using-swi-prolog-plgi-pack">Using SWI-Prolog plgi pack</a></span><span class="word_count">(7w~1m)</span></li>
</ul>
</div>
<h3 id="what-are-the-options"><span class="section_number">4.1</span><span class="section_title">&lt;2019-04-02&gt; What are the options?</span></h3>
<p>There are two options for doing GUI in SWI-Prolog:</p>
<ul>
<li>PCE: an abstraction layer like GNOME from the 1990s</li>
<li>plgi<a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a>: a SWI-Prolog pack containing bindings to Gtk</li>
</ul>
<p>The future of XPCE is uncertain, but all the SWI-Prolog IDE components use it.<a href="#fn29" class="footnote-ref" id="fnref29"><sup>29</sup></a> It works; it's just not shiny. Design sensibilities have changed due to new hardware.</p>
<p>PCE is an abstraction layer like GNOME. It has an object system like GObject, a drawing-primitive system like Gdk, and GUI toolkit like Gtk.</p>
<p>PCE is written in C.</p>
<p>XPCE is PCE + SWI-Prolog bindings.</p>
<pre class="example"><code>:- use_module(library(pce),[
    new/2
    , free/1
    , get/3
    , send/2
]).
:- use_module(library(pce_util),[
    send_list/3
]).
</code></pre>
<p>The predicates are:</p>
<ul>
<li>new(-Object, +Class) is det.</li>
<li>free(+Object) is det.</li>
<li>send(+Object, +MessageExp) is det.</li>
<li>get(+Object, +MessageExp, -Result) is det.</li>
</ul>
<p>A convenience predicate:</p>
<ul>
<li>send_list(+Object, +Slot, +Args) is det.</li>
</ul>
<p>XPCE <em>object expression</em> (message expression?) syntax is documented in XPCE User Guide section 10.2 (&quot;Executable objects&quot;)<a href="#fn30" class="footnote-ref" id="fnref30"><sup>30</sup></a>:</p>
<ul>
<li><code>@Name</code> global object</li>
<li><code>A ? B</code> obtainer (&quot;getter&quot; in Java parlance)</li>
</ul>
<p>PCE is similar to C Gtk or Java Swing. They are all object-oriented.</p>
<h3 id="selecting-a-gui-library"><span class="section_number">4.2</span><span class="section_title">Selecting a GUI library?</span></h3>
<p>Is GTK 3 here to stay? Is GIR (Gnome Introspection) here to stay? Is everyone switching from GTK to Qt?<a href="#fn31" class="footnote-ref" id="fnref31"><sup>31</sup></a></p>
<p>Why do everyone hate GTK?<a href="#fn32" class="footnote-ref" id="fnref32"><sup>32</sup></a> From a deleted user: &quot;GTK is no longer an independent toolkit, it's built by Gnome developers, for Gnome developers. They change the API in every single new release, which breaks third-party applications, extensions and themes. They don't care about other projects and developers.&quot;</p>
<p>That is fatal. That is a deal-breaker for me. I want my software to work forever.</p>
<p>Qt uses C++, and C++ turns me off, but some people say that Qt is more stable and C++ is a mature language.</p>
<h3 id="enlarge-the-fonts"><span class="section_number">4.3</span><span class="section_title">Enlarge the fonts</span></h3>
<p>XPCE was made in the 1990s when 800x600 screens were common. In 2019, 1920x1080 screens are common.</p>
<p>The easiest way to set up the XPCE Defaults file is by PceEmacs.</p>
<pre class="example"><code>?- emacs.
</code></pre>
<p>Edit &gt; Editor preferences</p>
<p>Increment each number in &quot;display.system_fonts&quot; chain by 2 (thus replace 12 with 14, replace 13 with 15, and so on).</p>
<p>Save the file, exit PceEmacs, and restart the Prolog interpreter.</p>
<h3 id="saving-pcexpce-by-porting-it-as-much-as-possible-to-pure-prolog"><span class="section_number">4.4</span><span class="section_title">Saving PCE/XPCE by porting it as much as possible to pure Prolog?</span></h3>
<p>PCE/XPCE is surprisingly modern? PCE <code>catch_all</code> is Ruby method_missing. But perhaps this is not surprising because both PCE and Ruby take something from Smalltalk, directly or indirectly.</p>
<p>Need to be done:</p>
<ul>
<li>Write a shorter user guide. Write about the things that the user really needs to care about. People are impatient. Life is short.</li>
<li>Integrate XPCE documentation system and PlDoc documentation system.</li>
<li>Make manpce use one frame instead of many frames. Compare GIMP before single-window layout.</li>
</ul>
<p>Nice to have?</p>
<ul>
<li>Rewrite the C parts in ISO Prolog.</li>
<li>Build on GTK.</li>
</ul>
<p>One problem is that PCE is not Prolog-only. In principle, PCE may also be used with any host language, such as Lisp and C.</p>
<h3 id="declarative-gui"><span class="section_number">4.5</span><span class="section_title">Declarative GUI?</span></h3>
<p>It is easy to model the <em>static</em> structure of a GUI:</p>
<pre class="example"><code>window(main).
textbox(a).
textbox(b).
textbox(c).
contain(main,a).
contain(main,b).
contain(main,c).
</code></pre>
<p>It is harder to model the <em>dynamic</em> behavior of a GUI.</p>
<pre class="example"><code>textbox_text(c,C) :-
    textbox_text(a,A),
    textbox_text(b,B),
    string_concat(A,B,C).
</code></pre>
<pre class="example"><code>constraint(text(c) = text(a) + text(b)).
</code></pre>
<p>Logical reactive programming?</p>
<h3 id="using-swi-prolog-plgi-pack"><span class="section_number">4.6</span><span class="section_title">Using SWI-Prolog plgi pack</span></h3>
<p>Before building on Debian/Ubuntu:</p>
<pre class="example"><code>sudo apt-get install libgirepository1.0-dev
</code></pre>
<h2 id="maintaining-large-knowledge-bases"><span class="section_number">5</span><span class="section_title">Maintaining large knowledge bases</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">5.1</span><span class="section_title"><a href="#a-suggested-way-to-use-prolog-for-programming-in-the-large">A suggested way to use Prolog for programming in the large?</a></span><span class="word_count">(45w~1m)</span></li>
<li><span class="section_number">5.2</span><span class="section_title"><a href="#disciplines-for-writing-large-maintainable-prolog-knowledge-bases">Disciplines for writing large maintainable Prolog knowledge bases</a></span><span class="word_count">(33w~1m)</span></li>
<li><span class="section_number">5.3</span><span class="section_title"><a href="#writing-extensible-knowledge-bases">Writing extensible knowledge bases</a></span><span class="word_count">(16w~1m)</span></li>
<li><span class="section_number">5.4</span><span class="section_title"><a href="#production-prolog">Production Prolog</a></span><span class="word_count">(29w~1m)</span></li>
<li><span class="section_number">5.5</span><span class="section_title"><a href="#testing">Testing</a></span><span class="word_count">(14w~1m)</span></li>
<li><span class="section_number">5.6</span><span class="section_title"><a href="#why-do-we-need-predicates-at-all-if-we-can-do-with-one-unary-predicate">Why do we need predicates at all if we can do with one unary predicate?</a></span><span class="word_count">(177w~1m)</span></li>
<li><span class="section_number">5.7</span><span class="section_title"><a href="#documentation-system">Documentation system</a></span><span class="word_count">(26w~1m)</span></li>
<li><span class="section_number">5.8</span><span class="section_title"><a href="#writing-portable-prolog-programs">Writing portable Prolog programs</a></span><span class="word_count">(180w~1m)</span></li>
<li><span class="section_number">5.9</span><span class="section_title"><a href="#how-do-we-manage-language-complexity">How do we manage language complexity?</a></span><span class="word_count">(95w~1m)</span></li>
<li><span class="section_number">5.10</span><span class="section_title"><a href="#not-interesting">Not interesting?</a></span><span class="word_count">(20w~1m)</span></li>
<li><span class="section_number">5.11</span><span class="section_title"><a href="#testing-1">Testing</a></span><span class="word_count">(58w~1m)</span></li>
<li><span class="section_number">5.12</span><span class="section_title"><a href="#logtalk">Logtalk?</a></span><span class="word_count">(14w~1m)</span></li>
<li><span class="section_number">5.13</span><span class="section_title"><a href="#logtalk-vs-libraryrecord">Logtalk vs library(record)?</a></span><span class="word_count">(9w~1m)</span></li>
</ul>
</div>
<h3 id="a-suggested-way-to-use-prolog-for-programming-in-the-large"><span class="section_number">5.1</span><span class="section_title">A suggested way to use Prolog for programming in the large?</span></h3>
<p>Begin by defining an ontology or domain-specific language. This is pure Prolog with declarative semantics.</p>
<p>Then specify a transformation or interpretation to reality.</p>
<p>Example: A functional programming language:</p>
<pre class="example"><code>%%  interpret(+Expression,-Value) is det.

interpret(write(A), Z) :- !,
    interpret(A, A0),
    write(A0),
    Z = unit.

interpret(A+B, Z) :- !,
    interpret(A, A0),
    interpret(B, B0),
    Z is A0 + B0.

interpret((A,B), Z) :- !,
    interpret(A, _),
    interpret(B, Z).

interpret(A, Z) :- number(A), !, Z = A.
interpret(A, Z) :- string(A), !, Z = A.
interpret(A, _) :- !, type_error(expression, A).
</code></pre>
<p>Always use explicit imports and exports. Help <code>grep</code> help us.</p>
<h3 id="disciplines-for-writing-large-maintainable-prolog-knowledge-bases"><span class="section_number">5.2</span><span class="section_title">Disciplines for writing large maintainable Prolog knowledge bases</span></h3>
<p>Some disciplines are required:</p>
<ul>
<li>Separate declarative and imperative codes.</li>
<li>Avoid depending on module systems.</li>
<li>Each declarative source file is a small <em>ontology</em>. Each imperative source file <em>merges</em> some ontologies.</li>
</ul>
<h3 id="writing-extensible-knowledge-bases"><span class="section_number">5.3</span><span class="section_title">Writing extensible knowledge bases</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">5.3.1</span><span class="section_title"><a href="#multifile-or-parametrization-and-catamorphism">Multifile or parametrization-and-catamorphism?</a></span><span class="word_count">(13w~1m)</span></li>
</ul>
</div>
<h4 id="multifile-or-parametrization-and-catamorphism"><span class="section_number">5.3.1</span><span class="section_title">Multifile or parametrization-and-catamorphism?</span></h4>
<pre class="example"><code>:- multifile foo_ext/1.

foo(A) :- foo_ext(A).
</code></pre>
<p>Catamorphism:</p>
<pre class="example"><code>foo(F,A) :- call(F,A).
</code></pre>
<p>Don't multifile if clause order matters. Reloading changes clause order. <a href="http://www.swi-prolog.org/FAQ/Multifile.html">http://www.swi-prolog.org/FAQ/Multifile.html</a></p>
<h3 id="production-prolog"><span class="section_number">5.4</span><span class="section_title">Production Prolog</span></h3>
<p>&quot;Production Prolog&quot; by Michael Hendricks; Strange Loop 2014 <a href="https://www.youtube.com/watch?v=G_eYTctGZw8">https://www.youtube.com/watch?v=G_eYTctGZw8</a></p>
<ul>
<li>This mentions &quot;Mercury's bisecting debugger&quot;</li>
<li>mavis library for optional type declarations</li>
<li>julian library for dates</li>
<li>time/1 for measuring how long a goal takes</li>
<li>library(spawn)?</li>
</ul>
<h3 id="testing"><span class="section_number">5.5</span><span class="section_title">Testing</span></h3>
<p>An example of unit testing is in <code>test.pro</code>.</p>
<pre class="example"><code>test(addition) :-
    1+2 =:= 3.

test(multiplication) :-
    2*3 =:= 6.

?- test_all.
</code></pre>
<p>What is this library for unit testing?<a href="#fn33" class="footnote-ref" id="fnref33"><sup>33</sup></a></p>
<h3 id="why-do-we-need-predicates-at-all-if-we-can-do-with-one-unary-predicate"><span class="section_number">5.6</span><span class="section_title">Why do we need predicates at all if we can do with one unary predicate?</span></h3>
<pre class="example"><code>:- op(600,xfy,:).
:- op(650,xfx,@).

invoke(father @ [abraham, isaac]).
invoke(father @ [abraham, ishmael]).
invoke(list_length @ [[], z]).
invoke(list_length @ [[_|A], N]) :-
    invoke(list_length @ [A,N0]),
    invoke(succ @ [N0,N]).
invoke(nat @ [z]).
invoke(nat @ [s(A)]) :- invoke(nat @ [A]).
invoke(succ @ [A, s(A)]) :- invoke(nat @ [A]).
</code></pre>
<p>We can even do module systems.</p>
<p>We can encode 1 module as 1 predicate.</p>
<pre class="example"><code>module1(pred @ [Arg1, Arg2, ...]) ...
module2(pred @ [Arg1, Arg2, ...]) ...
</code></pre>
<p>We can encode all modules as 1 predicate. We can have meta-predicates. We can have variable-arity predicates.</p>
<pre class="example"><code>invoke(module1:pred @ [Arg1, ...]) ...
invoke(module2(pred) @ [Arg1, ...]) ...
invoke(call @ [F|A]) :- invoke(F @ A).
</code></pre>
<p>We can do first-order logic with one predicate only and unlimited function symbols. We can convert predicates into function symbols: We can transform <span class="math inline">\( p_1(\vec{x}_1), \ldots, p_n(\vec{x}_n) \)</span> to <span class="math inline">\( P(p_k, \vec{x}_k) \)</span>. This is like writing the interpretation function inside the formal system itself. This is still first-order logic.</p>
<p>Should <code>a:b@c</code> be interpreted as <code>(a:b)@c</code> (call a:b with arguments c) or <code>a:(b@c)</code> (call b with context a and arguments c)?</p>
<p>Abstract terms. What if we write programs with only predicates and variables and no concrete terms? Why should we? Because it enables us to change the representation without changing the meaning of the program. It is the same as abstract data types in other languages.</p>
<p>We can see an as atom as a singleton predicate, that is, a predicate that is satisfied by one thing only, that is the atom.</p>
<h3 id="documentation-system"><span class="section_number">5.7</span><span class="section_title">Documentation system</span></h3>
<p>PlDoc &lt;module&gt; documentation should be taken to mean &lt;file&gt; documentation: It is files that are documented, not modules.</p>
<p>Compare: Logtalk documentation system<a href="#fn34" class="footnote-ref" id="fnref34"><sup>34</sup></a> and Logtalk documentation markup<a href="#fn35" class="footnote-ref" id="fnref35"><sup>35</sup></a>.</p>
<h3 id="writing-portable-prolog-programs"><span class="section_number">5.8</span><span class="section_title">Writing portable Prolog programs</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">5.8.1</span><span class="section_title"><a href="#use-logtalk">Use Logtalk?</a></span><span class="word_count">(31w~1m)</span></li>
<li><span class="section_number">5.8.2</span><span class="section_title"><a href="#which-string-representation-should-i-use">Which string representation should I use?</a></span><span class="word_count">(147w~1m)</span></li>
</ul>
</div>
<h4 id="use-logtalk"><span class="section_number">5.8.1</span><span class="section_title">Use Logtalk?</span></h4>
<p>Logtalk: &quot;What an object encapsulates depends on the <em>base programming paradigm</em> where we apply object-oriented programming concepts.&quot;<a href="#fn36" class="footnote-ref" id="fnref36"><sup>36</sup></a></p>
<p>Object-orientation itself is not a paradigm, but something built on top of a paradigm.</p>
<h4 id="which-string-representation-should-i-use"><span class="section_number">5.8.2</span><span class="section_title">Which string representation should I use?</span></h4>
<p>If you don't need to write portable Prolog programs, you can skip this section.</p>
<p>Unless you have to care about portability, use dedicated <em>double-quoted</em> string type (SWI-Prolog 7):</p>
<ul>
<li>&quot;Strings are distinct from lists&quot;<a href="#fn37" class="footnote-ref" id="fnref37"><sup>37</sup></a></li>
<li>&quot;Why has the representation of double quoted text changed?&quot;<a href="#fn38" class="footnote-ref" id="fnref38"><sup>38</sup></a></li>
<li>2013 article &quot;Strings in ECLiPSe 6.2, SWI-7 and YAP&quot;<a href="#fn39" class="footnote-ref" id="fnref39"><sup>39</sup></a>
<ul>
<li>&quot;With SWI-7 and ECLiPSe 6.2 string support has been harmonized, and YAP is expected to agree as well.&quot;</li>
<li>&quot;Agreed Common Functionality&quot;</li>
<li>&quot;Situation before December 2013&quot;</li>
</ul></li>
</ul>
<p>Non-answer: Edinburgh style: Double-quoted string as list of integer codes (default mode of SWI-Prolog 6.6.4 on Ubuntu 14.04): A string is represented as a list of character codes. This was in 1993 ISO standard draft<a href="#fn40" class="footnote-ref" id="fnref40"><sup>40</sup></a>, but this wasn't in the final version? Example: <code>&quot;aaa&quot; = [97,97,97]</code>. But this behavior changed in SWI-Prolog 7.</p>
<p>Non-answer: Double-quoted string as list of one-character atoms. A string is represented as a list of one-character atoms. Example: <code>&quot;aaa&quot; = [a,a,a]</code>.</p>
<h3 id="how-do-we-manage-language-complexity"><span class="section_number">5.9</span><span class="section_title">How do we manage language complexity?</span></h3>
<p>We use context to disambiguate sayings in natural languages. For example, &quot;man&quot; can mean a male human or to station people at some places as in &quot;man the guns&quot; or &quot;unmanned vehicle&quot;. We use &quot;table&quot; to mean a flat surface or a data set shown in columns and rows, depending on context.</p>
<p>Ad-hoc overloading is an example of this in programming languages. We use the same procedure name but different parameter types.</p>
<p>But ad-hoc overloading quickly becomes confusing? Also, what is the philosophical/mathematical foundation of ad-hoc overloading? Is it an engineering kludge?</p>
<h3 id="not-interesting"><span class="section_number">5.10</span><span class="section_title">Not interesting?</span></h3>
<p>Sterling &amp; Yalçinalp 1996 <span class="citation" data-cites="sterling1996logic">[<a href="#ref-sterling1996logic">27</a>]</span> presents the logic programming analog of the Gang of Four object programming design patterns.</p>
<h3 id="testing-1"><span class="section_number">5.11</span><span class="section_title">Testing</span></h3>
<p>The initial idea of &quot;prorogued&quot; programming <span class="citation" data-cites="afshari2012liberating">[<a href="#ref-afshari2012liberating">1</a>]</span> is to use the <em>user</em> as an interactive dummy implementation of stub methods. The stub implementation is &quot;ask the user for what the return value of this stub method should be&quot;. &quot;Prorogue&quot; is a rare English word meaning prolong or extend<a href="#fn41" class="footnote-ref" id="fnref41"><sup>41</sup></a>. But that is not all; types can be prorogued too.</p>
<h3 id="logtalk"><span class="section_number">5.12</span><span class="section_title">Logtalk?</span></h3>
<p>&quot;Strong motivation also come from my frustration with Prolog shortcomings for writing large applications.&quot;<a href="#fn42" class="footnote-ref" id="fnref42"><sup>42</sup></a></p>
<h3 id="logtalk-vs-libraryrecord"><span class="section_number">5.13</span><span class="section_title">Logtalk vs library(record)?</span></h3>
<p>SWI-Prolog library(record)<a href="#fn43" class="footnote-ref" id="fnref43"><sup>43</sup></a> is similar to Racket struct<a href="#fn44" class="footnote-ref" id="fnref44"><sup>44</sup></a>.</p>
<h2 id="logtalk-1"><span class="section_number">6</span><span class="section_title">Logtalk</span></h2>
<p>The problem with Logtalk: <em>too much documentation</em>, and unclear which one is authoritative; no authoritative documentation for onboarding new users. Two tutorials and one handbook<a href="#fn45" class="footnote-ref" id="fnref45"><sup>45</sup></a>, and a quick start and a tutorial<a href="#fn46" class="footnote-ref" id="fnref46"><sup>46</sup></a>. Which one am I supposed to follow? More text does not mean better documentation.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">6.1</span><span class="section_title"><a href="#how-do-i-start-using-logtalk">How do I start using Logtalk?</a></span><span class="word_count">(9w~1m)</span></li>
</ul>
</div>
<h3 id="how-do-i-start-using-logtalk"><span class="section_number">6.1</span><span class="section_title">How do I start using Logtalk?</span></h3>
<p>Git clone<a href="#fn47" class="footnote-ref" id="fnref47"><sup>47</sup></a>.</p>
<p>Set up bashrc.</p>
<p>swilgt.sh<a href="#fn48" class="footnote-ref" id="fnref48"><sup>48</sup></a></p>
<h2 id="ugly-things-awkward-squads-states-and-errors"><span class="section_number">7</span><span class="section_title">Ugly things, awkward squads, states and errors</span></h2>
<p>Simon Peyton-Jones <span class="citation" data-cites="Peytonjones2000TacklingTA">[<a href="#ref-Peytonjones2000TacklingTA">22</a>]</span> calls these the &quot;awkward squad&quot;: input/output, concurrency, exceptions, and foreign-language calls.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">7.1</span><span class="section_title"><a href="#effects-side-effects-and-errors">Effects, side-effects, and errors</a></span><span class="word_count">(750w~4m)</span></li>
<li><span class="section_number">7.2</span><span class="section_title"><a href="#error-handling-and-logging">Error handling and logging</a></span><span class="word_count">(187w~1m)</span></li>
</ul>
</div>
<h3 id="effects-side-effects-and-errors"><span class="section_number">7.1</span><span class="section_title">Effects, side-effects, and errors</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">7.1.1</span><span class="section_title"><a href="#an-effect-is-what">An effect is what?</a></span><span class="word_count">(335w~2m)</span></li>
<li><span class="section_number">7.1.2</span><span class="section_title"><a href="#an-error-is-an-unintended-behavior-unexpected-outcome">An error is an unintended behavior, unexpected outcome?</a></span><span class="word_count">(413w~3m)</span></li>
</ul>
</div>
<h4 id="an-effect-is-what"><span class="section_number">7.1.1</span><span class="section_title">An effect is what?</span></h4>
<p>What is an &quot;effect&quot;?</p>
<p>What is a &quot;side-effect&quot;?</p>
<p>Does &quot;side-&quot; imply undesirability?</p>
<p>Isn't memory allocation an effect?</p>
<p>What is a &quot;side-effect&quot;? Wikipedia<a href="#fn49" class="footnote-ref" id="fnref49"><sup>49</sup></a><a href="#fn50" class="footnote-ref" id="fnref50"><sup>50</sup></a> is inconclusive.</p>
<p>The &quot;side&quot; in &quot;side-effect&quot; implies that there are <em>effects</em> and <em>main-effects</em>, and that side-effects are unintended, unrelated, or unwanted. The <em>effect</em> of running a program is the change of the state of the universe that results from executing that program. In medicine, a side effect is an <em>unintended</em> effect, not necessarily bad<a href="#fn51" class="footnote-ref" id="fnref51"><sup>51</sup></a>. Thus, there is a parallel between chemists-and-drugs and programmers-and-programs: the designer of a drug (the programmer of a program) <em>intends</em> that taking the drug (running the program) accomplishes the <em>main-effect</em>, but reality is a bitch.</p>
<p>What is our intention when we write a program such as a Haskell program <code>inc x = (x :: Integer) + 1</code>? Our intention is that it increments an integer, for <em>every</em> integer, which is mathematically trivial but physically impossible. The side-effects are: heating up the CPU, taking up some memory, taking up some time. We certainly did not intend to heat up the CPU; therefore such heating is a side-effect. Thus the main-effect is the <em>denotation</em> (the mathematical meaning) of the program, and every implementation detail is a side-effect.</p>
<p>Thus &quot;side-effect&quot; means an effect that we failed to foresee, because the complexity was too much for us.</p>
<p>Side-effects may be fatal.</p>
<p>Spectre/Meltdown are side-effects in that sense. The chip designers sacrificed understandability for speed.</p>
<p>There is also the phrase &quot;algebraic effect&quot;.</p>
<p>We have to distinguish between a <em>program</em> and a <em>machine</em> running the program. A program does not run by itself. A <em>machine</em> runs a program. A program <em>describes</em> a computation. The machine <em>performs</em> the computation. A program is passive. A machine is active. A program exists in idea-world. A machine exists in material-world. A machine affects reality according to the program that the machine is running. The question: which is the <em>cause</em> of the change in reality: the machine or the program?</p>
<p>If we assume free will, then our thought causes our behavior, and our behavior causes something in the material-world.</p>
<h4 id="an-error-is-an-unintended-behavior-unexpected-outcome"><span class="section_number">7.1.2</span><span class="section_title">An error is an unintended behavior, unexpected outcome?</span></h4>
<p>Unintended behavior? How do we measure intention?</p>
<p>Error is like weed. They are subjective concepts. An error is an undesirable condition. Why are errors undesirable? Because they complicate programs.</p>
<p>We expect operating systems to run forever. We expect them to never err. We expect them to flawlessly reclaim the resources leaked by dead processes. We expect them to be stable in spite of badly written user programs.</p>
<p>An operating system has to prepare for the worst. Some difficult errors to recover from are out of disk space, out of memory, and disk failure. They tend to happen at the most inconvenient time.</p>
<p>Some errors such as stack overflow are fundamental assumption violations. The only sensible thing to do here is to produce diagnostics and abort the program.</p>
<p>Error handling has diminishing return. It pays off to handle common errors. It does not pay off to handle uncommon errors.</p>
<p>Error model:</p>
<ul>
<li>cost incurred by the error when it happens in an unhandled manner</li>
<li>cost incurred by the error when it happens in a handled manner</li>
<li>cost of writing the code that handles the error; this should include the increased maintenance burden due to reduced readability</li>
<li>probability of the error to happen</li>
</ul>
<p>Sometimes the cost is emotional and not monetary. It is hard to quantify emotional costs. But it is real. Users hate programs that crash.</p>
<p>Since 1726, an error is a &quot;difference between observed value and true value&quot;.<a href="#fn52" class="footnote-ref" id="fnref52"><sup>52</sup></a></p>
<p>An error is a difference between what is and what should be.</p>
<p>Midori programming language<a href="#fn53" class="footnote-ref" id="fnref53"><sup>53</sup></a><a href="#fn54" class="footnote-ref" id="fnref54"><sup>54</sup></a>.</p>
<p>Is an error a side-effect? Both errors and side-effects are unintended.</p>
<p>Let <span class="math inline">\(f&#39;\)</span> be what we think a system does. Let <span class="math inline">\(f\)</span> be what the system actually does. Then our error is <span class="math inline">\(f&#39; - f\)</span> which has to be equal to <span class="math inline">\(- (f - f&#39;)\)</span>. If each of <span class="math inline">\(f\)</span> and <span class="math inline">\(f&#39;\)</span> is a logic formula in a structure with domain <span class="math inline">\(D\)</span> and interpretation <span class="math inline">\(I\)</span>, then <span class="math inline">\(-\)</span> is symmetric difference, and negation is made with respect to <span class="math inline">\(D\)</span>.</p>
<p>For example, we think the system implements <span class="math inline">\( a \)</span>. It turns out that the system implements <span class="math inline">\( b \)</span>. Then the error is <span class="math inline">\((a \wedge \neg b) \vee (b \wedge \neg a)\)</span>. Let each of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> be a formula. Define their symmetric difference <span class="math inline">\(a - b\)</span> as <span class="math inline">\((a \wedge \neg b) \vee (b \wedge \neg a)\)</span>, similar to set-theoretic symmetric difference<a href="#fn55" class="footnote-ref" id="fnref55"><sup>55</sup></a>.</p>
<p>For example, we think the system implements <span class="math inline">\( x \mapsto x + 3 \)</span>. It turns out that the system implements <span class="math inline">\( x \mapsto x + 2 \)</span>. Then the error is <span class="math inline">\(x \mapsto 1\)</span>.</p>
<h3 id="error-handling-and-logging"><span class="section_number">7.2</span><span class="section_title">Error handling and logging</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">7.2.1</span><span class="section_title"><a href="#fail-throw-stack-traces">Fail, throw, stack traces</a></span><span class="word_count">(57w~1m)</span></li>
<li><span class="section_number">7.2.2</span><span class="section_title"><a href="#structured-logging">Structured logging</a></span><span class="word_count">(128w~1m)</span></li>
</ul>
</div>
<h4 id="fail-throw-stack-traces"><span class="section_number">7.2.1</span><span class="section_title">Fail, throw, stack traces</span></h4>
<p>Two options: throw or fail.</p>
<p>If backtracking doesn't make sense, then throw, don't fail.</p>
<pre class="example"><code>person(joe).
pair_first_second(pair(A,_), A, B).
</code></pre>
<p>Should <code>person(1)</code> fail or throw? Should <code>pair_first_second(foo)</code> fail or throw?</p>
<p>Fail means try the next alternative.</p>
<p>If you want throw/1 with stack trace, you must write it like <code>throw(error(Something, _))</code>.</p>
<p>A <em>function</em> should always throw and not fail, when an argument has a wrong type.</p>
<pre class="example"><code>negate(A,B) :- integer(A), !, B is -A.
negate(A,B) :- integer(B), !, A is -B.
negate(A,B) :- throw(error(negate(A,B),_)).
</code></pre>
<ul>
<li><a href="https://wiki.colby.edu/display/~amvartan/Exception+and+Error+Handling+in+Prolog">https://wiki.colby.edu/display/~amvartan/Exception+and+Error+Handling+in+Prolog</a></li>
<li><a href="https://stackoverflow.com/questions/32968148/why-throw-an-exception-in-prolog-instead-a-simple-fail">https://stackoverflow.com/questions/32968148/why-throw-an-exception-in-prolog-instead-a-simple-fail</a></li>
</ul>
<h4 id="structured-logging"><span class="section_number">7.2.2</span><span class="section_title">Structured logging</span></h4>
<p>This is how we log messages in Prolog:</p>
<ul>
<li>Design a term that represents the <em>meaning</em> of the message.</li>
<li>Call <code>print_message(Kind,Message)</code> where Message is that term.</li>
<li>Extend <code>prolog:message//1</code> to translate that term to string.</li>
</ul>
<pre class="example"><code>% Syntax:
prolog:message(Term) --&gt; Lines.

% Example:
prolog:message(Term) --&gt;
    [ &#39;The term is ~q.&#39;-[Term] ],
    [ &#39;This is the second line in the message.&#39; ].
</code></pre>
<p>Syntax description:</p>
<ul>
<li>'Lines' is a list of 'Line's.
<ul>
<li>A 'Line' has this shape:
<ul>
<li>Format-Args: 'Format' and 'Args' are the same arguments accepted by format/2.</li>
<li>Terms of other shapes are converted to string.</li>
</ul></li>
</ul></li>
</ul>
<p>The printed message is the concatenation of all 'Line's.</p>
<p>TODO:</p>
<ul>
<li>How do we log to file?</li>
<li>How do we rotate log files?</li>
</ul>
<p>References:</p>
<ul>
<li><a href="http://www.pathwayslms.com/swipltuts/message/index.html">Anne Ogborn's &quot;Printing Messages in SWI-Prolog&quot;</a></li>
<li><a href="http://www.swi-prolog.org/pldoc/man?section=printmsg">http://www.swi-prolog.org/pldoc/man?section=printmsg</a></li>
<li><a href="http://www.swi-prolog.org/pldoc/man?section=debug">http://www.swi-prolog.org/pldoc/man?section=debug</a></li>
<li><a href="https://www.metalevel.at/prolog/business">https://www.metalevel.at/prolog/business</a></li>
</ul>
<p>Usability issues:</p>
<ul>
<li>Where is <code>prolog:message//1</code> documented? I found that by looking at others' source code. There does not seem to be any documentation, or if there is, then it is at the wrong place.</li>
<li>Why do we require people to understand DCG rules before they can use the messaging system?</li>
</ul>
<h2 id="object-logic-programming"><span class="section_number">8</span><span class="section_title">Object-logic programming?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">8.1</span><span class="section_title"><a href="#can-we-model-objects-with-identities-without-unique-name-assumption">Can we model objects with identities without unique name assumption?</a></span><span class="word_count">(10w~1m)</span></li>
<li><span class="section_number">8.2</span><span class="section_title"><a href="#how-do-we-domakemodel-objects-and-properties-in-prolog">How do we do/make/model objects and properties in Prolog?</a></span><span class="word_count">(613w~4m)</span></li>
</ul>
</div>
<h3 id="can-we-model-objects-with-identities-without-unique-name-assumption"><span class="section_number">8.1</span><span class="section_title">Can we model objects with identities without unique name assumption?</span></h3>
<h3 id="how-do-we-domakemodel-objects-and-properties-in-prolog"><span class="section_number">8.2</span><span class="section_title">How do we do/make/model objects and properties in Prolog?</span></h3>
<p>&quot;From a logical point of view, an object, the basic abstraction unit, has a natural interpretation as a logic theory: <em>an object is simply a collection of axioms which describe what is true about the object itself</em>.&quot; <span class="citation" data-cites="ciancarini1993logic">[<a href="#ref-ciancarini1993logic">5</a>]</span> (emphasis mine)</p>
<p>An object is something with identity. In Prolog, we represent identity with the <em>unique name assumption</em>. Each object has a unique surrogate primary key. Usually this key is a Prolog atom.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">8.2.1</span><span class="section_title"><a href="#analogy-adding-objects-to-c">Analogy: adding objects to C</a></span><span class="word_count">(360w~2m)</span></li>
<li><span class="section_number">8.2.2</span><span class="section_title"><a href="#one-property-one-predicate-representation-of-objects">One-property-one-predicate representation of objects</a></span><span class="word_count">(38w~1m)</span></li>
<li><span class="section_number">8.2.3</span><span class="section_title"><a href="#opv-object-property-value-representation-of-constant-objects">OPV (object-property-value) representation of constant objects</a></span><span class="word_count">(10w~1m)</span></li>
<li><span class="section_number">8.2.4</span><span class="section_title"><a href="#representation">Representation</a></span><span class="word_count">(131w~1m)</span></li>
</ul>
</div>
<h4 id="analogy-adding-objects-to-c"><span class="section_number">8.2.1</span><span class="section_title">Analogy: adding objects to C</span></h4>
<p>In C we can have OOP by adding one &quot;this/self&quot; parameter as the first parameter of each method. I think it is also possible in Prolog. But should we?</p>
<pre class="example"><code>object_class(alice, person).
object_class(bob, person).
object_property_value(alice, name, &quot;Alice&quot;).
object_property_value(bob, name, &quot;Bob&quot;).
</code></pre>
<pre class="example"><code>person(alice).
person(bob).
person_name(alice, &quot;Alice&quot;).
person_name(bob, &quot;Bob&quot;).
</code></pre>
<p>Do we want to parameterize the class? Note that in Prolog unifying parameters is easier than unifying predicate names. That is, we cannot write <code>P(A) = Q(A)</code> where P and Q are variables.</p>
<p>&quot;Mapping Objects to Persistent Predicates&quot; <a href="https://pdfs.semanticscholar.org/f1ec/9e0e24faa1332d0cb60149e1d633b8d2509e.pdf">https://pdfs.semanticscholar.org/f1ec/9e0e24faa1332d0cb60149e1d633b8d2509e.pdf</a></p>
<p>Should we write our DSL in Twelf instead of Prolog? <a href="http://twelf.org/wiki/LF">http://twelf.org/wiki/LF</a></p>
<p>&quot;Objects with logic&quot; 1990 <a href="https://dl.acm.org/citation.cfm?id=100368">https://dl.acm.org/citation.cfm?id=100368</a></p>
<p>The difference between object and value is that an object has identity.</p>
<p>Must everything have a name?</p>
<p>An object has properties. A property is a key-value pair.</p>
<p>There are several ways to <em>represent</em> such objects in Prolog.</p>
<p>The 1-object-1-term representation represents an object as a ground term. There are two choices for such term: (1) a Prolog functor whose arity is the object's property count, or (2) a list of key-value pairs. The meaning of such representation is that iff the list L contains K-V, then the represented object has a property K whose value is V.</p>
<p>The 1-property-1-predicate representation represents each property as a predicate, but this requires <em>unique surrogate naming</em> of the object for identification: object_property1(O,P). object_property2(O,P).</p>
<p>It is surprising that database normalization theory explains some characteristics of good Prolog code.</p>
<p>Example: Suppose that there are two people Alice and Bob.</p>
<p>The question: is the object an <em>entity</em> or a <em>value</em>? An entity has identity. A value does not have identity. A natural number does not have an identity. A person has an identity. Two people may have the same name while still being two different people. The same natural number may be referred with a Arabic numeral or a Chinese numeral, but both of them refer to the same natural number.</p>
<p>The 1-object-1-term representation:</p>
<pre class="example"><code>[name-&quot;Alice&quot;, birthdate-date(1990,1,1), pets-[cat,dog]]
[name-&quot;Bob&quot;, birthdate-date(1990,1,1), pets-[cat,dog]]
</code></pre>
<p>The 1-object-1-predicate representation:</p>
<pre class="example"><code>person([name-&quot;Alice&quot;,birthdate-date(1990,1,1)).
person([name-&quot;Bob&quot;,birthdate-date(1990,1,1)]).
</code></pre>
<p>The 1-property-1-predicate representation (is this database in sixth normal form?):</p>
<pre class="example"><code>person_name(alice,&quot;Alice&quot;).
person_pet(alice,cat).
person_pet(alice,dog).
person_name(bob,&quot;Bob&quot;).
</code></pre>
<p>Note that we do not write person_pets(alice,[cat,dog]).</p>
<p>The ontological representation: kind_surrogate_property_value(person,alice,name,&quot;Alice&quot;). kind_surrogate_property_value(person,alice,birthdate,date(1990,1,1)).</p>
<p>The parameter O serves as an internal name. The equality of that parameter determines the identity of the represented object.</p>
<p>Two objects can be equal but not identical.</p>
<p>A value has no identity. An object has an <em>identity</em>.</p>
<p>Iff object_property(O,P) is provable, then object O has property P.</p>
<p>Object-oriented programming in Prolog? <a href="https://stackoverflow.com/questions/28154041/objected-oriented-programming-in-swi-prolog">https://stackoverflow.com/questions/28154041/objected-oriented-programming-in-swi-prolog</a></p>
<h4 id="one-property-one-predicate-representation-of-objects"><span class="section_number">8.2.2</span><span class="section_title">One-property-one-predicate representation of objects</span></h4>
<p>Another core idea is the <em>one-property one-predicate</em> representation, with surrogate primary keys. This enables us to represent objects in Prolog. Objects have identities. Two objects are identical iff their identifiers (primary keys) are equal. Example:</p>
<pre class="example"><code>person(PersonId)
person_name(PersonId, Name)
person_birthdate(PersonId, BirthDate)
</code></pre>
<h4 id="opv-object-property-value-representation-of-constant-objects"><span class="section_number">8.2.3</span><span class="section_title">OPV (object-property-value) representation of constant objects</span></h4>
<p>Objects without mutation. Immutable objects.</p>
<h4 id="representation"><span class="section_number">8.2.4</span><span class="section_title">Representation</span></h4>
<p>A class C has properties P1, P2, P3, etc. How do we represent an <em>instance</em> of C in Prolog? There are at least two ways: <em>many-predicates</em> and <em>one-term</em>.</p>
<p>The <em>many-predicates</em> representation makes it easy to add derived properties. One predicate represents one property. This is similar to 6NF (sixth normal form) in database theory.</p>
<pre class="example"><code>c_prop1(InstanceId, Prop1).
c_prop2(InstanceId, Prop2).
c_prop3(InstanceId, Prop3).
...
</code></pre>
<p>The <em>one-term</em> representation makes it easy to specify an instance. One term represents one instance. This is similar to 0NF/1NF (zeroth or first normal form) in database theory.</p>
<pre class="example"><code>c(InstanceId, [
    prop1 - Prop1,
    prop2 - Prop2,
    prop3 - Prop3,
    ...
]).
</code></pre>
<p>But we can combine both. We can translate an instance-wise representation to a property-wise representation:</p>
<pre class="example"><code>:- discontiguous c_prop1/2, ..., c_propN/2.

c_prop1(InstanceId, Prop1) :- c(InstanceId, Props), member(prop1-Prop1, Props).
c_prop2(InstanceId, Prop2) :- c(InstanceId, Props), member(prop2-Prop2, Props).
c_prop3(InstanceId, Prop3) :- c(InstanceId, Props), member(prop3-Prop3, Props).
...
</code></pre>
<p>But the many-predicates representation is easier to refactor than the one-term representation.</p>
<p>Conclusions:</p>
<ul>
<li>A module may internally specify objects in the one-term (denormal-form) style, but should only export predicates in the many-predicates (normal-form) style.</li>
<li>A translation should not import denormal-form predicates.</li>
</ul>
<h2 id="writing-enterprise-web-applications"><span class="section_number">9</span><span class="section_title">Writing enterprise web applications</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">9.1</span><span class="section_title"><a href="#why-do-we-model-things">Why do we model things?</a></span><span class="word_count">(5w~1m)</span></li>
<li><span class="section_number">9.2</span><span class="section_title"><a href="#modeling-the-dynamic-aspect-of-software-systems-as-inter-agent-dialogs">Modeling the dynamic aspect of software systems as inter-agent dialogs</a></span><span class="word_count">(96w~1m)</span></li>
<li><span class="section_number">9.3</span><span class="section_title"><a href="#why-should-we-use-a-modeling-language-expressive-enough-to-model-itself">Why should we use a modeling language expressive enough to model itself?</a></span><span class="word_count">(39w~1m)</span></li>
<li><span class="section_number">9.4</span><span class="section_title"><a href="#convenient-prolog-html-expression">Convenient Prolog HTML Expression</a></span><span class="word_count">(161w~1m)</span></li>
<li><span class="section_number">9.5</span><span class="section_title"><a href="#sql-prolog-integration-sketch">SQL-Prolog integration sketch</a></span><span class="word_count">(602w~4m)</span></li>
<li><span class="section_number">9.6</span><span class="section_title"><a href="#relational-multidirectional-logic-programming">Relational-multidirectional-logic programming?</a></span><span class="word_count">(2w~1m)</span></li>
<li><span class="section_number">9.7</span><span class="section_title"><a href="#the-operations">The operations</a></span><span class="word_count">(101w~1m)</span></li>
<li><span class="section_number">9.8</span><span class="section_title"><a href="#idea-write-an-sql-database-explorer-in-prolog.">Idea: Write an SQL database explorer in Prolog.</a></span><span class="word_count">(53w~1m)</span></li>
<li><span class="section_number">9.9</span><span class="section_title"><a href="#use-prolog-for-formal-software-requirement-capture-modeling.">Use Prolog for formal software requirement capture / modeling.?</a></span><span class="word_count">(133w~1m)</span></li>
<li><span class="section_number">9.10</span><span class="section_title"><a href="#prolog-revival-attempt">Prolog revival attempt</a></span><span class="word_count">(19w~1m)</span></li>
<li><span class="section_number">9.11</span><span class="section_title"><a href="#logic-programming-for-software-engineering">Logic programming for software engineering?</a></span><span class="word_count">(5w~1m)</span></li>
<li><span class="section_number">9.12</span><span class="section_title"><a href="#how-reliable-is-query-by-example">How reliable is query-by-example?</a></span><span class="word_count">(4w~1m)</span></li>
</ul>
</div>
<h3 id="why-do-we-model-things"><span class="section_number">9.1</span><span class="section_title">Why do we model things?</span></h3>
<p><a href="http://www.dubberly.com/articles/models-of-models.html">http://www.dubberly.com/articles/models-of-models.html</a></p>
<h3 id="modeling-the-dynamic-aspect-of-software-systems-as-inter-agent-dialogs"><span class="section_number">9.2</span><span class="section_title">Modeling the dynamic aspect of software systems as inter-agent dialogs</span></h3>
<p>We can think of a software system as the set of all possible <em>dialogs between agents</em>.</p>
<ul>
<li>Man queries machine.</li>
<li>Machine queries man.</li>
<li>Man commands machine.</li>
<li>Machine commands man.</li>
<li>Man queries man, man commands man, machine queries machine, machine commands machine.</li>
</ul>
<p>An agent is a man or a machine. An agent is something that can cause something.</p>
<p>An agent may query another agent. An agent may command another agent.</p>
<p>People must have thought about this before.</p>
<p>&quot;Behymer and Flach build on the idea of collaboration, proposing a model comprised of actors or 'agents', both human and 'automaton'.&quot;<a href="#fn56" class="footnote-ref" id="fnref56"><sup>56</sup></a></p>
<h3 id="why-should-we-use-a-modeling-language-expressive-enough-to-model-itself"><span class="section_number">9.3</span><span class="section_title">Why should we use a modeling language expressive enough to model itself?</span></h3>
<p>(Not yet answered.)</p>
<p>instance_of(O,C) means that O instantiates (is an instance of) C.</p>
<p>class_property(C,P) means that each instance of C has a property named P.</p>
<p>The constraint:</p>
<pre class="example"><code>forall O C : instance_of(O,C), class_property(C,P) -&gt; exists V : opv(O,P,V)
</code></pre>
<p>Class-property is its own meta-model.</p>
<pre class="example"><code>class(class).
class_property(class, name).
class_property(class, property).

class(property).
class_property(property, name).
</code></pre>
<h3 id="convenient-prolog-html-expression"><span class="section_number">9.4</span><span class="section_title">Convenient Prolog HTML Expression</span></h3>
<p>CPH stands for Convenient Prolog HTML. CPHE stands for CPH Expression. The source file is <code>html_cph.pro</code>.</p>
<p>Before you use this library:</p>
<ul>
<li>We have only HTML 5 in mind. We do not handle DTD, SGML, XML, and all that stuffs.</li>
<li>We require that the Prolog implementation have a dedicated double-quoted string type, in which a string is not a list of codes.</li>
<li>We only write HTML and do not read HTML.</li>
<li>We do not handle all tags. See is_tag/1 and is_empty_tag/1 in the source.</li>
<li>We do not handle comments.</li>
<li>We do not indent the HTML output. It is human-unreadable.</li>
<li>Security notice: We only escape attribute values and text nodes. We do not escape attribute names and doctypes.</li>
<li>Element names must be all-lower-case atoms.</li>
</ul>
<p>&lt;2019-03-29&gt; Motivation: SWI Prolog 7.6.4 library(http/html_write)<a href="#fn57" class="footnote-ref" id="fnref57"><sup>57</sup></a> was made before double-quoted strings.</p>
<p>To understand the idea, see the following example translation.</p>
<p>The predicate cphe_string/2 translates CPHE to HTML like this:</p>
<pre class="example"><code>p(class=foo, &quot;Text&quot;, style=&quot;color:#f00;&quot;, strong(&quot;Strong&quot;))

&lt;p class=&quot;foo&quot; style=&quot;color:#f00;&quot;&gt;Text&lt;strong&gt;Strong&lt;/strong&gt;&lt;/p&gt;
</code></pre>
<p>An example of a document:</p>
<pre class="example"><code>[
    &#39;!doctype&#39;(html)
    , html(
        head(
            title(&quot;Title&quot;)
        )
        , body(
            p(&quot;Paragraph&quot;)
        )
    )
]
</code></pre>
<p>Do not conflate atoms and strings. Atoms translate to empty elements. Strings translate to escaped texts.</p>
<h3 id="sql-prolog-integration-sketch"><span class="section_number">9.5</span><span class="section_title">SQL-Prolog integration sketch</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">9.5.1</span><span class="section_title"><a href="#the-idea">The idea</a></span><span class="word_count">(291w~2m)</span></li>
<li><span class="section_number">9.5.2</span><span class="section_title"><a href="#making-it-work">Making it work</a></span><span class="word_count">(3w~1m)</span></li>
<li><span class="section_number">9.5.3</span><span class="section_title"><a href="#making-it-fast">Making it fast</a></span><span class="word_count">(53w~1m)</span></li>
<li><span class="section_number">9.5.4</span><span class="section_title"><a href="#incrementalprogressive-aggregation">Incremental/progressive aggregation</a></span><span class="word_count">(98w~1m)</span></li>
<li><span class="section_number">9.5.5</span><span class="section_title"><a href="#what-else-other-similar-implementations">What else? Other similar implementations?</a></span><span class="word_count">(43w~1m)</span></li>
<li><span class="section_number">9.5.6</span><span class="section_title"><a href="#more-ambitions-all-data-sources-are-predicates-and-predicates-are-iterators">More ambitions: all data sources are predicates, and predicates are iterators</a></span><span class="word_count">(48w~1m)</span></li>
<li><span class="section_number">9.5.7</span><span class="section_title"><a href="#swi-prolog-postgresql-and-odbc">SWI-Prolog, PostgreSQL, and ODBC</a></span><span class="word_count">(70w~1m)</span></li>
</ul>
</div>
<h4 id="the-idea"><span class="section_number">9.5.1</span><span class="section_title">The idea</span></h4>
<p>The source file is <code>sql.pro</code>.</p>
<p>The initial key idea is a 1:1 mapping between SQL tables and Prolog predicates. But is it mapping to tables or to SQL SELECT queries? We can think of a table as a SELECT query. The key idea is a Prolog predicate that succeeds once for each row in a corresponding SQL table. What if we can access a SQL table as if it were a Prolog predicate?</p>
<p>It should be possible to make something like F# data provider but with Prolog predicates. It should be possible to make a Prolog predicate that fetches data when called.</p>
<p>The dream is seamless integration between Prolog and SQL databases. Seamless SQL-backed Prolog predicates.</p>
<p>Several design choices:</p>
<ul>
<li>seamless/proxy-predicate approach: a predicate that uses a connection pool; use &quot;proxy&quot; predicates with odbc_query/3; an SQL table with N columns is represented by a predicate with arity N</li>
<li>dynamic-predicate approach: populate dynamic predicates with data from table</li>
<li>optimizer-interpreter that works for both Prolog databases and SQL databases; an SQL table is modeled by a term table(Id,Cols)</li>
<li>The &quot;persistency&quot; library for persistent dynamic predicates<a href="#fn58" class="footnote-ref" id="fnref58"><sup>58</sup></a></li>
</ul>
<p>Warren 1999: &quot;Prolog is an elegant language for database queries. In fact if one constrains Prolog programs to use only atoms, integers and reals (no lists or complex terms) and disallows recursive definitions, one gets a database language that is equivalent to a powerful subset of SQL.&quot;<a href="#fn59" class="footnote-ref" id="fnref59"><sup>59</sup></a></p>
<pre class="example"><code>% employee(Id, Name, Age)

query :- interpret((table_row(employee,E), row_column_value(E,age,Age), Age &gt;= 20)).
</code></pre>
<p>Models of SQL SELECT statements:</p>
<ul>
<li>select(Table, Columns, Opts) where Opts is the optional parts (WHERE clause)
<ul>
<li>Column is an atom or an &quot;Column as Alias&quot;</li>
</ul></li>
</ul>
<pre class="example"><code>select(information_schema:columns
    , [table_name as table, column_name as column, column_type as type]
    , [
        where(column_type = &quot;integer&quot;)
        , order_by([asc(table)])
    ])
</code></pre>
<p>For testing (Do not do this on public/production server):</p>
<pre class="example"><code>CREATE USER test PASSWORD &#39;test&#39;;
CREATE DATABASE test OWNER test;
</code></pre>
<p>Other systems:</p>
<ul>
<li>CQL<a href="#fn60" class="footnote-ref" id="fnref60"><sup>60</sup></a> (Constraint Query Language) encloses its DSL expression in braces.</li>
</ul>
<p>&quot;There have been some Prolog systems in the past that could store predicates on a file.&quot;<a href="#fn61" class="footnote-ref" id="fnref61"><sup>61</sup></a></p>
<p>An SQL table can be thought of as a predicate that only works with ground terms.</p>
<h4 id="making-it-work"><span class="section_number">9.5.2</span><span class="section_title">Making it work</span></h4>
<h4 id="making-it-fast"><span class="section_number">9.5.3</span><span class="section_title">Making it fast</span></h4>
<p>We want to push the filter condition to SQL. We want to filter as close as possible to the source as much as possible. We want to minimize the amount of data transferred over the network. We want to move the computation? We want to run Prolog on the SQL database?</p>
<pre class="example"><code>employee(E), employee_age(E,A), A &gt;= 30
</code></pre>
<h4 id="incrementalprogressive-aggregation"><span class="section_number">9.5.4</span><span class="section_title">Incremental/progressive aggregation</span></h4>
<p>We often need to derive OLAP table from OLTP table. But PostgreSQL materialized view cannot partial-refresh.<a href="#fn62" class="footnote-ref" id="fnref62"><sup>62</sup></a> Often an OLTP table is an append-only log (but sometimes there is &quot;backdating&quot;).</p>
<p>Often we want to speed up queries like this:</p>
<pre class="example"><code>SELECT date, SUM(amount) FROM sale GROUP BY date;
</code></pre>
<p>We know that the query does not have to be recomputed because we know that there has been no changes to the past data in the source table.</p>
<p>But SQL is inconvenient, so we want to aggregate in the application and cache the result in an SQL table.</p>
<p>It should be possible to capture this architectural pattern in Prolog, and generate the implementation.</p>
<h4 id="what-else-other-similar-implementations"><span class="section_number">9.5.5</span><span class="section_title">What else? Other similar implementations?</span></h4>
<p>Jarke, Clifford, Vassiliou 1984 <span class="citation" data-cites="jarke1984optimizing">[<a href="#ref-jarke1984optimizing">10</a>]</span></p>
<p>&quot;One of the things that ProLog by BIM had was the ability to have Prolog use Oracle or Sybase databases as if they were Prolog's own native database&quot;<a href="#fn63" class="footnote-ref" id="fnref63"><sup>63</sup></a></p>
<p>XSB-ODBC may be similar to what I want.</p>
<h4 id="more-ambitions-all-data-sources-are-predicates-and-predicates-are-iterators"><span class="section_number">9.5.6</span><span class="section_title">More ambitions: all data sources are predicates, and predicates are iterators</span></h4>
<p>It is straightforward to generalize to other data sources: JSON, CSV, NoSQL, Redis, Lucene, etc. SLD resolution makes predicates behave as iterators.</p>
<p>Every object or table-row can be represented by a relation instance.</p>
<p>This is similar to F# type providers.</p>
<h4 id="swi-prolog-postgresql-and-odbc"><span class="section_number">9.5.7</span><span class="section_title">SWI-Prolog, PostgreSQL, and ODBC</span></h4>
<p>Install the Ubuntu 14.04 package <code>odbc-postgresql</code>.</p>
<p>I want my application to self-contain its configuration. I don't configure ODBC INI files.</p>
<p>ODBC Data Source Name (DSN) connection string</p>
<p>Relevant commands: <code>odbcinst -j</code></p>
<p>The file <code>/etc/odbcinst.ini</code> contains a list of driver names.</p>
<p><a href="http://www.swi-prolog.org/pldoc/doc_for?object=section(%2527packages/cql.html%2527)">SWI-Prolog CQL documentation</a> doesn't inspire confidence. Draxler 1991 relates database table and Prolog predicate. CQL models SQL query in Prolog terms.</p>
<p>Sketches, as good as non-existent: PL/SWI-Prolog<a href="#fn64" class="footnote-ref" id="fnref64"><sup>64</sup></a>, psqlog<a href="#fn65" class="footnote-ref" id="fnref65"><sup>65</sup></a>, what<a href="#fn66" class="footnote-ref" id="fnref66"><sup>66</sup></a>.</p>
<p>XSB-Prolog has viewsys and persistent_tables.<a href="#fn67" class="footnote-ref" id="fnref67"><sup>67</sup></a></p>
<h3 id="relational-multidirectional-logic-programming"><span class="section_number">9.6</span><span class="section_title">Relational-multidirectional-logic programming?</span></h3>
<h3 id="the-operations"><span class="section_number">9.7</span><span class="section_title">The operations</span></h3>
<p>The story does not end with development. After it comes <em>operation</em>. It's a boring task. But someone has to do it. Thus, how we make it as painless as possible?</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">9.7.1</span><span class="section_title"><a href="#devops-dependency-build-system">Devops, dependency, build system?</a></span><span class="word_count">(71w~1m)</span></li>
</ul>
</div>
<h4 id="devops-dependency-build-system"><span class="section_number">9.7.1</span><span class="section_title">Devops, dependency, build system?</span></h4>
<p>Prolog marelle, Haskell shake, build system?</p>
<ul>
<li><a href="http://quietlyamused.org/blog/2013/11/09/marelle-for-devops/">http://quietlyamused.org/blog/2013/11/09/marelle-for-devops/</a></li>
<li>&quot;there is already a configuration management language that is strongly influenced by Prolog and logic programming - Puppet - and the results are not that great&quot; <a href="https://news.ycombinator.com/item?id=6701362">https://news.ycombinator.com/item?id=6701362</a>
<ul>
<li>really?</li>
<li>The computer can't read your mind. You lie to the computer, it does what you told it to do. Don't blame the computer for your failing to tell the computer everything it needs to do the job.</li>
</ul></li>
</ul>
<p><a href="https://cloudbootup.com/post/cloudy-with-a-chance-of-prolog.html">https://cloudbootup.com/post/cloudy-with-a-chance-of-prolog.html</a></p>
<h3 id="idea-write-an-sql-database-explorer-in-prolog."><span class="section_number">9.8</span><span class="section_title">Idea: Write an SQL database explorer in Prolog.</span></h3>
<p>CLI interface without ncurses without pager. Imagine printing to paper like early Fortran/Unix/ed. Paper user interface.</p>
<ul>
<li>menu(KeyActionPairs).</li>
<li>select database</li>
<li>select schema</li>
<li>show 10 rows of table, 15 chars per column, truncating long strings with &quot;&gt;&quot;
<ul>
<li>tput <a href="https://stackoverflow.com/questions/263890/how-do-i-find-the-width-height-of-a-terminal-window">https://stackoverflow.com/questions/263890/how-do-i-find-the-width-height-of-a-terminal-window</a></li>
<li>My 1920x1080 terminal has 191 columns and 53 lines.</li>
</ul></li>
<li>go up / back to previous menu.</li>
</ul>
<h3 id="use-prolog-for-formal-software-requirement-capture-modeling."><span class="section_number">9.9</span><span class="section_title">Use Prolog for formal software requirement capture / modeling.?</span></h3>
<p>&quot;Are there any standard Prolog knowledge bases available anywhere that have the same purpose as Cyc, namely to encode generally accepted common sense and human knowledge?&quot; <a href="https://cs.stackexchange.com/questions/35237/open-standard-prolog-knowledge-bases">https://cs.stackexchange.com/questions/35237/open-standard-prolog-knowledge-bases</a></p>
<p>2004 &quot;SweetProlog: A System to Integrate Ontologies and Rules&quot; <a href="https://pdfs.semanticscholar.org/03c2/a0048a5845bb1f52462c4f26d7be0a929d7a.pdf">https://pdfs.semanticscholar.org/03c2/a0048a5845bb1f52462c4f26d7be0a929d7a.pdf</a></p>
<p>Prolog is better than Turtle. <a href="http://sujitpal.blogspot.com/2009/06/ontology-rules-with-prolog.html">http://sujitpal.blogspot.com/2009/06/ontology-rules-with-prolog.html</a> &quot;I actually set out to learn Jena Rules using the Semantic Web Programming book as a guide. Midway through that exercise, it occurred to me that Prolog would be a cleaner and almost drop-in replacement to the rather verbose Turtle syntax. Apparently the Semantic Web community thinks otherwise, since Turtle stands for Terse RDF Triple language. I haven't actually used Prolog before this, although I've read code snippets in articles once or twice (but not recently), so the realization was almost like an epiphany.&quot;</p>
<p><a href="http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/1989/8910/8910f/8910f.htm">http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/1989/8910/8910f/8910f.htm</a></p>
<p><a href="https://www.cs.auckland.ac.nz/~j-hamer/07.363/prolog-for-se.html">https://www.cs.auckland.ac.nz/~j-hamer/07.363/prolog-for-se.html</a></p>
<p><a href="http://ceur-ws.org/Vol-274/paper6.pdf">http://ceur-ws.org/Vol-274/paper6.pdf</a></p>
<h3 id="prolog-revival-attempt"><span class="section_number">9.10</span><span class="section_title">Prolog revival attempt</span></h3>
<ul>
<li><a href="https://github.com/Web-Prolog/swi-web-prolog">https://github.com/Web-Prolog/swi-web-prolog</a></li>
</ul>
<p>Wielemaker &amp; Angelopoulos 2012 &quot;Syntactic integration of external languages in Prolog&quot; <a href="https://pdfs.semanticscholar.org/35eb/0b9d6edc27dd4564d98b107fec08e45e36cd.pdf">https://pdfs.semanticscholar.org/35eb/0b9d6edc27dd4564d98b107fec08e45e36cd.pdf</a> SQL-Prolog Draxler [2] NED [5]</p>
<h3 id="logic-programming-for-software-engineering"><span class="section_number">9.11</span><span class="section_title">Logic programming for software engineering?</span></h3>
<p><span class="citation" data-cites="ciancarini1993logic">[<a href="#ref-ciancarini1993logic">5</a>]</span></p>
<p><span class="citation" data-cites="liu2018logic">[<a href="#ref-liu2018logic">13</a>]</span></p>
<h3 id="how-reliable-is-query-by-example"><span class="section_number">9.12</span><span class="section_title">How reliable is query-by-example?</span></h3>
<p><a href="https://en.wikipedia.org/wiki/Query_by_Example">https://en.wikipedia.org/wiki/Query_by_Example</a></p>
<h2 id="dsl-meta-programming-optimizing-checking-multi-paradigm-whatnot"><span class="section_number">10</span><span class="section_title">DSL, meta-programming, optimizing, checking, multi-paradigm, whatnot</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">10.1</span><span class="section_title"><a href="#ramble-translating-prolog-to-native-code">Ramble: Translating Prolog to native code?</a></span><span class="word_count">(183w~1m)</span></li>
<li><span class="section_number">10.2</span><span class="section_title"><a href="#implicit-state-language">Implicit state language?</a></span><span class="word_count">(3w~1m)</span></li>
<li><span class="section_number">10.3</span><span class="section_title"><a href="#prolog-needs-static-checking-like-erlang-dialyzer.">&lt;2018-11-30&gt; Prolog needs static checking like Erlang Dialyzer.</a></span><span class="word_count">(34w~1m)</span></li>
<li><span class="section_number">10.4</span><span class="section_title"><a href="#alternative-declarative-semantics">Alternative declarative semantics</a></span><span class="word_count">(85w~1m)</span></li>
<li><span class="section_number">10.5</span><span class="section_title"><a href="#meta-programming">Meta-programming</a></span><span class="word_count">(26w~1m)</span></li>
<li><span class="section_number">10.6</span><span class="section_title"><a href="#constraint-logic-programming">Constraint logic programming</a></span><span class="word_count">(55w~1m)</span></li>
<li><span class="section_number">10.7</span><span class="section_title"><a href="#advanced-logic-programming">Advanced logic programming</a></span><span class="word_count">(20w~1m)</span></li>
<li><span class="section_number">10.8</span><span class="section_title"><a href="#language-oriented-programming-embedding-a-language-in-prolog">Language-oriented programming, embedding a language in Prolog</a></span><span class="word_count">(149w~1m)</span></li>
<li><span class="section_number">10.9</span><span class="section_title"><a href="#iterative-deepening-search-with-length1">Iterative deepening search with length/1</a></span><span class="word_count">(37w~1m)</span></li>
<li><span class="section_number">10.10</span><span class="section_title"><a href="#prolog-lisp-operators-reflection-backtracking">Prolog = Lisp + operators + reflection + backtracking</a></span><span class="word_count">(87w~1m)</span></li>
<li><span class="section_number">10.11</span><span class="section_title"><a href="#all-state-computations-are-pure-in-the-bigger-supersystem">All state computations are pure in the bigger supersystem</a></span><span class="word_count">(28w~1m)</span></li>
<li><span class="section_number">10.12</span><span class="section_title"><a href="#warren-abstract-machine">Warren abstract machine</a></span><span class="word_count">(23w~1m)</span></li>
<li><span class="section_number">10.13</span><span class="section_title"><a href="#attributed-variables">Attributed variables</a></span><span class="word_count">(20w~1m)</span></li>
<li><span class="section_number">10.14</span><span class="section_title"><a href="#partial-evaluation">Partial evaluation</a></span><span class="word_count">(59w~1m)</span></li>
<li><span class="section_number">10.15</span><span class="section_title"><a href="#logic-programming-and-compiler-writing">Logic programming and compiler writing</a></span><span class="word_count">(26w~1m)</span></li>
</ul>
</div>
<h3 id="ramble-translating-prolog-to-native-code"><span class="section_number">10.1</span><span class="section_title">Ramble: Translating Prolog to native code?</span></h3>
<p>The idea is to relate a Prolog predicate and a C routine.</p>
<p>Every disjunct translates into one routine / basic block.</p>
<p>The current goal relates to the instruction pointer.</p>
<p>Proving a goal ~ calling a routine Conjunction of phrase ~ sequence of call Disjunction of clause ~ speculative parallel execution, for pure predicates only</p>
<p>p(A),q(A) can be optimized from O(PQ) time to O(max(P,Q)) time if we order the storage.</p>
<p>Intermediate language Compile by abstract interpretation unify(Var1,Var2) frame(Instrs) prove((A,B)) :- prove(A), prove(B).</p>
<p>A variable in clause head is implicitly universally quantified. A free variable in clause body is implicitly existentially quantified.</p>
<p>Prolog just-in-time compilation compile(GoalAst, Fragment) call(Fragment) Execute?</p>
<p>Compile prolog predicates, limited to u32 parameters. Normalize p(a). to p(A) :- A=a. If first arg is bound, use index. Else sequential scan. Subset of prolog. Focus on translation for performance. No dynamic predicates. Generate a c func for some predicate direction. plus_bbb plus_bbu … plus_uuu Add a state parameter for nondet predicate. (Next clause index to try). Initial value 0. p(A,B) :- B is A + 1.</p>
<p>Libjit vs llvm? mmap and mprotect</p>
<p>father_child(F,C)</p>
<p>bool father_child(termref F, termref C) { }</p>
<h3 id="implicit-state-language"><span class="section_number">10.2</span><span class="section_title">Implicit state language?</span></h3>
<div class="sourceCode" id="cb83"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb83-1" title="1">interpret(state(<span class="dt">S</span>)<span class="kw">,</span> <span class="dt">S</span><span class="kw">,</span> <span class="dt">S</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb83-2" title="2">interpret(state_set(<span class="dt">S</span>)<span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> <span class="dt">S</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb83-3" title="3">interpret((<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">,</span><span class="dt">S0</span><span class="kw">,</span><span class="dt">S2</span>) <span class="kw">:-</span> interpret(<span class="dt">A</span><span class="kw">,</span><span class="dt">S0</span><span class="kw">,</span><span class="dt">S1</span>)<span class="kw">,</span> interpret(<span class="dt">B</span><span class="kw">,</span><span class="dt">S1</span><span class="kw">,</span><span class="dt">S2</span>)<span class="kw">.</span></a></code></pre></div>
<h3 id="prolog-needs-static-checking-like-erlang-dialyzer."><span class="section_number">10.3</span><span class="section_title">&lt;2018-11-30&gt; Prolog needs static checking like Erlang Dialyzer.</span></h3>
<p>SWI-Prolog has check library?</p>
<p>Is there a Prolog totality/determinism checker?</p>
<p>Prolog typechecking is vital to prevent stupid mistakes in a large knowledge base?</p>
<p>1997 inconclusive discussion &quot;Prolog Type Checker&quot; <a href="https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/typing/types.html">https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/typing/types.html</a></p>
<h3 id="alternative-declarative-semantics"><span class="section_number">10.4</span><span class="section_title">Alternative declarative semantics</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">10.4.1</span><span class="section_title"><a href="#prolog-should-use-three-valued-logic">Prolog should use three-valued logic?</a></span><span class="word_count">(54w~1m)</span></li>
<li><span class="section_number">10.4.2</span><span class="section_title"><a href="#declarative-programming-function-arguments">Declarative programming? Function arguments?</a></span><span class="word_count">(28w~1m)</span></li>
<li><span class="section_number">10.4.3</span><span class="section_title"><a href="#what">What?</a></span><span class="word_count">(3w~1m)</span></li>
</ul>
</div>
<h4 id="prolog-should-use-three-valued-logic"><span class="section_number">10.4.1</span><span class="section_title">Prolog should use three-valued logic?</span></h4>
<p>Suppose that both A and B are unbound variables. Then:</p>
<ul>
<li><code>A =</code> B= is unknown, but it's false in Prolog.</li>
<li><code>A \</code> B= is unknown, not it's false in Prolog.</li>
</ul>
<p>In that case, it is better for Prolog to throw an instantiation_error instead of failing.</p>
<p>Three-valued logic would simplify and elegantize constraint logic programming?</p>
<h4 id="declarative-programming-function-arguments"><span class="section_number">10.4.2</span><span class="section_title">Declarative programming? Function arguments?</span></h4>
<p>The idea: A relation's parameter can be a unifiable logic variable or a beta-reducible lambda expression.</p>
<pre class="example"><code>is_one(A : exp(integer)) :- A = 1.
?- is_one(0+1).
true.

f(A : var(integer)) :- A = 1.
?- f(0+1).
false.
</code></pre>
<p>TODO Compare various approaches such as LambdaProlog, Mercury, and Curry.</p>
<h4 id="what"><span class="section_number">10.4.3</span><span class="section_title">What?</span></h4>
<p>Porto 2011 <span class="citation" data-cites="porto2011structured">[<a href="#ref-porto2011structured">23</a>]</span></p>
<h3 id="meta-programming"><span class="section_number">10.5</span><span class="section_title">Meta-programming</span></h3>
<p>&lt;2018-12-06&gt; Prolog is the best meta-language I have found so far. It is a good meta-language for defining other languages.</p>
<p>To define 'macros', use <code>term_expansion</code> or <code>goal_expansion</code>.</p>
<h3 id="constraint-logic-programming"><span class="section_number">10.6</span><span class="section_title">Constraint logic programming</span></h3>
<p>Why does use_module(library(clpfd)) increases loading time perceptibly?</p>
<p>Should we use clpfd #=/2 instead of is/2? But it's good to have minimal dependencies.</p>
<p>Motivation?</p>
<p>Consider this program for enumerating the duplicates in an array.</p>
<pre class="example"><code>duplicate(F, I, J, A) :-
    arg(I, F, A),
    arg(J, F, A),
    I \= J.
</code></pre>
<p>The compiler should be able to infer the constraints and use it to produce this, reducing the number of comparisons to half the original?</p>
<pre class="example"><code>duplicate(F, J, K, A) :-
    functor(F, _, N),
    between(1, N, J),
    between(J, N, K),
    arg(J, F, A),
    arg(K, F, A),
    J \= K.
</code></pre>
<h3 id="advanced-logic-programming"><span class="section_number">10.7</span><span class="section_title">Advanced logic programming</span></h3>
<p>According to some curriculums, advanced logic programming includes SLG (tableau) resolution, constraint logic programming, and inductive logic programming.</p>
<h3 id="language-oriented-programming-embedding-a-language-in-prolog"><span class="section_number">10.8</span><span class="section_title">Language-oriented programming, embedding a language in Prolog</span></h3>
<p>Advantages:</p>
<ul>
<li>Reuse all of Prolog.</li>
<li>Concentrate on the abstract syntax and the semantics, and not on the surface syntax.</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>No custom syntax error messages, because we embed our language in Prolog.</li>
<li>Limited to Prolog syntax. No array index operator such as <code>a[i]</code>.</li>
</ul>
<p>Several possibilities:</p>
<ul>
<li>Horn clauses.</li>
<li>Custom terms with custom interpretation function.</li>
</ul>
<p>The 2010 article &quot;Using DSLs for Developing Enterprise Systems&quot; <a href="https://research.cyber.ee/simpl/enterprise-dsl.pdf">pdf</a>:</p>
<ul>
<li>It uses the terms &quot;language engineer&quot;, &quot;transformation specialist&quot;, and &quot;business engineer&quot;.</li>
<li>It defines several usage scenarios of DSLs.</li>
<li>It defines five criteria for comparing DSL tools.</li>
<li>It compares some DSL tools.</li>
<li>It should have been a wiki article.</li>
</ul>
<p>A relation can be thought of as an interpretation of function terms. For example, m0/2 and m1/2 give different meanings to the same function term f/1.</p>
<pre class="example"><code>m0(f(X), Y) :- Y is X+1.
m1(f(X), Y) :- Y is 2*X.
</code></pre>
<p>Prolog is ideal for writing DSLs because:</p>
<ul>
<li>We can embed the abstract syntax in Prolog syntax. We can skip specifying the grammar and go directly to specifying the semantics.</li>
<li>Specifying the semantics is straightforward.</li>
</ul>
<pre class="example"><code>exp_val(S, T) :- string(S), !, S = T.
exp_val(S, T) :- number(S), !, S = T.
exp_val(A+B, C) :- string(A), string(B), !, string_concat(A, B, C).
exp_val(A+B, C) :- number(A), number(B), !, C is A+B.
</code></pre>
<h3 id="iterative-deepening-search-with-length1"><span class="section_number">10.9</span><span class="section_title">Iterative deepening search with length/1</span></h3>
<p>Prolog uses depth-first search. It isn't complete. (What does that mean?)</p>
<p>If you have a query <code>goal(List)</code> where <code>List</code> is a list, then you can query <code>length(List, _), goal(List)</code> to make the search complete.</p>
<p><a href="https://en.wikibooks.org/wiki/Prolog/Search_techniques">https://en.wikibooks.org/wiki/Prolog/Search_techniques</a></p>
<h3 id="prolog-lisp-operators-reflection-backtracking"><span class="section_number">10.10</span><span class="section_title">Prolog = Lisp + operators + reflection + backtracking</span></h3>
<p>Both Prolog and Lisp has terms, read, eval, write, and macros.</p>
<p>Prolog has read/1. Lisp has read.</p>
<p>Prolog has call/1. Lisp has eval.</p>
<p>Prolog has term_expansion/2. Lisp has defmacro.</p>
<p>Prolog has infix prefix, infix, and suffix operators. Lisp does not have them? Lisp is all prefix? There may be some extensions?</p>
<p>Operators facilitate human-reading but complicate machine-parsing.</p>
<p>If we are going to pick a high-level language, we should pick one that has solid mathematical foundation. But that is enough. How about language usability and toolchain?</p>
<h3 id="all-state-computations-are-pure-in-the-bigger-supersystem"><span class="section_number">10.11</span><span class="section_title">All state computations are pure in the bigger supersystem</span></h3>
<p>Endofunction from state to state.</p>
<p>Side-effects are like weed: They are human-invented labels, a subjective teleological categorization without objective ontological existence.</p>
<h3 id="warren-abstract-machine"><span class="section_number">10.12</span><span class="section_title">Warren abstract machine</span></h3>
<p>&quot;Goal: Adapting the Warren abstract machine to the LLVM IR machine model for later compilation.&quot; &quot;Hassan Aït-Kaci's WAM book&quot; 2018 <a href="https://www.researchgate.net/project/Compiling-Prolog">https://www.researchgate.net/project/Compiling-Prolog</a></p>
<h3 id="attributed-variables"><span class="section_number">10.13</span><span class="section_title">Attributed variables</span></h3>
<p>I feel that attributed variables seem to be an engineering hack without mathematical justification. It interacts badly with term-copying.</p>
<h3 id="partial-evaluation"><span class="section_number">10.14</span><span class="section_title">Partial evaluation</span></h3>
<p>A common way to make compiler is to use a parser generator and what?</p>
<p>A possibly better way is to write an interpreter and <em>get a compiler for free</em> by partial evaluation.</p>
<p>Writing an interpreter is much easier than writing a compiler.</p>
<p>&quot;Partial deduction&quot; is partial evaluation from logic point of view.</p>
<p>Jones, Gomard, &amp; Sestoft 1993 book on partial evaluation <span class="citation" data-cites="jones1993partial">[<a href="#ref-jones1993partial">11</a>]</span></p>
<h3 id="logic-programming-and-compiler-writing"><span class="section_number">10.15</span><span class="section_title">Logic programming and compiler writing</span></h3>
<p>Warren 1980 &quot;Logic programming and compiler writing&quot; <a href="http://sovietov.com/tmp/warren1980.pdf">http://sovietov.com/tmp/warren1980.pdf</a></p>
<p>Hamel 2016 &quot;Formal Methods: A First Introduction using Prolog to specify Programming Language Semantics&quot; <a href="https://pdfs.semanticscholar.org/1c13/792241df9d5e002dab7a2515f11ad1fbc85e.pdf">https://pdfs.semanticscholar.org/1c13/792241df9d5e002dab7a2515f11ad1fbc85e.pdf</a></p>
<h2 id="theoretical-foundations-of-logic-programming"><span class="section_number">11</span><span class="section_title">Theoretical foundations of logic programming</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">11.1</span><span class="section_title"><a href="#theories-of-truth">Theories of truth</a></span><span class="word_count">(22w~1m)</span></li>
<li><span class="section_number">11.2</span><span class="section_title"><a href="#semantics">Semantics</a></span><span class="word_count">(50w~1m)</span></li>
<li><span class="section_number">11.3</span><span class="section_title"><a href="#why-does-automatic-theorem-proving-use-resolution">Why does automatic theorem proving use resolution?</a></span><span class="word_count">(7w~1m)</span></li>
<li><span class="section_number">11.4</span><span class="section_title"><a href="#what-is-wrong-with-prolog">What is wrong with Prolog?</a></span><span class="word_count">(91w~1m)</span></li>
<li><span class="section_number">11.5</span><span class="section_title"><a href="#is-there-a-general-purpose-relational-programming-language-not-restricted-to-databases">Is there a general-purpose relational programming language not restricted to databases?</a></span><span class="word_count">(11w~1m)</span></li>
<li><span class="section_number">11.6</span><span class="section_title"><a href="#which-point-of-view-should-we-use-logic-set-relation">Which point of view should we use: logic, set, relation?</a></span><span class="word_count">(33w~1m)</span></li>
<li><span class="section_number">11.7</span><span class="section_title"><a href="#prolog-vs-datalog">Prolog vs datalog</a></span><span class="word_count">(8w~1m)</span></li>
<li><span class="section_number">11.8</span><span class="section_title"><a href="#how-does-lambda-prolog-extend-prolog">How does Lambda-Prolog extend Prolog?</a></span><span class="word_count">(82w~1m)</span></li>
<li><span class="section_number">11.9</span><span class="section_title"><a href="#how-do-lambda-logic-and-lambda-prolog-relate">How do Lambda-Logic and Lambda-Prolog relate?</a></span><span class="word_count">(17w~1m)</span></li>
<li><span class="section_number">11.10</span><span class="section_title"><a href="#predicate-logic-can-be-thought-of-propositional-logic-with-parameters">Predicate logic can be thought of propositional logic with parameters</a></span><span class="word_count">(47w~1m)</span></li>
<li><span class="section_number">11.11</span><span class="section_title"><a href="#horn-clauses-history-importance-why">Horn clauses, history, importance, why?</a></span><span class="word_count">(31w~1m)</span></li>
<li><span class="section_number">11.12</span><span class="section_title"><a href="#why-is-prolog-a-dynamic-programming-language">Why is Prolog a dynamic programming language?</a></span><span class="word_count">(75w~1m)</span></li>
</ul>
</div>
<h3 id="theories-of-truth"><span class="section_number">11.1</span><span class="section_title">Theories of truth</span></h3>
<p>There are at least three theories of truth<a href="#fn68" class="footnote-ref" id="fnref68"><sup>68</sup></a>. But there are more.<a href="#fn69" class="footnote-ref" id="fnref69"><sup>69</sup></a> There is also Tarski's model-theoretic theory of truth.</p>
<h3 id="semantics"><span class="section_number">11.2</span><span class="section_title">Semantics</span></h3>
<p><a href="https://math.stackexchange.com/questions/2112719/what-is-the-difference-between-herbrand-logic-and-relational-logic-or-predicate">https://math.stackexchange.com/questions/2112719/what-is-the-difference-between-herbrand-logic-and-relational-logic-or-predicate</a></p>
<p>There are several semantics for logic programs:</p>
<ul>
<li>Tarski</li>
<li>model</li>
<li>Herbrand</li>
<li>operational</li>
</ul>
<p>Genesereth &amp; Kao advocates using Herbrand semantics instead of Tarski semantics. They claim that Herbrand semantics is easier to teach.<a href="#fn70" class="footnote-ref" id="fnref70"><sup>70</sup></a><a href="#fn71" class="footnote-ref" id="fnref71"><sup>71</sup></a></p>
<p>Shieber et al. 1995 <span class="citation" data-cites="shieber1995principles">[<a href="#ref-shieber1995principles">25</a>]</span> p. 14 puts it eloquently: First-order terms &quot;can be understood as abbreviations for the sets of all their ground instances&quot;.</p>
<h3 id="why-does-automatic-theorem-proving-use-resolution"><span class="section_number">11.3</span><span class="section_title">Why does automatic theorem proving use resolution?</span></h3>
<p><a href="https://math.stackexchange.com/questions/2394518/why-was-the-resolution-method-so-important-to-ai-theorem-proving">https://math.stackexchange.com/questions/2394518/why-was-the-resolution-method-so-important-to-ai-theorem-proving</a>?</p>
<h3 id="what-is-wrong-with-prolog"><span class="section_number">11.4</span><span class="section_title">What is wrong with Prolog?</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">11.4.1</span><span class="section_title"><a href="#the-problem-with-var1-non-commutativity-and-non-monotonicity">The problem with var/1: non-commutativity and non-monotonicity</a></span><span class="word_count">(21w~1m)</span></li>
<li><span class="section_number">11.4.2</span><span class="section_title"><a href="#why-should-a-logic-programming-language-be-sound-and-complete">Why should a logic programming language be sound and complete?</a></span><span class="word_count">(17w~1m)</span></li>
<li><span class="section_number">11.4.3</span><span class="section_title"><a href="#how-is-prolog-unsound">How is Prolog unsound?</a></span><span class="word_count">(32w~1m)</span></li>
<li><span class="section_number">11.4.4</span><span class="section_title"><a href="#what-is-wrong-with-logic-programming">What is wrong with logic programming?</a></span><span class="word_count">(20w~1m)</span></li>
</ul>
</div>
<h4 id="the-problem-with-var1-non-commutativity-and-non-monotonicity"><span class="section_number">11.4.1</span><span class="section_title">The problem with var/1: non-commutativity and non-monotonicity</span></h4>
<p>Usually conjunction is commutative: <span class="math inline">\(a \wedge b \equiv b \wedge a\)</span>. But var/1 breaks that.</p>
<pre class="example"><code>p(A) :- var(A), A = 1.
q(A) :- A = 1, var(A).

?- p(A).
A = 1.

?- q(A).
false.
</code></pre>
<h4 id="why-should-a-logic-programming-language-be-sound-and-complete"><span class="section_number">11.4.2</span><span class="section_title">Why should a logic programming language be sound and complete?</span></h4>
<p>Prolog is unsound. So what?</p>
<p>(example of Prolog's unsoundness?)</p>
<h4 id="how-is-prolog-unsound"><span class="section_number">11.4.3</span><span class="section_title">How is Prolog unsound?</span></h4>
<p>From <span class="citation" data-cites="boizumault2014implementation">[<a href="#ref-boizumault2014implementation">3</a>]</span>:</p>
<ul>
<li>&quot;The absence of the occur check entails the unsoundness of the resolution strategy used by Prolog.&quot;</li>
<li>&quot;The main reason for this omission is a sensible gain in execution time.&quot;</li>
</ul>
<h4 id="what-is-wrong-with-logic-programming"><span class="section_number">11.4.4</span><span class="section_title">What is wrong with logic programming?</span></h4>
<p>&quot;What is Wrong with Logic Programming?&quot; &quot;A Deductive Solution to Mutable State and I/O&quot; <a href="https://pdfs.semanticscholar.org/ca08/dcb9eddc1e7651509daac7fa02eddb7f675b.pdf">https://pdfs.semanticscholar.org/ca08/dcb9eddc1e7651509daac7fa02eddb7f675b.pdf</a></p>
<h3 id="is-there-a-general-purpose-relational-programming-language-not-restricted-to-databases"><span class="section_number">11.5</span><span class="section_title">Is there a general-purpose relational programming language not restricted to databases?</span></h3>
<h3 id="which-point-of-view-should-we-use-logic-set-relation"><span class="section_number">11.6</span><span class="section_title">Which point of view should we use: logic, set, relation?</span></h3>
<p>A relation is not a mere set, but is a <em>triple</em> of domain, codomain, and mapping. Thus there is a <em>type theory</em> of relations.</p>
<h3 id="prolog-vs-datalog"><span class="section_number">11.7</span><span class="section_title">Prolog vs datalog</span></h3>
<p>Prolog is top-down/backward-chaining. Datalog is bottom-up/forward-chaining.</p>
<h3 id="how-does-lambda-prolog-extend-prolog"><span class="section_number">11.8</span><span class="section_title">How does Lambda-Prolog extend Prolog?</span></h3>
<p>Nadathur &amp; Miller 1988 <span class="citation" data-cites="nadathur1988overview">[<a href="#ref-nadathur1988overview">20</a>]</span> justifies Lambda-Prolog.</p>
<p>&quot;The language Lambda-Prolog extends the logic of Horn clauses by allowing the use of implication not just in clauses, but also in goals,&quot; among other things.<a href="#fn72" class="footnote-ref" id="fnref72"><sup>72</sup></a></p>
<p>&quot;By moving away from classical logic, Lambda Prolog was able to expand to a much larger fragment of logic: higher-order hereditary Harrop formulas. This allows some features, e.g. modules, to be handled in a logical way as opposed to the ad-hoc way they are handled in Prolog.&quot;<a href="#fn73" class="footnote-ref" id="fnref73"><sup>73</sup></a></p>
<h3 id="how-do-lambda-logic-and-lambda-prolog-relate"><span class="section_number">11.9</span><span class="section_title">How do Lambda-Logic and Lambda-Prolog relate?</span></h3>
<p>How do Beeson 2004 <span class="citation" data-cites="beeson2004lambda">[<a href="#ref-beeson2004lambda">2</a>]</span> and Miller &amp; Nadathur 2012 <span class="citation" data-cites="miller2012programming">[<a href="#ref-miller2012programming">18</a>]</span> relate?</p>
<h3 id="predicate-logic-can-be-thought-of-propositional-logic-with-parameters"><span class="section_number">11.10</span><span class="section_title">Predicate logic can be thought of propositional logic with parameters</span></h3>
<p>This fragment looks like written by a programmer who does not know arrays or a logician who does not know parameters.</p>
<pre class="example"><code>handsome_bob
man_bob
handsome_joe
man_joe
handsome_bob -&gt; man_bob
handsome_joe -&gt; man_joe
</code></pre>
<p>Then he learns about arrays and parameters, and he rewrites that to <span class="math inline">\( \forall x (handsome(x) \to man(x)) \)</span>.</p>
<h3 id="horn-clauses-history-importance-why"><span class="section_number">11.11</span><span class="section_title">Horn clauses, history, importance, why?</span></h3>
<p>&lt;2019-04-13&gt; It is a shame that Horn's paper &quot;On sentences which are true of direct unions of algebras&quot; is not freely available online. (Login-wall is not free.)</p>
<h3 id="why-is-prolog-a-dynamic-programming-language"><span class="section_number">11.12</span><span class="section_title">Why is Prolog a dynamic programming language?</span></h3>
<p><a href="https://en.wikipedia.org/wiki/Dynamic_programming_language">https://en.wikipedia.org/wiki/Dynamic_programming_language</a></p>
<p>Functionalities such as assert/1 and retract/1 are inherently dynamic.</p>
<p>Why use dynamic programming languages?</p>
<p>Dynamic does not mean lack of checking. We can write our own checker in Prolog.</p>
<p>Static language = dynamic language + checking</p>
<p>Static languages are usually translated (compiled) instead of interpreted.</p>
<p>The checking is part of the translation.</p>
<p>Writing an interpreter is much easier than writing a compiler because when writing an interpreter we can reuse all features of the meta-language.</p>
<h2 id="artificial-intelligence"><span class="section_number">12</span><span class="section_title">Artificial intelligence?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">12.1</span><span class="section_title"><a href="#finding-out-what-to-ask-coming-up-with-a-question-machine-scientist">Finding out what to ask; coming up with a question; machine scientist?</a></span><span class="word_count">(87w~1m)</span></li>
<li><span class="section_number">12.2</span><span class="section_title"><a href="#logic-of-machine-comprehension-and-machine-translation">Logic of machine comprehension and machine translation?</a></span><span class="word_count">(46w~1m)</span></li>
<li><span class="section_number">12.3</span><span class="section_title"><a href="#advanced-reasoning-non-monotonic-logic-abduction-induction">Advanced reasoning: non-monotonic logic, abduction, induction</a></span><span class="word_count">(6w~1m)</span></li>
<li><span class="section_number">12.4</span><span class="section_title"><a href="#problem-with-openai-gym">&lt;2019-04-16&gt; Problem with OpenAI Gym</a></span><span class="word_count">(12w~1m)</span></li>
</ul>
</div>
<h3 id="finding-out-what-to-ask-coming-up-with-a-question-machine-scientist"><span class="section_number">12.1</span><span class="section_title">Finding out what to ask; coming up with a question; machine scientist?</span></h3>
<p>Suppose that:</p>
<ul>
<li>There is an agent <span class="math inline">\(A\)</span> with goal <span class="math inline">\(G\)</span>.</li>
<li><span class="math inline">\(K\)</span> is the entire knowledge of agent <span class="math inline">\(A\)</span>. This <span class="math inline">\(K\)</span> may be thought of as a set of Horn clauses.</li>
</ul>
<p>Define &quot;hypothesis&quot; as &quot;something we don't know but should know&quot;?</p>
<p>The questions:</p>
<ul>
<li>What question should the agent ask (and try to answer) in order to optimally increase the agent's knowledge?</li>
<li>How do we craft/select/formulate hypotheses?</li>
</ul>
<p>Intuitively, an agent gains zero knowledge by answering a question whose answer is already in its knowledge set.</p>
<h3 id="logic-of-machine-comprehension-and-machine-translation"><span class="section_number">12.2</span><span class="section_title">Logic of machine comprehension and machine translation?</span></h3>
<p>We can imagine a relation internal_external(I,E) where I is an internal language of thought and C is an external language (natural language).</p>
<p>We can see that a relation like english_indonesian(EnglishWord,IndonesianWord) does not have any provisions for using context to disambiguate meanings.</p>
<h3 id="advanced-reasoning-non-monotonic-logic-abduction-induction"><span class="section_number">12.3</span><span class="section_title">Advanced reasoning: non-monotonic logic, abduction, induction</span></h3>
<p><a href="https://book.simply-logical.space/part_iii.html">https://book.simply-logical.space/part_iii.html</a></p>
<h3 id="problem-with-openai-gym"><span class="section_number">12.4</span><span class="section_title">&lt;2019-04-16&gt; Problem with OpenAI Gym</span></h3>
<p>The OpenAI Gym<a href="#fn74" class="footnote-ref" id="fnref74"><sup>74</sup></a> overrepresents connectionists and underrepresents symbolists.</p>
<h2 id="what-mess"><span class="section_number">13</span><span class="section_title">What mess?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">13.1</span><span class="section_title"><a href="#gospel">Gospel</a></span><span class="word_count">(29w~1m)</span></li>
<li><span class="section_number">13.2</span><span class="section_title"><a href="#alternative-prolog-syntax">Alternative Prolog syntax?</a></span><span class="word_count">(6w~1m)</span></li>
<li><span class="section_number">13.3</span><span class="section_title"><a href="#what-1">What?</a></span><span class="word_count">(85w~1m)</span></li>
<li><span class="section_number">13.4</span><span class="section_title"><a href="#overview">overview</a></span><span class="word_count">(1w~1m)</span></li>
<li><span class="section_number">13.5</span><span class="section_title"><a href="#what-2">what</a></span><span class="word_count">(8w~1m)</span></li>
<li><span class="section_number">13.6</span><span class="section_title"><a href="#what-3">what</a></span><span class="word_count">(1w~1m)</span></li>
<li><span class="section_number">13.7</span><span class="section_title"><a href="#what-4">what</a></span><span class="word_count">(55w~1m)</span></li>
<li><span class="section_number">13.8</span><span class="section_title"><a href="#whaaat">whaaat</a></span><span class="word_count">(12w~1m)</span></li>
<li><span class="section_number">13.9</span><span class="section_title"><a href="#reverse-engineering">Reverse engineering?</a></span><span class="word_count">(34w~1m)</span></li>
<li><span class="section_number">13.10</span><span class="section_title"><a href="#prolog-somewhat-object-oriented-mapping-from-java-to-prolog">Prolog, somewhat object-oriented, mapping from Java to Prolog</a></span><span class="word_count">(48w~1m)</span></li>
<li><span class="section_number">13.11</span><span class="section_title"><a href="#what-99-prolog-problems">What? 99 Prolog problems?</a></span><span class="word_count">(23w~1m)</span></li>
<li><span class="section_number">13.12</span><span class="section_title"><a href="#difference-lists">Difference lists</a></span><span class="word_count">(66w~1m)</span></li>
<li><span class="section_number">13.13</span><span class="section_title"><a href="#how-do-we-make-sense-of-this-counterintuitive-module-syntax">&lt;2018-10-20&gt; How do we make sense of this counterintuitive module syntax?</a></span><span class="word_count">(11w~1m)</span></li>
<li><span class="section_number">13.14</span><span class="section_title"><a href="#discover-the-wonderful-world-of-prolog-logic-programming-relational-programming">Discover the wonderful world of Prolog / logic programming / relational programming</a></span><span class="word_count">(79w~1m)</span></li>
<li><span class="section_number">13.15</span><span class="section_title"><a href="#making-compilers">Making compilers</a></span><span class="word_count">(20w~1m)</span></li>
<li><span class="section_number">13.16</span><span class="section_title"><a href="#declarative-programming-languages">Declarative programming languages</a></span><span class="word_count">(30w~1m)</span></li>
<li><span class="section_number">13.17</span><span class="section_title"><a href="#speculative">Speculative</a></span><span class="word_count">(4w~1m)</span></li>
<li><span class="section_number">13.18</span><span class="section_title"><a href="#resources-for-beginners">Resources for beginners?</a></span><span class="word_count">(11w~1m)</span></li>
<li><span class="section_number">13.19</span><span class="section_title"><a href="#resources-not-for-beginners">Resources not for beginners</a></span><span class="word_count">(122w~1m)</span></li>
<li><span class="section_number">13.20</span><span class="section_title"><a href="#what-5">What?</a></span><span class="word_count">(583w~3m)</span></li>
<li><span class="section_number">13.21</span><span class="section_title"><a href="#the-things-we-have-to-know">The things we have to know</a></span><span class="word_count">(105w~1m)</span></li>
<li><span class="section_number">13.22</span><span class="section_title"><a href="#drafts-and-archives-of-my-correspondence-with-the-prolog-community">Drafts and archives of my correspondence with the Prolog community</a></span><span class="word_count">(150w~1m)</span></li>
<li><span class="section_number">13.23</span><span class="section_title"><a href="#discourse-is-interesting">Discourse is interesting</a></span><span class="word_count">(31w~1m)</span></li>
<li><span class="section_number">13.24</span><span class="section_title"><a href="#unread">Unread</a></span><span class="word_count">(107w~1m)</span></li>
<li><span class="section_number">13.25</span><span class="section_title"><a href="#reverse-engineering-with-prolog">Reverse engineering with Prolog</a></span><span class="word_count">(19w~1m)</span></li>
<li><span class="section_number">13.26</span><span class="section_title"><a href="#teachers-who-cant-teach-shouldnt-teach-lest-they-condemn-students-to-hatred">Teachers who can't teach shouldn't teach, lest they condemn students to hatred</a></span><span class="word_count">(54w~1m)</span></li>
<li><span class="section_number">13.27</span><span class="section_title"><a href="#reason-for-distinguishing-atoms-and-zero-arity-compound-terms">Reason for distinguishing atoms and zero-arity compound terms</a></span><span class="word_count">(28w~1m)</span></li>
<li><span class="section_number">13.28</span><span class="section_title"><a href="#kowalski-1992-legislation-as-logic-programs">Kowalski 1992 &quot;Legislation as Logic Programs&quot;</a></span><span class="word_count">(6w~1m)</span></li>
</ul>
</div>
<h3 id="gospel"><span class="section_number">13.1</span><span class="section_title">Gospel</span></h3>
<p>If everyone could be 20x more productive using Prolog, then it is a sin to let them use Java or C++. It is a massive waste of human life.</p>
<h3 id="alternative-prolog-syntax"><span class="section_number">13.2</span><span class="section_title">Alternative Prolog syntax?</span></h3>
<p>Curry/ML-like syntax for Prolog?</p>
<pre class="example"><code>append([],B,B).
append([H|A], B, [H|C]) :- append(A,B,C).

append [] B B.
append [H|A] B [H|C] :- append A B C.
</code></pre>
<h3 id="what-1"><span class="section_number">13.3</span><span class="section_title">What?</span></h3>
<p>Prolog web browser, prolog gui, prolog operating system, prolog system f, normal-order lambda calculus, Haskell in prolog</p>
<p>Prolog to glue Haskell, racket, typescript</p>
<p>&quot;adding a search Path in SWI prolog&quot; <a href="https://stackoverflow.com/questions/6334050/adding-a-search-path-in-swi-prolog">https://stackoverflow.com/questions/6334050/adding-a-search-path-in-swi-prolog</a></p>
<p>&quot;The Mess We're In&quot; by Joe Armstrong&quot; <a href="https://www.youtube.com/watch?v=lKXe3HUG2l4">https://www.youtube.com/watch?v=lKXe3HUG2l4</a> 43:20 We assume that two files A and B are similar if size(compress(A)) is similar to size(compress(A++B)).</p>
<p>decompilation, reverse engineering</p>
<p>&quot;J.P. Bowen, From Programs to Object Code and Back Again Using Logic Programming: Compilation and Decompilation, Journal of Software Maintenance: Research and Practice, Vol. 5, No. 4, pp.205-234, December, 1993&quot; <a href="https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/compiler2.html">https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/compiler2.html</a></p>
<h3 id="overview"><span class="section_number">13.4</span><span class="section_title">overview</span></h3>
<p><a href="https://www.ajibot.com/blog/overview-of-logic-languages">https://www.ajibot.com/blog/overview-of-logic-languages</a></p>
<h3 id="what-2"><span class="section_number">13.5</span><span class="section_title">what</span></h3>
<p>Prolog clpq documentation doesn't mention multivariate optimization? <a href="https://stackoverflow.com/questions/27716598/constraint-values-on-local-variable">https://stackoverflow.com/questions/27716598/constraint-values-on-local-variable</a></p>
<p><a href="http://www.amzi.com/manuals/amzi/pro/ref_execution.htm">http://www.amzi.com/manuals/amzi/pro/ref_execution.htm</a></p>
<p><a href="http://users.cs.cf.ac.uk/O.F.Rana/prolog/lectureP5/node3.html">http://users.cs.cf.ac.uk/O.F.Rana/prolog/lectureP5/node3.html</a></p>
<p><a href="https://coderwall.com/p/laduzw/how-to-measure-execution-time-in-swi-prolog">https://coderwall.com/p/laduzw/how-to-measure-execution-time-in-swi-prolog</a></p>
<p><a href="https://www.reddit.com/r/prolog/comments/9mxhbw/the_art_of_prolog_second_edition_is_available_as/">https://www.reddit.com/r/prolog/comments/9mxhbw/the_art_of_prolog_second_edition_is_available_as/</a></p>
<p><a href="http://www.swi-prolog.org/pldoc/man?section=modes">http://www.swi-prolog.org/pldoc/man?section=modes</a></p>
<h3 id="what-3"><span class="section_number">13.6</span><span class="section_title">what</span></h3>
<p><a href="http://dbs.informatik.uni-halle.de/Lehre/LP09/c3_purep.pdf">http://dbs.informatik.uni-halle.de/Lehre/LP09/c3_purep.pdf</a></p>
<p><a href="http://fsl.cs.illinois.edu/images/9/9c/PrologStandard.pdf">http://fsl.cs.illinois.edu/images/9/9c/PrologStandard.pdf</a></p>
<h3 id="what-4"><span class="section_number">13.7</span><span class="section_title">what</span></h3>
<p>Read &quot;The art of Prolog&quot;, second-order programming,</p>
<p><a href="https://stackoverflow.com/questions/32835086/prolog-how-to-avoid-backtracking-without-cuts">https://stackoverflow.com/questions/32835086/prolog-how-to-avoid-backtracking-without-cuts</a></p>
<p>Now I know this is false:</p>
<ul>
<li>Relational programming subsumes functional programming.
<ul>
<li>Functional programming is a special case of relational programming.</li>
<li>Every function is a relation.</li>
</ul></li>
</ul>
<p>Functional programming is more concise and readable than logic (relational?) programming when we are describing functions:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb92-1" title="1">fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb92-2" title="2">fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb92-3" title="3">fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)</a></code></pre></div>
<div class="sourceCode" id="cb93"><pre class="sourceCode prolog"><code class="sourceCode prolog"><a class="sourceLine" id="cb93-1" title="1">fib(<span class="dv">0</span><span class="kw">,</span><span class="dv">1</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb93-2" title="2">fib(<span class="dv">1</span><span class="kw">,</span><span class="dv">1</span>)<span class="kw">.</span></a>
<a class="sourceLine" id="cb93-3" title="3">fib(<span class="dt">N</span><span class="kw">,</span><span class="dt">F</span>) <span class="kw">:-</span> <span class="dt">N1</span> <span class="dt">is</span> <span class="dt">N</span><span class="dv">-1</span><span class="kw">,</span> <span class="dt">N2</span> <span class="dt">is</span> <span class="dt">N</span><span class="dv">-2</span><span class="kw">,</span> fib(<span class="dt">N1</span><span class="kw">,</span><span class="dt">F1</span>)<span class="kw">,</span> fib(<span class="dt">N2</span><span class="kw">,</span><span class="dt">F2</span>)<span class="kw">,</span> <span class="dt">F</span> <span class="dt">is</span> <span class="dt">F1+F2</span><span class="kw">.</span></a></code></pre></div>
<p>But we can translate a function to a deterministic (det) predicate in Prolog.</p>
<h3 id="whaaat"><span class="section_number">13.8</span><span class="section_title">whaaat</span></h3>
<p>This marshallp guy is… inhuman? He uses Prolog for note taking! <a href="https://news.ycombinator.com/item?id=1142292">https://news.ycombinator.com/item?id=1142292</a></p>
<h3 id="reverse-engineering"><span class="section_number">13.9</span><span class="section_title">Reverse engineering?</span></h3>
<ul>
<li>1992 &quot;A Logic-Based Approach to Reverse Engineering Tools Production&quot;</li>
</ul>
<p><a href="https://pdfs.semanticscholar.org/4882/9fd716349ff586e21e9277890989daa0e916.pdf">https://pdfs.semanticscholar.org/4882/9fd716349ff586e21e9277890989daa0e916.pdf</a></p>
<p>Prolog-COBOL stuff</p>
<ul>
<li>1991, Using Prolog for Reverse-Engineering and Validation</li>
</ul>
<p><a href="http://www.academia.edu/2493008/Using_Prolog_for_reverse-engineering_and_validation">http://www.academia.edu/2493008/Using_Prolog_for_reverse-engineering_and_validation</a></p>
<ul>
<li>1994, &quot;Reverse Engineering of COBOL Programs into Prolog Programs&quot;</li>
</ul>
<p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.5073&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.5073&amp;rep=rep1&amp;type=pdf</a></p>
<ul>
<li>1992, &quot;The Art of Computer Un-Programming: Reverse Engineering in Prolog&quot;</li>
</ul>
<p><a href="http://www.academia.edu/1413561/The_art_of_computer_un-programming_Reverse_engineering_in_Prolog">http://www.academia.edu/1413561/The_art_of_computer_un-programming_Reverse_engineering_in_Prolog</a></p>
<ul>
<li><a href="https://link.springer.com/chapter/10.1007/3-540-55930-2_20">https://link.springer.com/chapter/10.1007/3-540-55930-2_20</a></li>
</ul>
<p><a href="http://www.academia.edu/1413561/The_art_of_computer_un-programming_Reverse_engineering_in_Prolog">http://www.academia.edu/1413561/The_art_of_computer_un-programming_Reverse_engineering_in_Prolog</a></p>
<h3 id="prolog-somewhat-object-oriented-mapping-from-java-to-prolog"><span class="section_number">13.10</span><span class="section_title">Prolog, somewhat object-oriented, mapping from Java to Prolog</span></h3>
<p>Prior arts: 2017 &quot;Mapping Objects to Persistent Predicates&quot; <a href="https://pdfs.semanticscholar.org/f1ec/9e0e24faa1332d0cb60149e1d633b8d2509e.pdf">https://pdfs.semanticscholar.org/f1ec/9e0e24faa1332d0cb60149e1d633b8d2509e.pdf</a></p>
<p><a href="http://ceur-ws.org/Vol-274/paper6.pdf">http://ceur-ws.org/Vol-274/paper6.pdf</a></p>
<p>Every Java class instantiation expression becomes a Prolog compound.</p>
<pre class="example"><code>% From Java expression: new Class_name(field_1, field_n)
class_name(Field_1, ..., Field_N)
</code></pre>
<p>Every Java class instantiation statement becomes a Prolog fact.</p>
<pre class="example"><code>% From Java statement: Class_name instance_name = new Class_name(field_1, field_n)
Class_name(Instance_name, Field_1, ..., Field_N).
</code></pre>
<p>Example 2010 &quot;Simulating BPMN Models with Prolog&quot;</p>
<pre class="example"><code>final class Car {
    final String brand;
    final int year;
    // constructor omitted
}

Car a_car = new Car(&quot;Toyota&quot;, 2000);
</code></pre>
<p>becomes</p>
<pre class="example"><code>car(a_car, [brand(&#39;Toyota&#39;), year(2000)]).
% or
car(a_car, &#39;Toyota&#39;, 2000).
% or
car(a_car, car(&#39;Toyota&#39;, 2000)).
</code></pre>
<p>Large-scale Prolog? 1991 &quot;Efficient Access To Large Prolog Knowledge Bases&quot; <a href="https://link.springer.com/chapter/10.1007/978-3-7091-7555-2_26">https://link.springer.com/chapter/10.1007/978-3-7091-7555-2_26</a></p>
<h3 id="what-99-prolog-problems"><span class="section_number">13.11</span><span class="section_title">What? 99 Prolog problems?</span></h3>
<p>There is the <a href="http://www.ic.unicamp.br/~meidanis/courses/problemas-prolog/">99 Prolog problems</a>. But what if you we are not undergraduate students with too much free time?</p>
<h3 id="difference-lists"><span class="section_number">13.12</span><span class="section_title">Difference lists</span></h3>
<ul>
<li>Who invented difference lists when?</li>
</ul>
<p>A &quot;difference list&quot; is a term of the form <code>A - B</code> where <code>A</code> is a list and <code>B</code> is a list.</p>
<p>A difference list represents a list.</p>
<p>The difference list <code>A - []</code> represents the list <code>A</code>.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Difference_list">https://en.wikipedia.org/wiki/Difference_list</a></li>
<li><a href="https://en.wikibooks.org/wiki/Prolog/Difference_Lists">https://en.wikibooks.org/wiki/Prolog/Difference_Lists</a>
<ul>
<li>Difference list has constant-time append. Ordinary list has linear-time append.</li>
</ul></li>
<li><a href="https://wiki.haskell.org/Difference_list">https://wiki.haskell.org/Difference_list</a>
<ul>
<li>&quot;Whether this kind of difference list is more efficient than another list representations depends on usage patterns.&quot;</li>
</ul></li>
<li><a href="http://homepages.inf.ed.ac.uk/pbrna/prologbook/node180.html">http://homepages.inf.ed.ac.uk/pbrna/prologbook/node180.html</a></li>
</ul>
<h3 id="how-do-we-make-sense-of-this-counterintuitive-module-syntax"><span class="section_number">13.13</span><span class="section_title">&lt;2018-10-20&gt; How do we make sense of this counterintuitive module syntax?</span></h3>
<ul>
<li><a href="https://stackoverflow.com/questions/42399020/how-to-get-a-listing-of-a-specific-knowledge-base">https://stackoverflow.com/questions/42399020/how-to-get-a-listing-of-a-specific-knowledge-base</a></li>
</ul>
<h3 id="discover-the-wonderful-world-of-prolog-logic-programming-relational-programming"><span class="section_number">13.14</span><span class="section_title">Discover the wonderful world of Prolog / logic programming / relational programming</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">13.14.1</span><span class="section_title"><a href="#symbolic-ai-is-the-easiest-ai-approach.">Symbolic AI is the easiest AI approach.</a></span><span class="word_count">(53w~1m)</span></li>
<li><span class="section_number">13.14.2</span><span class="section_title"><a href="#dreams">Dreams</a></span><span class="word_count">(16w~1m)</span></li>
</ul>
</div>
<h4 id="symbolic-ai-is-the-easiest-ai-approach."><span class="section_number">13.14.1</span><span class="section_title">Symbolic AI is the easiest AI approach.</span></h4>
<ul>
<li>Connectionist AI (neural networks) excels at tasks that are difficult to describe in formal logic.</li>
<li>Symbolic AI (Prolog) is much more understandable and predictable than connectionist AI.
<ul>
<li>Understanding connectionist AI requires probability, statistics, and real analysis.</li>
</ul></li>
<li>Why not both? 2017 article &quot;SLDR-DL: A Framework for SLD-Resolution with Deep Learning&quot; <a href="https://arxiv.org/pdf/1705.02210.pdf">https://arxiv.org/pdf/1705.02210.pdf</a>?</li>
</ul>
<h4 id="dreams"><span class="section_number">13.14.2</span><span class="section_title">Dreams</span></h4>
<ul>
<li>offload/scale/formalize thinking/cognition</li>
<li>transform reasoning into data entry</li>
<li>brain prosthetics; cognitive prosthetics</li>
<li>Leibniz, &quot;Let us calculate!&quot;, calculus ratiocinator
<ul>
<li><a href="https://en.wikipedia.org/wiki/Calculus_ratiocinator">https://en.wikipedia.org/wiki/Calculus_ratiocinator</a></li>
<li><a href="https://publicdomainreview.org/2016/11/10/let-us-calculate-leibniz-llull-and-computational-imagination/">https://publicdomainreview.org/2016/11/10/let-us-calculate-leibniz-llull-and-computational-imagination/</a></li>
</ul></li>
<li>probabilistic logic programming</li>
<li><a href="https://softwareengineering.stackexchange.com/questions/275680/the-dream-of-declarative-programming">https://softwareengineering.stackexchange.com/questions/275680/the-dream-of-declarative-programming</a></li>
</ul>
<h3 id="making-compilers"><span class="section_number">13.15</span><span class="section_title">Making compilers</span></h3>
<ul>
<li><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/9em9jf/future_directions_for_optimizing_compilers/">https://www.reddit.com/r/ProgrammingLanguages/comments/9em9jf/future_directions_for_optimizing_compilers/</a>
<ul>
<li>&quot;Future Directions for Optimizing Compilers&quot; <a href="https://arxiv.org/abs/1809.02161">https://arxiv.org/abs/1809.02161</a></li>
</ul></li>
</ul>
<p>&quot;Universal-transpiler&quot; may be similar to what we want.</p>
<ul>
<li>&quot;Universal-transpiler&quot;
<ul>
<li><a href="https://github.com/jarble/transpiler">https://github.com/jarble/transpiler</a>
<ul>
<li>it also has links to similar projects</li>
</ul></li>
<li><a href="http://www.swi-prolog.org/pack/list?p=transpiler">http://www.swi-prolog.org/pack/list?p=transpiler</a></li>
</ul></li>
</ul>
<h3 id="declarative-programming-languages"><span class="section_number">13.16</span><span class="section_title">Declarative programming languages</span></h3>
<p><a href="http://www.cse.chalmers.se/~oloft/Papers/wm96/node2.html">Declarative Programming Languages</a>, functional logic programming, two ways it is done (narrowing and residuation); definitional programming, GCLA language (separate definition and control)</p>
<ul>
<li>1995, &quot;Functional Logic Programming in GCLA&quot;, <a href="http://www.cse.chalmers.se/~oloft/Papers/wm95.pdf">pdf</a></li>
</ul>
<h3 id="speculative"><span class="section_number">13.17</span><span class="section_title">Speculative</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">13.17.1</span><span class="section_title"><a href="#fast-logic-programming">Fast logic programming?</a></span><span class="word_count">(3w~1m)</span></li>
<li><span class="section_number">13.17.2</span><span class="section_title"><a href="#lambda-prolog">Lambda-prolog?</a></span><span class="word_count">(2w~1m)</span></li>
</ul>
</div>
<h4 id="fast-logic-programming"><span class="section_number">13.17.1</span><span class="section_title">Fast logic programming?</span></h4>
<ul>
<li><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/9fgv3v/can_logic_programming_execute_as_fast_as/">https://www.reddit.com/r/ProgrammingLanguages/comments/9fgv3v/can_logic_programming_execute_as_fast_as/</a>
<ul>
<li><a href="https://www.info.ucl.ac.be/~pvr/Peter.thesis/Peter.thesis.html">https://www.info.ucl.ac.be/~pvr/Peter.thesis/Peter.thesis.html</a></li>
</ul></li>
<li><a href="https://stackoverflow.com/questions/23711790/comparision-of-abstract-machines-for-execution-of-prolog">https://stackoverflow.com/questions/23711790/comparision-of-abstract-machines-for-execution-of-prolog</a></li>
</ul>
<h4 id="lambda-prolog"><span class="section_number">13.17.2</span><span class="section_title">Lambda-prolog?</span></h4>
<ul>
<li>lambda-prolog <a href="http://www.lix.polytechnique.fr/~dale/lProlog/">http://www.lix.polytechnique.fr/~dale/lProlog/</a></li>
</ul>
<h3 id="resources-for-beginners"><span class="section_number">13.18</span><span class="section_title">Resources for beginners?</span></h3>
<ul>
<li>&quot;Real World Programming in SWI-Prolog&quot;<a href="#fn75" class="footnote-ref" id="fnref75"><sup>75</sup></a></li>
<li>&quot;Frequently Asked Questions for ##Prolog&quot;<a href="#fn76" class="footnote-ref" id="fnref76"><sup>76</sup></a></li>
</ul>
<h3 id="resources-not-for-beginners"><span class="section_number">13.19</span><span class="section_title">Resources not for beginners</span></h3>
<ul>
<li>1990 book &quot;The craft of Prolog&quot; by Richard A. O'Keefe
<ul>
<li>from the preface: &quot;There are a lot of introductory Prolog books around. This is not one of them. Think of it as &quot;second steps in Prolog&quot;. If you have already read one of the introductory books, if you have taken an introductory course on Prolog, if you have written one or two Prolog programs, and if you are wondering why it is still hard to writegood Prolog programs, this book is meant to help you. The purpose of the book is to show you how you can write Prolog programs that work, that don't take an unreasonable amount of time, and that are clean enough to show to your friends.&quot;</li>
</ul></li>
</ul>
<h3 id="what-5"><span class="section_number">13.20</span><span class="section_title">What?</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">13.20.1</span><span class="section_title"><a href="#what-are-these-trying-to-say">What are these trying to say?</a></span><span class="word_count">(156w~1m)</span></li>
<li><span class="section_number">13.20.2</span><span class="section_title"><a href="#books">Books?</a></span><span class="word_count">(428w~3m)</span></li>
</ul>
</div>
<h4 id="what-are-these-trying-to-say"><span class="section_number">13.20.1</span><span class="section_title">What are these trying to say?</span></h4>
<ul>
<li>1991 article &quot;Logic Programming, Functional Programming, and Inductive Definitions&quot; <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-205.pdf">https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-205.pdf</a>
<ul>
<li>&quot;The unification of logic and functional programming, like the Holy Grail, is sought by countless people&quot;</li>
<li>&quot;More generally, we suggest that the traditional paradigm — logic programming as first-order logic — is seriously out of step with practice. We offer an alternative paradigm. We view the logic program as an <em>inductive definition</em> of sets and relations.&quot;</li>
<li>&quot;To justify the Closed World Assumption, we propose that logic programs should be viewed as inductive definitions, not as first-order theories. Some people refuse to abandon the dream of programming in first-order logic. But we have to ask whether this dream is possible — even whether it is desirable. The first-order paradigm does not deal adequately with negation in databases, and seems to be an unreliable guide in research on program correctness and language design. Inductive definitions are more fundamental than first-order logic, and perhaps easier to understand.&quot;</li>
</ul></li>
</ul>
<h4 id="books"><span class="section_number">13.20.2</span><span class="section_title">Books?</span></h4>
<ul>
<li>1995 book &quot;Prolog Programming in Depth&quot; <a href="http://www.lsv.fr/~reichert/Enseignement/2012/PPL/Prolog_Programming_In_Depth.pdf">http://www.lsv.fr/~reichert/Enseignement/2012/PPL/Prolog_Programming_In_Depth.pdf</a>
<ul>
<li>1.16 Styles of encoding knowledge, p. 28
<ul>
<li>parent, male, female vs. father, mother</li>
<li>&quot;Which style is computationally more efficient depends on the kinds of queries to be answered.&quot;</li>
<li>&quot;Unlike other knowledge representation languages, Prolog does not force the knowledge base builder to state information in a particular logical style. Information can be entered in whatever form is most convenient, and then appropriate rules can be added to retrieve the information in a different form.&quot;</li>
<li>&quot;We could use a 'data-record' format to encode the family tree like [person(Name,Sex,Father,Mother)]&quot;
<ul>
<li>&quot;The only advantage of this style is that the multi-argument facts are often easy to generate from conventional databases, by simply printing out the data in a format that conforms to Prolog syntax.&quot;</li>
</ul></li>
</ul></li>
<li>5.12 Grand Finale: Reading a Lotus Spreadsheet, p. 148</li>
<li>5.13 Language and Metalanguage, p. 153
<ul>
<li>&quot;A Prolog program can extend and modify the inference engine that controls program execution. Thus, the language can change itself in ways that go beyond superficial syntax.&quot;
<ul>
<li>Really? How?</li>
</ul></li>
</ul></li>
<li>5.17 Intensional and Extensional Queries, p. 159</li>
<li>5.19 Giving Meaning to Operators, p. 163
<ul>
<li>&quot;How to make the ampersand mean 'and' in Prolog&quot;</li>
</ul></li>
<li>5.20 Prolog in Prolog, p. 165
<ul>
<li>&quot;Meta-interpreter for Prolog&quot;</li>
</ul></li>
<li>5.21 Extending the inference engine, p. 167
<ul>
<li>biconditionals</li>
</ul></li>
<li>11 Defeasible Prolog, p. 347
<ul>
<li>11.1 Nonmonotonic reasoning and Prolog, p. 347
<ul>
<li>&quot;If our reasoning is monotonic, the set of conclusions we draw from the information we have only gets larger as we get more and more information. Once we reach a conclusion, no additional information will cause us to reject it. When our reasoning is nonmonotonic, we may reject an earlier conclusion on the basis of new information.&quot;</li>
<li>&quot;Human reasoning is notoriously nonmonotonic. We make plans based on what we expect to happen, but we constantly revise our expectations, and our plans, as events unfold.&quot;</li>
<li>&quot;The Prolog inference engine is nonmonotonic because of the way it handles negation.&quot;</li>
<li>Why is &quot;defeasible&quot; not spelled &quot;defeatable&quot;?</li>
</ul></li>
<li>11.2 New syntax for defeasible reasoning, p. 348
<ul>
<li>&quot;Although Prolog can perform some kinds of nonmonotonic reasoning, Prolog rules are not defeasible.&quot;</li>
<li>&quot;Some instances of defeasible reasoning cannot be reproduced in ordinary Prolog.&quot;</li>
<li>&quot;What we need is a new way to represent defeasible rules and presumptions and an inference engine that knows how to use them. We also need a negation operator that is different from negation-as-failure so we can represent rules that tell us when something is positively not the case rather than just that we cannot <em>prove</em> that it is the case. These negative rules are needed to tell us when we have an exception to a defeasible rule, but they are desirable in their own right as well.&quot;
<ul>
<li>The second sentence is too long.</li>
</ul></li>
</ul></li>
<li>(I haven't read it.)</li>
</ul></li>
</ul></li>
</ul>
<h3 id="the-things-we-have-to-know"><span class="section_number">13.21</span><span class="section_title">The things we have to know</span></h3>
<p>This chapter should not exist. The users have to know these, but when should we introduce these topics?</p>
<ul>
<li>operational semantics: how the Prolog program actually runs: depth-first search (brute force)</li>
<li>how to get unstuck</li>
</ul>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">13.21.1</span><span class="section_title"><a href="#some-greek-words-used-in-philosophy-and-programming">Some Greek words used in philosophy and programming</a></span><span class="word_count">(33w~1m)</span></li>
<li><span class="section_number">13.21.2</span><span class="section_title"><a href="#modules">Modules?</a></span><span class="word_count">(28w~1m)</span></li>
<li><span class="section_number">13.21.3</span><span class="section_title"><a href="#equalities-and-equivalences">Equalities and equivalences?</a></span><span class="word_count">(10w~1m)</span></li>
</ul>
</div>
<h4 id="some-greek-words-used-in-philosophy-and-programming"><span class="section_number">13.21.1</span><span class="section_title">Some Greek words used in philosophy and programming</span></h4>
<p>&quot;ontos&quot; is &quot;(of) being&quot;.</p>
<p>&quot;episteme&quot; is &quot;knowledge&quot;.</p>
<p>&quot;logos&quot; is &quot;word&quot;, &quot;theory&quot;.</p>
<p>Thus, &quot;ontology&quot; is &quot;theory of being&quot;, and &quot;epistemology&quot; is &quot;theory of knowledge&quot;. They are two branches of philosophy.</p>
<h4 id="modules"><span class="section_number">13.21.2</span><span class="section_title">Modules?</span></h4>
<p>Prolog syntax for use_module is documented in <a href="http://www.swi-prolog.org/FAQ/LoadLibrary.html">LoadLibrary FAQ</a>, not in the documentation for use_module/1. The <code>library</code> alias is defined in file_search_path/2.</p>
<p>swipl: use <code>-s</code> instead of <code>-l</code> <a href="http://www.swi-prolog.org/pldoc/man?section=cmdline">http://www.swi-prolog.org/pldoc/man?section=cmdline</a></p>
<h4 id="equalities-and-equivalences"><span class="section_number">13.21.3</span><span class="section_title">Equalities and equivalences?</span></h4>
<p>What is the difference: <code>, ~==~, ~</code>:=~, is</p>
<h3 id="drafts-and-archives-of-my-correspondence-with-the-prolog-community"><span class="section_number">13.22</span><span class="section_title">Drafts and archives of my correspondence with the Prolog community</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">13.22.1</span><span class="section_title"><a href="#avoiding-future-swi-prolog-pack-nightmare">Avoiding future SWI-Prolog pack nightmare</a></span><span class="word_count">(19w~1m)</span></li>
<li><span class="section_number">13.22.2</span><span class="section_title"><a href="#improving-contributor-guide-discoverability">&lt;2019-04-07&gt; Improving contributor guide discoverability</a></span><span class="word_count">(36w~1m)</span></li>
<li><span class="section_number">13.22.3</span><span class="section_title"><a href="#open-source-donation-does-not-work">&lt;2019-04-08&gt; Open-source donation does not work</a></span><span class="word_count">(88w~1m)</span></li>
</ul>
</div>
<h4 id="avoiding-future-swi-prolog-pack-nightmare"><span class="section_number">13.22.1</span><span class="section_title">Avoiding future SWI-Prolog pack nightmare</span></h4>
<p>Semantic Web should be applied to make SWI-Prolog packs searchable and manageable.</p>
<p>SWI-Prolog packs need curation/vetting/testimony/promotion.</p>
<h4 id="improving-contributor-guide-discoverability"><span class="section_number">13.22.2</span><span class="section_title">&lt;2019-04-07&gt; Improving contributor guide discoverability</span></h4>
<p>I wrote<a href="#fn77" class="footnote-ref" id="fnref77"><sup>77</sup></a>:</p>
<blockquote>
<p>The information, the person, and the task must be <em>near to each other in space and time</em>. Ideally, the information is presented right where people need it when they need it.</p>
</blockquote>
<h4 id="open-source-donation-does-not-work"><span class="section_number">13.22.3</span><span class="section_title">&lt;2019-04-08&gt; Open-source donation does not work</span></h4>
<p>Jan Wielemaker on swipl-devel pull-request 459<a href="#fn78" class="footnote-ref" id="fnref78"><sup>78</sup></a>:</p>
<blockquote>
<p>I'd drop donating. We've done that in the past. It is mostly hassle that is nice to buy some infrastructure, but doesn't cover salaries. So far we managed to get the required infra structure sponsored directly.</p>
</blockquote>
<p>Indeed. It's like digital busking. It is extremely simple to throw money physically at physical buskers. But how do we throw money digitally at people? In 2019 digital money donation is so much hassle and so complex that few actually donate money digitally.</p>
<h3 id="discourse-is-interesting"><span class="section_number">13.23</span><span class="section_title">Discourse is interesting</span></h3>
<p>Discourse<a href="#fn79" class="footnote-ref" id="fnref79"><sup>79</sup></a> reputation system is an example of using software to enforce a policy that creates a system that self-heals against attacks.</p>
<p>I should put it in my open-source page somewhere.</p>
<h3 id="unread"><span class="section_number">13.24</span><span class="section_title">Unread</span></h3>
<p>&quot;Here I make use of a feature of the SWI Prolog REPL - prefixing a variable with $ will use the value that was assigned to that variable in a previous REPL command.&quot; <a href="https://bluishcoder.co.nz/2018/09/24/concurrent-and-distributed-programming-in-web-prolog.html">https://bluishcoder.co.nz/2018/09/24/concurrent-and-distributed-programming-in-web-prolog.html</a></p>
<p>&quot;Notes for a Tutorial on Abstract Interpretation of Logic Programs&quot; <a href="https://www.reddit.com/r/prolog/comments/98cqie/notes_for_a_tutorial_on_abstract_interpretation/">https://www.reddit.com/r/prolog/comments/98cqie/notes_for_a_tutorial_on_abstract_interpretation/</a></p>
<p>&quot;Prolog and the Database Of The Future&quot; <a href="https://www.reddit.com/r/prolog/comments/99xwue/prolog_and_the_database_of_the_future/">https://www.reddit.com/r/prolog/comments/99xwue/prolog_and_the_database_of_the_future/</a></p>
<p>&quot;fizz: an experimental language/runtime for cognitive architectures (version 0.4)&quot; <a href="https://www.reddit.com/r/prolog/comments/9c5evc/fizz_an_experimental_languageruntime_for/">https://www.reddit.com/r/prolog/comments/9c5evc/fizz_an_experimental_languageruntime_for/</a></p>
<p>&quot;A Data-parallel Implementation of Prolog: : a simple model for parallel execution suitably restricted to guarantee efficient parallel execution&quot; <a href="https://www.reddit.com/r/prolog/comments/9cbqj0/a_dataparallel_implementation_of_prolog_a_simple/">https://www.reddit.com/r/prolog/comments/9cbqj0/a_dataparallel_implementation_of_prolog_a_simple/</a></p>
<p>&quot;Reform Prolog is an (dependent) AND-parallel system based on recursion parallelism and Reform compilation.&quot; <a href="https://www.reddit.com/r/prolog/comments/9ceohz/reform_prolog_the_language_and_its_implementation/">https://www.reddit.com/r/prolog/comments/9ceohz/reform_prolog_the_language_and_its_implementation/</a></p>
<p><a href="https://www.reddit.com/r/prolog/new/">https://www.reddit.com/r/prolog/new/</a></p>
<p>1997 &quot;FAQ: Prolog Resource Guide 1/2 [Monthly posting]&quot; Where is the most recent version? <a href="http://www.faqs.org/faqs/prolog/resource-guide/part1/index.html">http://www.faqs.org/faqs/prolog/resource-guide/part1/index.html</a></p>
<h3 id="reverse-engineering-with-prolog"><span class="section_number">13.25</span><span class="section_title">Reverse engineering with Prolog</span></h3>
<p>&quot;Using Logic Programming to Recover C++ Classes and Methods from Compiled Executables. They use XSB Prolog&quot;<a href="#fn80" class="footnote-ref" id="fnref80"><sup>80</sup></a><a href="#fn81" class="footnote-ref" id="fnref81"><sup>81</sup></a></p>
<h3 id="teachers-who-cant-teach-shouldnt-teach-lest-they-condemn-students-to-hatred"><span class="section_number">13.26</span><span class="section_title">Teachers who can't teach shouldn't teach, lest they condemn students to hatred</span></h3>
<p>People hate math because they are unfortunate enough to be taught by teachers who can't teach.</p>
<p>People hate Prolog because they are unfortunate enough to be taught by teachers who can't teach.</p>
<p>Those students grow up to be adults with atrophied minds condemned to mediocrity.</p>
<h3 id="reason-for-distinguishing-atoms-and-zero-arity-compound-terms"><span class="section_number">13.27</span><span class="section_title">Reason for distinguishing atoms and zero-arity compound terms</span></h3>
<p>Such separation helps us write a language interpreter in which <code>foo</code> means a variable value and <code>foo()</code> means a function call.</p>
<h3 id="kowalski-1992-legislation-as-logic-programs"><span class="section_number">13.28</span><span class="section_title">Kowalski 1992 &quot;Legislation as Logic Programs&quot;</span></h3>
<p><a href="https://www.doc.ic.ac.uk/~rak/papers/law.pdf">https://www.doc.ic.ac.uk/~rak/papers/law.pdf</a></p>
<h2 id="rethinking-module-systems-especially-of-prolog"><span class="section_number">14</span><span class="section_title">Rethinking module systems, especially of Prolog</span></h2>
<p>Miller 1986 <span class="citation" data-cites="miller1986theory">[<a href="#ref-miller1986theory">17</a>]</span> has what we want: implication as local scoping.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">14.1</span><span class="section_title"><a href="#what-are-the-problems-of-existing-module-systems">What are the problems of existing module systems?</a></span><span class="word_count">(27w~1m)</span></li>
<li><span class="section_number">14.2</span><span class="section_title"><a href="#what-problems-are-modules-trying-to-solve">What problems are modules trying to solve?</a></span><span class="word_count">(614w~4m)</span></li>
<li><span class="section_number">14.3</span><span class="section_title"><a href="#how-should-modules-and-meta-predicates-interact">How should modules and meta-predicates interact?</a></span><span class="word_count">(173w~1m)</span></li>
<li><span class="section_number">14.4</span><span class="section_title"><a href="#designing-the-module-system">Designing the module system</a></span><span class="word_count">(821w~5m)</span></li>
<li><span class="section_number">14.5</span><span class="section_title"><a href="#organizing-and-loading-prolog-source-files-without-name-clashes">Organizing and loading Prolog source files without name clashes</a></span><span class="word_count">(202w~2m)</span></li>
<li><span class="section_number">14.6</span><span class="section_title"><a href="#from-module.md-designing-module-systems">from module.md (Designing module systems)</a></span><span class="word_count">(908w~5m)</span></li>
<li><span class="section_number">14.7</span><span class="section_title"><a href="#the-implementation-draft-a-clash-free-module-system">&lt;2019-04-02&gt; The implementation? Draft: A clash-free module system</a></span><span class="word_count">(476w~3m)</span></li>
<li><span class="section_number">14.8</span><span class="section_title"><a href="#implementing-modules">Implementing modules</a></span><span class="word_count">(259w~2m)</span></li>
<li><span class="section_number">14.9</span><span class="section_title"><a href="#brain-dumps">Brain dumps</a></span><span class="word_count">(8w~1m)</span></li>
<li><span class="section_number">14.10</span><span class="section_title"><a href="#operators-and-adaptive-grammar">Operators and adaptive grammar</a></span><span class="word_count">(123w~1m)</span></li>
</ul>
</div>
<h3 id="what-are-the-problems-of-existing-module-systems"><span class="section_number">14.1</span><span class="section_title">What are the problems of existing module systems?</span></h3>
<p>A module system is often an afterthought to a core language.<span class="citation" data-cites="miller2012programming">[<a href="#ref-miller2012programming">18</a>]</span></p>
<p>Chapter 6 of <span class="citation" data-cites="miller2012programming">[<a href="#ref-miller2012programming">18</a>]</span> contains a desiderata for module systems.</p>
<h3 id="what-problems-are-modules-trying-to-solve"><span class="section_number">14.2</span><span class="section_title">What problems are modules trying to solve?</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">14.2.1</span><span class="section_title"><a href="#two-problems-that-modules-are-trying-to-solve">Two problems that modules are trying to solve</a></span><span class="word_count">(64w~1m)</span></li>
<li><span class="section_number">14.2.2</span><span class="section_title"><a href="#modules-are-for-humans">Modules are for humans</a></span><span class="word_count">(48w~1m)</span></li>
<li><span class="section_number">14.2.3</span><span class="section_title"><a href="#why-do-name-clashes-happen">Why do name clashes happen?</a></span><span class="word_count">(34w~1m)</span></li>
<li><span class="section_number">14.2.4</span><span class="section_title"><a href="#how-does-name-clashes-happen">How does name clashes happen?</a></span><span class="word_count">(5w~1m)</span></li>
<li><span class="section_number">14.2.5</span><span class="section_title"><a href="#the-key-of-avoiding-name-clashes-things-should-not-name-themselves">The key of avoiding name clashes: Things should not name themselves</a></span><span class="word_count">(116w~1m)</span></li>
<li><span class="section_number">14.2.6</span><span class="section_title"><a href="#how-do-module-systems-arise">How do module systems arise?</a></span><span class="word_count">(50w~1m)</span></li>
<li><span class="section_number">14.2.7</span><span class="section_title"><a href="#secondary-uses-of-modules">Secondary uses of modules</a></span><span class="word_count">(115w~1m)</span></li>
<li><span class="section_number">14.2.8</span><span class="section_title"><a href="#modules-as-protection-of-internals">Modules as protection of internals?</a></span><span class="word_count">(108w~1m)</span></li>
<li><span class="section_number">14.2.9</span><span class="section_title"><a href="#what-are-hardware-modules">What are hardware modules?</a></span><span class="word_count">(73w~1m)</span></li>
<li><span class="section_number">14.2.10</span><span class="section_title"><a href="#ciao-prolog-module-system">Ciao Prolog module system?</a></span><span class="word_count">(4w~1m)</span></li>
</ul>
</div>
<h4 id="two-problems-that-modules-are-trying-to-solve"><span class="section_number">14.2.1</span><span class="section_title">Two problems that modules are trying to solve</span></h4>
<ul>
<li>our only mental weapon, to understand code and combat complexity, is divide-and-conquer and abstraction which is often somewhat hierarchical</li>
<li>name clashes are bound to happen in a large software system</li>
</ul>
<p>Modules reduce complexity by partitioning and independence. See <a href="http://www.computing.dcu.ie/~renaat/ca2/ca214/ca214vii.html">Three Universal methods of reducing complexity</a> from the course <a href="http://www.computing.dcu.ie/~renaat/ca2/ca214over.html">CA214 Systems Analysis and Design Page</a>.</p>
<p>Which is essential: complexity management or namespacing?</p>
<h4 id="modules-are-for-humans"><span class="section_number">14.2.2</span><span class="section_title">Modules are for humans</span></h4>
<p>Computers don't need modules. All it needs is a sequence of machine codes.</p>
<p>Given enough memory, a computer can handle arbitrarily big programs.</p>
<p>Human uses modules for organizing things. Human uses modules to make machines separate compilation, speed up recompilation, and recompile a part of the program.</p>
<h4 id="why-do-name-clashes-happen"><span class="section_number">14.2.3</span><span class="section_title">Why do name clashes happen?</span></h4>
<p>Natural languages also have name clashes.</p>
<p>English homonyms.</p>
<p>Why do we have homonyms?</p>
<p>We use language for practical purposes, not for philosophical purposes. Practically, conflating a thing and its representation makes life easier.</p>
<h4 id="how-does-name-clashes-happen"><span class="section_number">14.2.4</span><span class="section_title">How does name clashes happen?</span></h4>
<h4 id="the-key-of-avoiding-name-clashes-things-should-not-name-themselves"><span class="section_number">14.2.5</span><span class="section_title">The key of avoiding name clashes: Things should not name themselves</span></h4>
<p>Names and referents should be separated.</p>
<p>Philosophically, a name of a thing must not be a property of the thing itself. A rock does not implore us to call it &quot;rock&quot;. It is we who name it &quot;rock&quot;. My name is &quot;Erik&quot;, but you can name me anything, although calling me with any other name may fail to grab my attention.</p>
<p>If A uses B, then A names B, and B must not tell A what to name B.</p>
<p>Example agreement: JavaScript functions and modules don't have names. What has a name is the variable that refers to the function or to the module.</p>
<p>Example violation: C functions have names.</p>
<h4 id="how-do-module-systems-arise"><span class="section_number">14.2.6</span><span class="section_title">How do module systems arise?</span></h4>
<p>We are merrily writing codes until our program grows big and we have difficulty finding things. Then we feel that something has to be done.</p>
<p>We make module systems because we are humans with limited working memory. Our only weapon against complexity is divide-and-conquer and hierarchical abstraction/categorization.</p>
<h4 id="secondary-uses-of-modules"><span class="section_number">14.2.7</span><span class="section_title">Secondary uses of modules</span></h4>
<p>All other purposes such as encapsulation and protection are secondary while-we're-at-it additions.</p>
<ul>
<li>to separate or parallelize compilation</li>
<li>to protect internal constraints/consistency, to prevent the user from using the module in an incorrect way not designed by the module creator <span class="citation" data-cites="haemmerle2006modules">[<a href="#ref-haemmerle2006modules">8</a>]</span></li>
</ul>
<p>C does not even try: leave it the programmer. C++ solution is better but not satisfactory: automatically prefix everything. JavaScript's solution is fundamentally better: the names of modules, classes and functions can be locally scoped.</p>
<p>Static typing helps name resoution by overloading like in Java and C++. But this only delays the problem: <em>the types themselves can have clashing names</em>.</p>
<p>For example, a car driver does not mess with the internals of the car engine while driving.</p>
<h4 id="modules-as-protection-of-internals"><span class="section_number">14.2.8</span><span class="section_title">Modules as protection of internals?</span></h4>
<p>There are two opposing hypotheses:</p>
<ul>
<li>Good abstraction (implementation-hiding) increases robustness.</li>
<li>All abstraction leaks, and the fix requires knowing the implementation.</li>
</ul>
<p>For robustness, we want caller to depend only on public interface; we want to make the contract explicit.</p>
<p>Modules are for protecting internal assumptions? From <span class="citation" data-cites="haemmerle2006modules">[<a href="#ref-haemmerle2006modules">8</a>]</span>:</p>
<ul>
<li>&quot;One difficulty in Prolog comes from the <em>call</em> predicate which interferes with the protection of the code, an essential task of a module system.&quot;</li>
<li>&quot;[…] to guarantee the semantics of the predicates defined in a library, a module system has however to strictly prevent any predicate execution not allowed by the programmer.&quot;</li>
<li>&quot;The <em>algebraic approach</em> defines module calculi with operations over sets of program clauses&quot;</li>
</ul>
<h4 id="what-are-hardware-modules"><span class="section_number">14.2.9</span><span class="section_title">What are hardware modules?</span></h4>
<p>An example is an integrated circuit, a black box that performs a high-level function. Thinking in terms of op-amps instead of in terms of Maxwell's equations. The essence of hardware module is abstraction. A module is a unit of reasoning. If a module breaks down, the user replaces the entire module. The module creator designs the module such that the module user can think at a higher level of abstraction.</p>
<h4 id="ciao-prolog-module-system"><span class="section_number">14.2.10</span><span class="section_title">Ciao Prolog module system?</span></h4>
<p><span class="citation" data-cites="cabeza2000new">[<a href="#ref-cabeza2000new">4</a>]</span></p>
<h3 id="how-should-modules-and-meta-predicates-interact"><span class="section_number">14.3</span><span class="section_title">How should modules and meta-predicates interact?</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">14.3.1</span><span class="section_title"><a href="#what-is-the-name-of-a-thing">What is the name of a thing?</a></span><span class="word_count">(18w~1m)</span></li>
<li><span class="section_number">14.3.2</span><span class="section_title"><a href="#what-should-call1-mean-what-is-the-reason-for-atom-based-module-systems">What should call/1 mean? What is the reason for atom-based module systems?</a></span><span class="word_count">(151w~1m)</span></li>
</ul>
</div>
<h4 id="what-is-the-name-of-a-thing"><span class="section_number">14.3.1</span><span class="section_title">What is the name of a thing?</span></h4>
<p>The question boils down to &quot;What is the name of a thing?&quot;</p>
<h4 id="what-should-call1-mean-what-is-the-reason-for-atom-based-module-systems"><span class="section_number">14.3.2</span><span class="section_title">What should call/1 mean? What is the reason for atom-based module systems?</span></h4>
<p>We propose two principles for call/1: <em>transparency</em> and <em>lexical binding</em>, because they simplify reasoning about the program.</p>
<p>Without modules, the meaning of <code>call(foo(A))</code> is straightforward: It is as if the programmer had written <code>foo(A)</code> instead.</p>
<p><em>Transparency</em> means that textually replacing <code>call(A)</code> with <code>A</code> in the source code should preserve the meaning of the program. The semantics of <code>call(A)</code> should be the same as the semantics of <code>A</code>.</p>
<p><em>Lexical binding</em> means that we should be able to determine the meaning just by looking at the source code without running the program.</p>
<p>An atom-based module system is one way of satisfying those principles. But a predicate-based module system is more amenable to compilation?</p>
<p>qname_module_name(QualName, Module, Name)</p>
<p>Lexical binding is a consequence of the <em>principle of least surprise</em>: do what most users most likely expect. But can the principle of least surprise clash with the principle of mathematical elegance?</p>
<h3 id="designing-the-module-system"><span class="section_number">14.4</span><span class="section_title">Designing the module system</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">14.4.1</span><span class="section_title"><a href="#what-is-a-module-functionally-relationally-and-logically">What is a module, functionally, relationally, and logically?</a></span><span class="word_count">(74w~1m)</span></li>
<li><span class="section_number">14.4.2</span><span class="section_title"><a href="#how-does-a-module-differ-from-dictionary-function-table-map-association">How does a module differ from dictionary, function, table, map, association?</a></span><span class="word_count">(177w~1m)</span></li>
<li><span class="section_number">14.4.3</span><span class="section_title"><a href="#do-not-conflate-modules-and-files">Do not conflate modules and files</a></span><span class="word_count">(29w~1m)</span></li>
<li><span class="section_number">14.4.4</span><span class="section_title"><a href="#should-module-names-correspond-to-file-names">Should module names correspond to file names?</a></span><span class="word_count">(307w~2m)</span></li>
<li><span class="section_number">14.4.5</span><span class="section_title"><a href="#how-do-we-design-a-module-system-that-subsumes-both-atom-based-and-predicate-based-module-systems">How do we design a module system that subsumes both atom-based and predicate-based module systems?</a></span><span class="word_count">(21w~1m)</span></li>
<li><span class="section_number">14.4.6</span><span class="section_title"><a href="#anonymous-predicates">Anonymous predicates?</a></span><span class="word_count">(43w~1m)</span></li>
<li><span class="section_number">14.4.7</span><span class="section_title"><a href="#prolog-mixins">Prolog mixins</a></span><span class="word_count">(35w~1m)</span></li>
<li><span class="section_number">14.4.8</span><span class="section_title"><a href="#component-system-with-socket-plug-metaphor">Component system with socket-plug metaphor</a></span><span class="word_count">(128w~1m)</span></li>
<li><span class="section_number">14.4.9</span><span class="section_title"><a href="#no-separate-header-files">No separate header files</a></span><span class="word_count">(12w~1m)</span></li>
</ul>
</div>
<h4 id="what-is-a-module-functionally-relationally-and-logically"><span class="section_number">14.4.1</span><span class="section_title">What is a module, functionally, relationally, and logically?</span></h4>
<p>From functional programming perspective, a module is a function from name to value.</p>
<p>From relational programming perspective, a module is a functional relation between name and value.</p>
<p>From logic programming perspective, a module is a collection of Horn clauses.</p>
<p>Atom-based modules break those intuitions?</p>
<p>Thus in Prolog, if we have first-class relations, then we can have first-class modules.</p>
<p>Having first-class relation means using <em>second-order logic</em>. That is the <code>M</code> in this example:</p>
<pre class="example"><code>usefoo :-
    import(&quot;foo.pro&quot;, mypred, M),
    M(bar).

% But that can be made first-order?

usefoo :-
    import(&quot;foo.pro&quot;, M),
    M:bar.
</code></pre>
<h4 id="how-does-a-module-differ-from-dictionary-function-table-map-association"><span class="section_number">14.4.2</span><span class="section_title">How does a module differ from dictionary, function, table, map, association?</span></h4>
<p>What can we do with zero module? We can create the empty module. What can we do with a module? What can we do with many modules?</p>
<p>Equality vs identity: Must a programming language separate equality and identity? Should two strings be equal, if they have different memory addresses but the same content?</p>
<p>Let <span class="math inline">\( D \)</span> be the programming language's domain of discourse.</p>
<p>Let <span class="math inline">\( F(D) = D \to D \)</span> be the set of every endofunction whose domain is <span class="math inline">\( D \)</span>. Let <span class="math inline">\( D \)</span> be the smallest set such that <span class="math inline">\( F(D) \subset D \)</span>. Thus <span class="math inline">\( D \)</span> is the least fixed point of <span class="math inline">\( F \)</span>.</p>
<p>A dictionary can be a finite function whose domain is a finite subset of <span class="math inline">\( D \)</span>.</p>
<p>A module can be modeled as a dictionary. A module can be modeled as a finite function <span class="math inline">\( N \to D \)</span> where <span class="math inline">\( N \)</span> is the set of names for which the module has an entry. A module can be modeled as an infinite function <span class="math inline">\( N \to D \)</span> where <span class="math inline">\( N \)</span> is the set of all possible names.</p>
<h4 id="do-not-conflate-modules-and-files"><span class="section_number">14.4.3</span><span class="section_title">Do not conflate modules and files</span></h4>
<p>A module is the internal representation. File contains the external representation. The analogy: A module contains thoughts. A file countains writings representing those thoughts.</p>
<h4 id="should-module-names-correspond-to-file-names"><span class="section_number">14.4.4</span><span class="section_title">Should module names correspond to file names?</span></h4>
<p>If the relationship between a file and a module does not have to be 1:1, then complications arise.</p>
<p>We assume 1:1 relationship between files and modules.</p>
<p>Problems:</p>
<ul>
<li>M:N mapping between files and modules</li>
<li>Name clashes</li>
<li>Module instantiation</li>
<li>Imports and dependencies</li>
<li>I want to make many languages and interpreters, and I don't want to prefix each predicate: I want to write N interpret predicates, I don't want to write 1 langN_interpret for each N.</li>
<li>A clashy-named old predicate is used a lot.</li>
</ul>
<p>Why do we have modules if records suffice? An OCaml &quot;functor&quot; would then simply be a function from records to records.</p>
<p>OCaml has first-class modules, but can it import a file into a module? <a href="https://v1.realworldocaml.org/v1/en/html/first-class-modules.html">https://v1.realworldocaml.org/v1/en/html/first-class-modules.html</a></p>
<p>OCaml ties module name to file name. Is this bad? &quot;Source files in OCaml are tied into the module system, with each file compiling down into a module whose name is derived from the name of the file.&quot; <a href="https://v1.realworldocaml.org/v1/en/html/files-modules-and-programs.html">https://v1.realworldocaml.org/v1/en/html/files-modules-and-programs.html</a></p>
<p>What JavaScript does right:</p>
<ul>
<li>a module is a plain JavaScript object</li>
<li>it is possible import a file into a module referred by a local variable</li>
</ul>
<p>What Ocaml does right:</p>
<ul>
<li>local import</li>
</ul>
<pre class="example"><code>interpret(Language, Context, Expression, Meaning).
</code></pre>
<p>Some solutions that come to mind:</p>
<ul>
<li>Load module using gensym/2 if not current_module/2. The loader generates the name of the module that the file is loaded to. module/2 is anti-pattern.</li>
<li>name mangling like what C++ does on top of C; generated module names</li>
<li>Pengines to separate the worlds?</li>
<li>Logtalk</li>
</ul>
<p>We want to state these facts:</p>
<ul>
<li>This file imports predicate P from file F, because a predicate in this file calls/uses/depends-on that predicate P defined in that file F.</li>
</ul>
<p>We came up with the import/2 directive.</p>
<p>Prolog expansion has some problems.<a href="#fn82" class="footnote-ref" id="fnref82"><sup>82</sup></a></p>
<p>Moura 2003 <span class="citation" data-cites="pmoura2003logtalk">[<a href="#ref-pmoura2003logtalk">19</a>]</span>: &quot;The first time I felt the need for strong encapsulation features in Prolog was during my final year undergraduate project, in 1989.&quot;</p>
<p>This SWI-Prolog Google Groups discussion thread<a href="#fn83" class="footnote-ref" id="fnref83"><sup>83</sup></a> is relevant.</p>
<p>Module is about namespacing.</p>
<p>We want to say that &quot;The mypred/3 in file1 is the same as the yourpred/3 in file2.&quot;</p>
<h4 id="how-do-we-design-a-module-system-that-subsumes-both-atom-based-and-predicate-based-module-systems"><span class="section_number">14.4.5</span><span class="section_title">How do we design a module system that subsumes both atom-based and predicate-based module systems?</span></h4>
<p>A module system is a name-prefixing mechanism.</p>
<h4 id="anonymous-predicates"><span class="section_number">14.4.6</span><span class="section_title">Anonymous predicates?</span></h4>
<ul>
<li>Do anonymous predicates subsume module systems?</li>
<li>What may anonymous predicates look like?</li>
</ul>
<p>It should be possible to talk about a predicate without naming it first.</p>
<pre class="example"><code>p(A) :- A = 0 ; A = 1.

% vs

\ A :- A = 0 ; A = 1.
</code></pre>
<p><span class="math inline">\( p(x) \equiv x=0 \vee x=1 \)</span> vs <span class="math inline">\( \lambda x (x=0 \vee x=1) \)</span>.</p>
<p>How do we add anonymous relations/predicates to Prolog?</p>
<pre class="example"><code>let p = \ A :- (A = 1 ; A = 2).

p(A) :- A = 1, A = 2.
</code></pre>
<h4 id="prolog-mixins"><span class="section_number">14.4.7</span><span class="section_title">Prolog mixins</span></h4>
<p>A Prolog <em>mixin</em> (mix-in) is simply an include file that adds features to the includer. Example, this mixin endows the includer with a static vocabulary about objects and properties, akin to object-orientation without method.</p>
<pre class="example"><code>% object.pro

:- multifile opv/3.

get(O,P,V) :- \+ opv(O,P,V), throw... . % what?
get(O,P,V) :- opv(O,P,V).
</code></pre>
<h4 id="component-system-with-socket-plug-metaphor"><span class="section_number">14.4.8</span><span class="section_title">Component system with socket-plug metaphor</span></h4>
<p>I need a component system for programming in the large. Prolog module system is a building block, but Prolog modules by themselves are not enough. Socket-and-plug metaphor fits nicely? The name tells it all: a socket is a female connector and a plug is a male connector, and we connect plugs to sockets, and Prolog should complain if it sees a socket that is connected not exactly once.</p>
<p>An input is a multifile predicate.</p>
<p>A pin is a Name/Arity term.</p>
<p>A plug exports symbols.</p>
<p>A socket imports symbols.</p>
<p>A module may have multiple plugs and sockets.</p>
<p>Pins are matched by NameArity. The ordering of pins does not matter.</p>
<p>A Prolog module system is either <em>predicate-based</em> or <em>atom-based</em>. XSB is atom-based. SWI is predicate-based. GNU Prolog does not have a module system.</p>
<h4 id="no-separate-header-files"><span class="section_number">14.4.9</span><span class="section_title">No separate header files</span></h4>
<p>Separate header files are remnants of the big-design-up-front era.</p>
<h3 id="organizing-and-loading-prolog-source-files-without-name-clashes"><span class="section_number">14.5</span><span class="section_title">Organizing and loading Prolog source files without name clashes</span></h3>
<p>Prolog multifile predicates can be used for <em>dependency injection</em>. Instead of importing a module, declare a multifile predicate and let the user link that predicate.</p>
<p>Prolog source files come in <em>two kinds</em> depending on how they are loaded: <em>type-1</em> files and <em>type-2</em> (module-free) files. In short, a type-2 file should not assume that the Prolog implementation has a module system, unless when defining meta-predicates. The discipline is:</p>
<ul>
<li>A type-2 file should not contain any directives except include/1. Thus a type-2 file must not begin with module/2 directive, and must not use the use_module/[1,2] directive.</li>
<li>A type-2 file should not contain hard-coded module references. A type-2 file should not contain any qualified M:P call where M is a hard-coded atom; it is fine if M is a variable.</li>
</ul>
<p>There are several mostly incompatible ways to load a Prolog source file:</p>
<ul>
<li>include/1, only works as directive</li>
<li>consult/1</li>
<li>consult_unregistered/1, which is load_files/2 with register(false) option</li>
<li>use_module/2</li>
<li>load_files/2</li>
<li>consult_unregistered_into_module/2, which is just load_files/2 with module/1 and register(false) options</li>
<li>Logtalk, logtalk_load/1, logtalk_load/2</li>
</ul>
<p>The function of the main file is to link the non-main files. To maximize reusability and minimize name clash, a non-main file must not contain any hard-coded module names: Those files must not contain module/2 declarations and use_module/[1,2] directives.</p>
<h3 id="from-module.md-designing-module-systems"><span class="section_number">14.6</span><span class="section_title">from module.md (Designing module systems)</span></h3>
<ul>
<li>How do we decompose a program? (I think David Parnas has answered this.)</li>
<li>How do we organize programs?</li>
</ul>
<p>What do we infer?</p>
<ul>
<li>We can develop different modules at the same time.</li>
</ul>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">14.6.1</span><span class="section_title"><a href="#philosophical-investigation">Philosophical investigation</a></span><span class="word_count">(128w~1m)</span></li>
<li><span class="section_number">14.6.2</span><span class="section_title"><a href="#key-idea-module-dictionary---dictionary">Key idea: Module = Dictionary -&gt; Dictionary</a></span><span class="word_count">(162w~1m)</span></li>
<li><span class="section_number">14.6.3</span><span class="section_title"><a href="#partial-query-problem">Partial query problem</a></span><span class="word_count">(36w~1m)</span></li>
<li><span class="section_number">14.6.4</span><span class="section_title"><a href="#what-are-some-cool-ideas">What are some cool ideas?</a></span><span class="word_count">(15w~1m)</span></li>
<li><span class="section_number">14.6.5</span><span class="section_title"><a href="#finding-a-programming-language-for-programming-in-the-large">Finding a programming language for programming in the large</a></span><span class="word_count">(337w~2m)</span></li>
<li><span class="section_number">14.6.6</span><span class="section_title"><a href="#packagedependency-management-tools">package/dependency management tools</a></span><span class="word_count">(13w~1m)</span></li>
<li><span class="section_number">14.6.7</span><span class="section_title"><a href="#module-algebra-vs-module-calculus">Module algebra vs module calculus?</a></span><span class="word_count">(61w~1m)</span></li>
<li><span class="section_number">14.6.8</span><span class="section_title"><a href="#other-questions">Other questions?</a></span><span class="word_count">(132w~1m)</span></li>
</ul>
</div>
<h4 id="philosophical-investigation"><span class="section_number">14.6.1</span><span class="section_title">Philosophical investigation</span></h4>
<ul>
<li>What are the properties of a module?</li>
<li>What are its relationships with other things?
<ul>
<li>interchangeability</li>
</ul></li>
<li>A module groups things.
<ul>
<li>Is this essential or accidental? Is it made for grouping? Is grouping only a side-effect?</li>
</ul></li>
<li>What can we do with modules?
<ul>
<li>We can combine modules.</li>
<li>We can shadow modules.</li>
<li>We can link modules.</li>
<li>We can embed/inline modules.</li>
</ul></li>
<li>A module is an incomplete/dependent piece of functionality/code.
<ul>
<li>A module may have unresolved symbols?</li>
</ul></li>
<li>A module is a decomposition of a program?</li>
<li>Module is about reusability?</li>
<li>A program is a module and a starting point.</li>
<li>A module specifies a contract. A module can be swapped with another module that satisfies the same contract without changing the correctness of the program.</li>
<li>A module is a bunch of imports and exports?</li>
<li>A module is smallest unit of reuse? Isn't that function?</li>
<li>A module is smallest unit of compilation? Isn't that function?</li>
</ul>
<h4 id="key-idea-module-dictionary---dictionary"><span class="section_number">14.6.2</span><span class="section_title">Key idea: Module = Dictionary -&gt; Dictionary</span></h4>
<p>Assume a dependently-typed language.</p>
<p>Recall some terminologies:</p>
<ul>
<li>A record is a tuple whose components are named.</li>
<li>A dictionary is also known as key-value map or look-up table.</li>
</ul>
<p>Then a module is a lambda abstraction that takes a record and gives a record.</p>
<p>A module is a lambda abstraction.</p>
<p>This idea is similar to Nix and JavaScript modules.</p>
<p><code>type Module = Map Name Decl -&gt; Map Name Decl</code></p>
<p>A module translates into a lambda-calculus expression. An import translates to an entry in the input dictionary. An export translates to an entry in the output dictionary. Example:</p>
<pre class="example"><code>module {
    import add mul Int32;
    export f g T;
    f = add;
    g = mul;
    T = Int32;
};

-- The expression above translates to:

\ {add; mul; Int32; ...} -&gt; {
    f = add;
    g = mul;
    T = Int32;
};
</code></pre>
<ul>
<li><p>Key ideas of that example:</p>
<ul>
<li>Dictionary pattern matching simulates row polymorphism.</li>
<li><code>{a;b;c;}</code> is shorthand for <code>{a:a; b:b; c:c;}</code>.</li>
<li><a href="https://blog.robphoenix.com/elixir/notes-on-elixir-pattern-matching-maps/">Notes on Elixir: Pattern-Matching Maps · Rob Phoenix</a></li>
</ul></li>
</ul>
<p>What we are doing here is also known as &quot;blurring the phase distinction&quot;. See <a href="https://futhark-lang.org/blog/2017-01-25-futhark-module-system.html#modules-versus-higher-order-functions">&quot;Modules versus Higher-Order Functions&quot; in Futhark blog post</a>: &quot;A module can be viewed as nothing but a record containing types and values.&quot;</p>
<p>A problem: compilation may fail to terminate. No big deal. Set a time-out.</p>
<h4 id="partial-query-problem"><span class="section_number">14.6.3</span><span class="section_title">Partial query problem</span></h4>
<p>Partial query problem is when an object-relational mapper is not smart enough to avoid pulling unused columns.</p>
<p>Does lazy evaluation solve the partial query problem elegantly? Lazy evaluation is not a substitute for dependency analysis?</p>
<h4 id="what-are-some-cool-ideas"><span class="section_number">14.6.4</span><span class="section_title">What are some cool ideas?</span></h4>
<ul>
<li>Module system: Dhall can import from IPFS.<a href="#fn84" class="footnote-ref" id="fnref84"><sup>84</sup></a></li>
<li>Elixir can pattern-match maps (dictionaries).</li>
</ul>
<h4 id="finding-a-programming-language-for-programming-in-the-large"><span class="section_number">14.6.5</span><span class="section_title">Finding a programming language for programming in the large</span></h4>
<ul>
<li>Ecosystem, libraries, tools, and communities.</li>
<li>The most important thing in programming in the large is name management. Namespaces.
<ul>
<li>C has two namespaces: type namespace and value namespace.</li>
<li>Haskell has two namespaces: type namespace and value namespace.</li>
<li>Java has better namespacing than C.</li>
<li>Enable the same name to be used in different context, so that you can write <code>get_name employee</code> and <code>get_name company</code> instead of <code>employee_get_name employee</code> or <code>company_get_name company</code>.
<ul>
<li>Ad-hoc polymorphism.</li>
</ul></li>
</ul></li>
<li>Which one has the biggest community?</li>
<li>Which one has a decent IDE?</li>
<li>Which community puts their money on where their mouth is?</li>
<li>Comparing type systems
<ul>
<li><a href="https://docs.racket-lang.org/ts-guide/">The Typed Racket Guide</a></li>
<li>F#</li>
<li>SML</li>
<li>Caml</li>
<li>OCaml</li>
<li>Idris, Agda</li>
<li>Coq, Lean</li>
<li>Haskell</li>
<li>2004, chapter, &quot;Type systems&quot;, Luca Cardelli, <a href="http://lucacardelli.name/Papers/TypeSystems.pdf">pdf</a>
<ul>
<li>from <a href="https://www.artima.com/forums/flat.jsp?forum=106&amp;thread=185420">https://www.artima.com/forums/flat.jsp?forum=106&amp;thread=185420</a></li>
<li>2005, book, &quot;Advanced topics in types and programming languages&quot;, Benjamin C. Pierce (editor)
<ul>
<li>Part IV, &quot;Types for Programming in the Large&quot;</li>
</ul></li>
<li>2002, book, &quot;Types and programming languages&quot;, Benjamin C. Pierce</li>
</ul></li>
<li>Java, Kotlin, Scala</li>
<li>Things that annoy me
<ul>
<li>ML, SML, Caml, OCaml: <code>'a tf</code> is somewhat annoying. It should have been <code>tf a</code>.
<ul>
<li>F# uses <code>tf&lt;'a&gt;</code>.</li>
<li>Haskell uses <code>Tf a</code>.</li>
</ul></li>
<li>Would you rather type <code>'a list</code> (F#) or deal with an inadequate record/module system (Haskell)?</li>
<li>Haskell doesn't have <code>instance Read (-&gt;)</code> and <code>instance Show (-&gt;)</code>.
<ul>
<li>Haskell expressions are not first-class citizen in the language.
<ul>
<li>Unlike Lisp/Scheme.</li>
</ul></li>
<li>Encumbers metaprogramming.</li>
</ul></li>
</ul></li>
<li>OCaml labels and polymorphic variants?
<ul>
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml-400/manual006.html">http://caml.inria.fr/pub/docs/manual-ocaml-400/manual006.html</a></li>
<li>OCaml labels are somewhat similar to Scheme keyword arguments.</li>
</ul></li>
<li>F# quotations is important for metaprogramming.</li>
<li>F# doesn't do ad-hoc polymorphism well?
<ul>
<li><a href="https://withouttheloop.com/articles/2014-10-21-fsharp-adhoc-polymorphism/">Ad-hoc Polymorphism in F# (how to survive without Type Classes) - Without the loop</a></li>
<li><a href="https://sidburn.github.io/blog/2016/03/24/higher-kinded-polymorphism">Higher-kinded Polymorphism: What is it, why you want it · David Raab</a></li>
</ul></li>
<li><a href="https://cstheory.stackexchange.com/questions/40705/why-did-caml-become-ocaml-or-why-use-objects-in-f">https://cstheory.stackexchange.com/questions/40705/why-did-caml-become-ocaml-or-why-use-objects-in-f</a></li>
<li>ML begat Caml. Caml begat Caml Light? Caml Light begat OCaml?</li>
<li><a href="https://www.quora.com/How-does-F-compare-to-OCaml-in-regard-to-major-syntactic-differences-paradigm-shifts-and-interoperability-with-Windows-What-about-its-numeric-capabilities">How does F# compare to OCaml, in regard to major syntactic differences, paradigm shifts, and interoperability with Windows? What about its numeric capabilities? - Quora</a>
<ul>
<li>Jon Harrop claims. More sources needed. Take it with a grain of salt.
<ul>
<li>&quot;OCaml has an integrated full-blown macro system in the form of Camlp4 whereas F# does not have macros and, in fact, has been deliberately closed off in order to discourage people from creating products that compete with Visual Studio.&quot;
<ul>
<li>&quot;deliberately closed off […]&quot; is a bold claim.</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/155239/are-all-languages-basically-the-same/155243">Are all languages basically the same? - Software Engineering Stack Exchange</a></li>
</ul>
<h4 id="packagedependency-management-tools"><span class="section_number">14.6.6</span><span class="section_title">package/dependency management tools</span></h4>
<ul>
<li>Java: Maven, Gradle</li>
<li>OCaml: OPAM</li>
<li>Haskell: Cabal, Stack</li>
<li>F#: Paket? NuGet?</li>
<li>C/C++: conan? chocolate? vcpkg?</li>
</ul>
<h4 id="module-algebra-vs-module-calculus"><span class="section_number">14.6.7</span><span class="section_title">Module algebra vs module calculus?</span></h4>
<p><span class="citation" data-cites="haemmerle2006modules">[<a href="#ref-haemmerle2006modules">8</a>]</span> mentions module algebra (when talking about Prolog modules).</p>
<p>The following seems different.</p>
<p>Formally adding modules to lambda calculus: What is module calculus?</p>
<ul>
<li>2017 article &quot;Modules, Abstraction, and Parametric Polymorphism&quot; <a href="https://www.cs.cmu.edu/~crary/papers/2017/mapp.pdf">pdf</a></li>
<li>2003 article &quot;A Type System for Higher-Order Modules&quot; <a href="http://www.cs.cmu.edu/~rwh/papers/thoms/tr2.pdf">pdf</a></li>
<li>2001 article &quot;A Calculus of Module Systems&quot; <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.5407">pdf available</a></li>
<li>2012 course notes &quot;Types for Module Systems&quot; <a href="http://www.ccs.neu.edu/home/amal/course/7480-s12/modules-notes.pdf">pdf</a> from <a href="http://www.ccs.neu.edu/home/amal/course/7480-s12/">CS7480 Type Systems (Spring 2012)</a></li>
</ul>
<h4 id="other-questions"><span class="section_number">14.6.8</span><span class="section_title">Other questions?</span></h4>
<ul>
<li>Does a module have to coincide with a compilation unit?</li>
<li>Basic module functions?
<ul>
<li>How does a code describe its dependencies?</li>
<li>How does the machine disambiguate names?</li>
<li>Functions should be versioned. Not module. Not package. Version describes semantics.</li>
</ul></li>
</ul>
<p>Module is second-order logic programming? Note below, that the same <code>Plus</code> is used as both a variable and a predicate.</p>
<pre class="example"><code>export(module_name, type, name, value).

export(prelude, int, plus, Plus) |- export(my_module, int, three, Plus(1, 2)).
</code></pre>
<ul>
<li>The smallest unit for this discussion is a machine instruction.</li>
<li>A subroutine is a collection of instructions.</li>
<li>A library is a collection of subroutines.</li>
<li>A program is a collection of libraries and an entry point.</li>
<li>History
<ul>
<li>The initial motivation was to reuse.
<ul>
<li>Reduce development cost.
<ul>
<li>Humans have always been looking for easier ways to live. This &quot;laziness&quot; (the ability to get bored repeating something) is the source of all human technology.</li>
</ul></li>
</ul></li>
<li>The next motivation was to reduce disk and memory usage.</li>
</ul></li>
<li>The essence of programming-in-the-large is Don't Repeat Yourself?</li>
</ul>
<h3 id="the-implementation-draft-a-clash-free-module-system"><span class="section_number">14.7</span><span class="section_title">&lt;2019-04-02&gt; The implementation? Draft: A clash-free module system</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">14.7.1</span><span class="section_title"><a href="#about-this-draft">About this draft</a></span><span class="word_count">(64w~1m)</span></li>
<li><span class="section_number">14.7.2</span><span class="section_title"><a href="#message">Message</a></span><span class="word_count">(182w~1m)</span></li>
<li><span class="section_number">14.7.3</span><span class="section_title"><a href="#implementation-details">Implementation details</a></span><span class="word_count">(140w~1m)</span></li>
<li><span class="section_number">14.7.4</span><span class="section_title"><a href="#proposal-import_qualified1-directive">Proposal: import_qualified/1 directive</a></span><span class="word_count">(8w~1m)</span></li>
<li><span class="section_number">14.7.5</span><span class="section_title"><a href="#the-problem-we-could-be-a-victim-of-our-own-success-if-we-dont-act">The problem: We could be a victim of our own success if we don't act</a></span><span class="word_count">(62w~1m)</span></li>
<li><span class="section_number">14.7.6</span><span class="section_title"><a href="#criteria-of-a-satisfactory-solution">Criteria of a satisfactory solution</a></span><span class="word_count">(15w~1m)</span></li>
<li><span class="section_number">14.7.7</span><span class="section_title"><a href="#related-discourses">Related discourses</a></span><span class="word_count">(4w~1m)</span></li>
</ul>
</div>
<h4 id="about-this-draft"><span class="section_number">14.7.1</span><span class="section_title">About this draft</span></h4>
<p>The target audience is the SWI-Prolog maintainer, Jan Wielemaker.</p>
<p>I wish to convince Jan that we must have a clash-free module system so that we do not become the victim of our own success when Prolog becomes mainstream.</p>
<p>I wish to see such module system standardized and implemented.</p>
<p>Where should we publish this to?</p>
<ul>
<li>Post in SWI-Prolog Discourse group <a href="https://swi-prolog.discourse.group">https://swi-prolog.discourse.group</a></li>
<li>Open an issue in SWI-Prolog Roadmap <a href="https://github.com/SWI-Prolog/roadmap">https://github.com/SWI-Prolog/roadmap</a></li>
</ul>
<h4 id="message"><span class="section_number">14.7.2</span><span class="section_title">Message</span></h4>
<p>Dear Prolog implementors,</p>
<p>The Prolog community seems to be growing, and so is the number of SWI-Prolog packs. As more people write code, name clashes become more likely. We should standardize a clash-free module system before we have too many users and name clashes become too painful.</p>
<p>There are two ways to avoid name clashes:</p>
<ul>
<li>Rely on programmer coordination and discipline. For example, the pack authors may prefix their module names by a domain name they control. But it would be better for a system to avoid assuming that humans behave well.</li>
<li>Make name clashes impossible. This is the path taken by JavaScript. It is the only language I know that does this by its first-class modules.</li>
</ul>
<p>The key to clash-free module names is simple:</p>
<ul>
<li>A file must not contain any module names/references.</li>
<li>The module/2 directive must ignore its first argument (the module name).</li>
<li>Dependency must be specified by file paths and not module names.</li>
</ul>
<p>Both predicate-based and atom-based modules are fine, as long as a module does not name itself, that is, as long as a file does not expect to be loaded to a module with a certain name.</p>
<h4 id="implementation-details"><span class="section_number">14.7.3</span><span class="section_title">Implementation details</span></h4>
<p>I have a working code for SWI-Prolog in <a href="https://github.com/edom/work/blob/master/software/boot/load.pro">boot/load.pro</a>. It defines an <code>import/2</code> directive using <code>term_expansion/2</code>. The loader generates module names. An example usage looks like this:</p>
<pre class="example"><code>:- import(&quot;somefile.pl&quot;,[
    pred/1
    , run/0 as somefile_run
]).
</code></pre>
<p>The presence of an <code>:- import(Source, Specs)</code> in a file means that the file requires some things from Source.</p>
<p>Source may be:</p>
<ul>
<li><code>file(Path)</code> where <code>Path</code> is a relative path to a file. This path is resolved against the file that contains the import/2 directive.</li>
</ul>
<p>Specs is a list of Spec.</p>
<p>Spec may be:</p>
<ul>
<li><code>Name/Arity</code></li>
<li><code>Name/Arity as Alias</code></li>
<li><code>multifile(Name/Arity)</code>: a &quot;reverse-import&quot;</li>
<li><code>multifiles(Preds)</code> where each Pred is a Name/Arity</li>
</ul>
<p>Not yet implemented: importing operators like SWI-Prolog 7.6.4 use_module/2.</p>
<pre class="example"><code>use_module(..., [
    op(_,_,some_operator)
]).
</code></pre>
<p>One day someone may make it possible for Source to be <code>github(...)</code> or <code>pack(...)</code>, but perhaps we should not do that because it will increase compilation time.</p>
<p>An example language with a clash-free module system is JavaScript. Even better, modules are first-class in JavaScript.</p>
<pre class="example"><code>function foo () {
    var a = require(&quot;file1.js&quot;);
    var b = require(&quot;file2.js&quot;);
    console.log(a.x + b.y);
}

// a.js
export let x = 1;

// b.js
export let y = 2;
</code></pre>
<p>What do you think?</p>
<p>Best regards,</p>
<p>Erik</p>
<h4 id="proposal-import_qualified1-directive"><span class="section_number">14.7.4</span><span class="section_title">Proposal: import_qualified/1 directive</span></h4>
<pre class="example"><code>:- import_qualified(file(RelativePath) as local_module(Name)).
:- import_qualified([
    file(File1) as local_module(Name1),
    file(File2) as local_module(Name2),
    ...
]).
</code></pre>
<p>This recursively replaces all module expressions.</p>
<h4 id="the-problem-we-could-be-a-victim-of-our-own-success-if-we-dont-act"><span class="section_number">14.7.5</span><span class="section_title">The problem: We could be a victim of our own success if we don't act</span></h4>
<p>Imagine that there were 10,000 SWI-Prolog packs: There would be naming conflicts. We can learn from the Haskell community's complaints with Haskell's module system, and do it right before it becomes too painful. Let us prepare, so that we do not become a victim of our own success.</p>
<h4 id="criteria-of-a-satisfactory-solution"><span class="section_number">14.7.6</span><span class="section_title">Criteria of a satisfactory solution</span></h4>
<p>Ideally, many people can write and use libraries without name clashes.</p>
<h4 id="related-discourses"><span class="section_number">14.7.7</span><span class="section_title">Related discourses</span></h4>
<ul>
<li>Contributing libraries <a href="https://swi-prolog.discourse.group/t/contributing-libraries/381">https://swi-prolog.discourse.group/t/contributing-libraries/381</a></li>
</ul>
<h3 id="implementing-modules"><span class="section_number">14.8</span><span class="section_title">Implementing modules</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">14.8.1</span><span class="section_title"><a href="#adding-module-system-by-term_expansion2">Adding module system by term_expansion/2</a></span><span class="word_count">(44w~1m)</span></li>
<li><span class="section_number">14.8.2</span><span class="section_title"><a href="#logtalk-2">Logtalk?</a></span><span class="word_count">(23w~1m)</span></li>
<li><span class="section_number">14.8.3</span><span class="section_title"><a href="#haskell-first-class-modules">Haskell first-class modules?</a></span><span class="word_count">(7w~1m)</span></li>
<li><span class="section_number">14.8.4</span><span class="section_title"><a href="#module-systems-in-other-languages">Module systems in other languages?</a></span><span class="word_count">(91w~1m)</span></li>
<li><span class="section_number">14.8.5</span><span class="section_title"><a href="#comparing-existing-module-systems">Comparing existing module systems</a></span><span class="word_count">(97w~1m)</span></li>
</ul>
</div>
<h4 id="adding-module-system-by-term_expansion2"><span class="section_number">14.8.1</span><span class="section_title">Adding module system by term_expansion/2</span></h4>
<p>If a Prolog system has term_expansion/2 but does not have a module system, then we can add a module system. The idea is to recursively replace each term <code>A</code> with <code>':'(M,A)</code>.</p>
<p>This makes something similar to XSB Prolog's atom-based module system.</p>
<h4 id="logtalk-2"><span class="section_number">14.8.2</span><span class="section_title">Logtalk?</span></h4>
<p>&quot;You can even use [Logtalk] to run Prolog module code in Prolog compilers such as GNU Prolog that don't include a module system.&quot;<a href="#fn85" class="footnote-ref" id="fnref85"><sup>85</sup></a></p>
<h4 id="haskell-first-class-modules"><span class="section_number">14.8.3</span><span class="section_title">Haskell first-class modules?</span></h4>
<p>Shields &amp; Peyton-Jones 2002 <span class="citation" data-cites="shields2002first">[<a href="#ref-shields2002first">26</a>]</span>.</p>
<h4 id="module-systems-in-other-languages"><span class="section_number">14.8.4</span><span class="section_title">Module systems in other languages?</span></h4>
<p>REBOL module system?</p>
<p>Bad example: java:</p>
<ul>
<li>name is a property of a method.</li>
<li>a method cannot be referred to by a name.</li>
</ul>
<p>If you use reflection, you are referring to a representation of that method, not the method itself.</p>
<p>Bad example: scheme: map, vector-map, tree-map, etc.</p>
<p>Racket vs prolog Racket has racklog and miniKanren</p>
<p>(infix x = 1 : y = x + x : )</p>
<p>Racket DCG, packrat</p>
<p>What is a module in an untyped functional programming language such as Tulip?</p>
<p>Ignored undocumented code sketches: <a href="https://github.com/jordanlewis/simple-module-system">jordanlewis/simple-module-system: Adding modules to a polymorphic lambda calculus</a>, code in SML/NJ.</p>
<h4 id="comparing-existing-module-systems"><span class="section_number">14.8.5</span><span class="section_title">Comparing existing module systems</span></h4>
<p>How do programming languages deal with modules?</p>
<ul>
<li><a href="https://github.com/dhall-lang/dhall-lang/issues/182">dhall modules · Issue #182 · dhall-lang/dhall-lang</a></li>
<li><a href="https://futhark-lang.org/blog/2017-01-25-futhark-module-system.html">Futhark</a></li>
<li><p><a href="https://elixir-lang.org/getting-started/modules-and-functions.html">Elixir</a></p>
<ul>
<li><a href="https://hexdocs.pm/elixir/Module.html">Module – Elixir v1.7.2</a></li>
</ul></li>
<li><p>Racket</p>
<ul>
<li>2011, article, &quot;Languages as Libraries&quot;, <a href="http://www.cs.utah.edu/plt/publications/pldi11-tscff.pdf">pdf</a></li>
</ul></li>
<li>Scheme R7RS, Common Lisp, Clojure</li>
<li><p>Java, Scala, Kotlin, Go, C, C++</p>
<ul>
<li><p>C ABI</p>
<ul>
<li>A module is an ELF shared object file (SO file).</li>
</ul></li>
</ul></li>
<li>Pascal, Ada, Oberon, Algol, Fortran</li>
<li>JavaScript, TypeScript, ECMAScript</li>
<li><p>Standard ML, Caml, OCaml, MLTON, SML/NJ, F#</p>
<ul>
<li><p>2000, &quot;A modular module system&quot;, <a href="https://hal.inria.fr/hal-01499946/document">pdf</a></p>
<ul>
<li>&quot;Harper-Lillibridge-Leroy module system&quot;</li>
<li>&quot;applicability of that module system to a wide range of programming languages&quot;</li>
</ul></li>
</ul></li>
<li>Haskell has underpowered module system.</li>
<li><p>book, &quot;Advanced topics in types and programming languages&quot;, part IV, programming in the large, <a href="http://camlunity.ru/swap/Functional%20Programming/Type%20Systems/Pierce/Advanced%20Topics%20in%20Types%20and%20Programming%20Languages.pdf">pdf</a></p>
<ul>
<li>book, &quot;Types and programming languages&quot;, <a href="https://www.asc.ohio-state.edu/pollard.4/type/books/pierce-tpl.pdf">pdf</a></li>
</ul></li>
<li><a href="https://en.wikipedia.org/wiki/Modular_programming">WP:Modular programming</a></li>
</ul>
<h3 id="brain-dumps"><span class="section_number">14.9</span><span class="section_title">Brain dumps</span></h3>
<ul>
<li><a href="http://erlang.org/pipermail/erlang-questions/2011-May/058768.html">http://erlang.org/pipermail/erlang-questions/2011-May/058768.html</a>
<ul>
<li>Hackernews commend thread <a href="https://news.ycombinator.com/item?id=8226139">https://news.ycombinator.com/item?id=8226139</a></li>
<li>LtU comment thread <a href="http://lambda-the-ultimate.org/node/5079">http://lambda-the-ultimate.org/node/5079</a></li>
</ul></li>
</ul>
<h3 id="operators-and-adaptive-grammar"><span class="section_number">14.10</span><span class="section_title">Operators and adaptive grammar</span></h3>
<p>Should operator be module-scoped or global-scoped?</p>
<p>An operator declaration modifies the Prolog parser/reader's grammar in a limited manner.</p>
<p>Is it not confusing if parsing a text can, in the middle of parsing, change the grammar that is used to parse the text itself?</p>
<pre class="example"><code>% input

:- op(400,yfx,&#39;+&#39;).
:- op(500,yfx,&#39;*&#39;).

a(A) :- A is 1+2*3.
:- op(500,yfx,&#39;+&#39;).
:- op(400,yfx,&#39;*&#39;).
b(A) :- A is 1+2*3.

% output

?- a(A).
A = 9.

?- b(A).
A = 7.
</code></pre>
<p>If we want adaptive grammars<a href="#fn86" class="footnote-ref" id="fnref86"><sup>86</sup></a>, why stop at operators? Should we go at least as far as OMeta?</p>
<p>&quot;Operator precedence parsing is particularly ugly in PEGs, since by default, they don't support left recursion. The OMeta folks figured out how to cleanly support left recursion in PEGs, but you lose the linear-time guarantee.&quot;<a href="#fn87" class="footnote-ref" id="fnref87"><sup>87</sup></a></p>
<p>If we have local variables, we should also have local operator declarations. We need an adaptive grammar with scope.</p>
<p>We also need composable grammars<a href="#fn88" class="footnote-ref" id="fnref88"><sup>88</sup></a><a href="#fn89" class="footnote-ref" id="fnref89"><sup>89</sup></a>.</p>
<p>C grammar is ambiguous.<a href="#fn90" class="footnote-ref" id="fnref90"><sup>90</sup></a></p>
<p>What are dynamic grammars?<a href="#fn91" class="footnote-ref" id="fnref91"><sup>91</sup></a></p>
<h2 id="the-problems-with-prolog"><span class="section_number">15</span><span class="section_title">The problems with Prolog</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">15.1</span><span class="section_title"><a href="#absence-of-modules-scoping-and-local-variables">Absence of modules, scoping, and local variables</a></span><span class="word_count">(430w~3m)</span></li>
<li><span class="section_number">15.2</span><span class="section_title"><a href="#what-next">What next?</a></span><span class="word_count">(24w~1m)</span></li>
<li><span class="section_number">15.3</span><span class="section_title"><a href="#embedding-prologhaskell-in-haskellprolog">Embedding Prolog/Haskell in Haskell/Prolog</a></span><span class="word_count">(122w~1m)</span></li>
<li><span class="section_number">15.4</span><span class="section_title"><a href="#comparison-with-other-programming-languages">Comparison with other programming languages</a></span><span class="word_count">(211w~2m)</span></li>
<li><span class="section_number">15.5</span><span class="section_title"><a href="#programming-can-be-thought-of-as-applied-mathematics">Programming can be thought of as applied mathematics?</a></span><span class="word_count">(36w~1m)</span></li>
<li><span class="section_number">15.6</span><span class="section_title"><a href="#theorem-proving">Theorem proving</a></span><span class="word_count">(113w~1m)</span></li>
<li><span class="section_number">15.7</span><span class="section_title"><a href="#logic-programming-vs-theorem-proving">Logic programming vs theorem proving</a></span><span class="word_count">(21w~1m)</span></li>
<li><span class="section_number">15.8</span><span class="section_title"><a href="#avoid-using-list-too-much">Avoid using list too much</a></span><span class="word_count">(19w~1m)</span></li>
<li><span class="section_number">15.9</span><span class="section_title"><a href="#minikanren">miniKanren?</a></span><span class="word_count">(26w~1m)</span></li>
<li><span class="section_number">15.10</span><span class="section_title"><a href="#dreams-speculations-ambitions">Dreams, speculations, ambitions</a></span><span class="word_count">(208w~2m)</span></li>
<li><span class="section_number">15.11</span><span class="section_title"><a href="#dynamic-assert-retract">Dynamic, assert, retract</a></span><span class="word_count">(6w~1m)</span></li>
<li><span class="section_number">15.12</span><span class="section_title"><a href="#why-should-we-write-type-systems-as-macros">Why should we write type systems as macros?</a></span><span class="word_count">(16w~1m)</span></li>
</ul>
</div>
<h3 id="absence-of-modules-scoping-and-local-variables"><span class="section_number">15.1</span><span class="section_title">Absence of modules, scoping, and local variables</span></h3>
<p>Prolog does not have scopes and local variables.</p>
<p>Is that absence a bad thing?</p>
<p>(old title: Lambda, closure, scoping, higher-order logic programming, relational programming)</p>
<p>One application of higher-order logic programming is scopes (local variables). It can be done by allowing implications in Horn clause bodies.</p>
<p>Ulrich Neumerkel's &quot;Lambdas in ISO Prolog&quot;<a href="#fn92" class="footnote-ref" id="fnref92"><sup>92</sup></a>.</p>
<p>Logtalk 2.38.0 has lambda expressions.<a href="#fn93" class="footnote-ref" id="fnref93"><sup>93</sup></a></p>
<p>Why can't it be this? Isn't &quot;apply&quot; just variable substitution? But the problem is not substitution. The problem is <em>scoping</em>.</p>
<pre class="example"><code>apply(A^B, A, B).
</code></pre>
<p>&lt;2019-04-05&gt; See lambda.pro. It does the job, but the variables cannot be reused.</p>
<p>Example of closure:</p>
<pre class="example"><code>let makeGetter list = \ i -&gt; elemAt list i
</code></pre>
<p>We can manually do closure conversion (lambda lifting)<a href="#fn94" class="footnote-ref" id="fnref94"><sup>94</sup></a>.</p>
<p>Naish 1996 <span class="citation" data-cites="naish1996higher">[<a href="#ref-naish1996higher">21</a>]</span>:<a href="#fn95" class="footnote-ref" id="fnref95"><sup>95</sup></a> &quot;First, we point out that call/N is not the way to go, despite its recent popularity as the primitive to use for higher order logic programming.&quot;</p>
<p>Let's try something else.</p>
<p>I propose &quot;local predicate&quot; as the logic-relational analog of the functional lambda expression.</p>
<p>The meaning of the expression <code>A ^ B</code> is &quot;prove B assuming that A is true&quot;. The semantics is substitution.</p>
<p>Define the meaning of <code>A^B</code> as prove <code>B</code> assuming <code>A</code>. Thus, the meaning of <code>p(1) ^ (p(A), q(B))</code> is <code>(A = 1, q(B))</code>.</p>
<p>Lambda expression is variable scoping. Prolog needs &quot;knowledge base&quot; scoping.</p>
<p>Each lambda parameter x is encoded as a unary predicate x(A) that succeeds exactly once and unifies A to the value of the variable.</p>
<p>Implication is the logic parallel of lambda abstraction. Proving is the logic parallel of lambda application.</p>
<pre class="example"><code>lambda application: (x to x + 1) 23
becomes
prolog query: x(23), y(B) --&gt; x(A), B is A+1
</code></pre>
<p>But this may be a bad idea, because the predicate x/1 is dynamically scoped. &quot;Local dynamic clauses&quot;</p>
<p>Assert the antecedent when entering frame. Retract the antecedent when leaving frame.</p>
<p>Ask at stackoverflow:</p>
<p>Is there a with_assumption_prove_goal/2 predicate in Prolog?</p>
<p>I am looking for &quot;knowledge base scoping&quot; as an analog of variable scoping in lambda expressions.</p>
<pre class="example"><code>Assumption = (p(1) ; p(2)),
Goal = (p(A), writeln(A)),
with_assumption_prove_goal(Assumption, Goal)

1
2
</code></pre>
<p>It can be done with meta-interpretation. I think it can also be done with Prolog engines.</p>
<p><a href="http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/naish.html">http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/naish.html</a></p>
<p><a href="https://pdfs.semanticscholar.org/904a/b2253330cdd379c7a405f400c6f9152afdca.pdf">https://pdfs.semanticscholar.org/904a/b2253330cdd379c7a405f400c6f9152afdca.pdf</a></p>
<p>Interesting google scholar search: logic with lexical scoping</p>
<p>It may be disconcerting that it takes an academic article to add local variables. But we are doing it in a principled manner. We are thinking about how to add local variables to logic, not to a programming language.</p>
<p>Predicate logic is dynamically scoped. p(G) leftarrow ( x(1) right arrow G) defines a local dynamic predicate x/1</p>
<p>Currying requires keeping track of the arity of partially-applied functions. Currying readily generalizes to partially-applied relations.</p>
<pre class="example"><code>f (x,y) -&gt; (f x) y
r (x,y) -&gt; (r x) y
</code></pre>
<p>Logic vs relational?</p>
<p>MacLennan 1981 <span class="citation" data-cites="maclennan1981overview">[<a href="#ref-maclennan1981overview">15</a>]</span>, MacLennan 1983 <span class="citation" data-cites="maclennan1983relational">[<a href="#ref-maclennan1983relational">16</a>]</span></p>
<p>MacLennan 1981 <span class="citation" data-cites="maclennan1981introduction">[<a href="#ref-maclennan1981introduction">14</a>]</span>: A function is a <em>left-univalent</em> relation. I have been looking for that term.</p>
<p><span class="math inline">\(R \wedge S\)</span> in relation is <code>R, S</code> in logic.</p>
<p>The connection is fundamental: Every set <span class="math inline">\(R\)</span> corresponds to a predicate <span class="math inline">\(\phi\)</span> in this way: <span class="math inline">\(\SetBuilder{\vec{x}}{\phi(\vec{x})}\)</span>. We say that the predicate is an <em>intension</em> and the set is an <em>extension</em>.</p>
<h3 id="what-next"><span class="section_number">15.2</span><span class="section_title">What next?</span></h3>
<p>Gödel, λProlog, Twelf, Datalog, Answer-Set-Programming.<a href="#fn96" class="footnote-ref" id="fnref96"><sup>96</sup></a></p>
<p>Lambda-Prolog 2012 book <span class="citation" data-cites="miller2012programming">[<a href="#ref-miller2012programming">18</a>]</span>.</p>
<p>What are Prolog alternatives? See 2011 article <a href="https://arxiv.org/abs/1107.5408">A structured alternative to Prolog with simple compositional semantics</a>?</p>
<h3 id="embedding-prologhaskell-in-haskellprolog"><span class="section_number">15.3</span><span class="section_title">Embedding Prolog/Haskell in Haskell/Prolog</span></h3>
<p>Why bother with this? Why not just use Oz?</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">15.3.1</span><span class="section_title"><a href="#embedding-prolog-in-haskell">Embedding Prolog in Haskell</a></span><span class="word_count">(57w~1m)</span></li>
<li><span class="section_number">15.3.2</span><span class="section_title"><a href="#embedding-haskell-in-prolog-nobody-is-talking-about-this">Embedding Haskell in Prolog: Nobody is talking about this?</a></span><span class="word_count">(55w~1m)</span></li>
</ul>
</div>
<h4 id="embedding-prolog-in-haskell"><span class="section_number">15.3.1</span><span class="section_title">Embedding Prolog in Haskell</span></h4>
<ul>
<li>1999 article &quot;Embedding Prolog in Haskell&quot; <a href="https://pdfs.semanticscholar.org/7c46/5d25205830735d0a034532746b7243221eca.pdf">https://pdfs.semanticscholar.org/7c46/5d25205830735d0a034532746b7243221eca.pdf</a>
<ul>
<li>&quot;We propose an embedding of logic programming into lazy functional programming in which each predicate in a Prolog program becomes a Haskell function, in such a way that both the declarative and the procedural reading of the Prolog predicate are preserved.&quot;</li>
</ul></li>
<li>1988 article &quot;Towards functional programming in Prolog&quot; <a href="ftp://obaluae.inf.puc-rio.br/pub/docs/Publications/88_AI_Furtado_SINPLAN.Not.pdf">ftp://obaluae.inf.puc-rio.br/pub/docs/Publications/88_AI_Furtado_SINPLAN.Not.pdf</a></li>
</ul>
<h4 id="embedding-haskell-in-prolog-nobody-is-talking-about-this"><span class="section_number">15.3.2</span><span class="section_title">Embedding Haskell in Prolog: Nobody is talking about this?</span></h4>
<p>translate haskell to prolog</p>
<ul>
<li><a href="https://stackoverflow.com/questions/1932770/haskell-vs-prolog-comparison">https://stackoverflow.com/questions/1932770/haskell-vs-prolog-comparison</a></li>
<li><a href="https://github.com/COMS30106/slides">https://github.com/COMS30106/slides</a></li>
<li><a href="https://github.com/COMS30106/slides/blob/master/haskell2prolog.pdf">https://github.com/COMS30106/slides/blob/master/haskell2prolog.pdf</a></li>
</ul>
<p>Prolog and Haskell are almost equally concise. Prolog and Haskell are even in head/2 and tail/2. Prolog beats Haskell in null/1 and reverse/2. Haskell beats Prolog in length/2, sumList/2, and everything that has arithmetics where Prolog requires intermediate variable such as &quot;N1 is N-1&quot;.</p>
<h3 id="comparison-with-other-programming-languages"><span class="section_number">15.4</span><span class="section_title">Comparison with other programming languages</span></h3>
<p>&quot;GOEDEL is intended to be a declarative successor to Prolog.&quot; <a href="https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/impl/other/goedel/0.html">https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/impl/other/goedel/0.html</a></p>
<p>How are Prolog and Lisp similar?</p>
<ul>
<li>Both Prolog and Lisp have symbols and cons cells.
<ul>
<li>This is a Lisp cons cell: <code>(cons 'a 'b)</code> or <code>'(a . b)</code>.</li>
<li>This is the corresponding SWI-Prolog cons cell: <code>[a|b]</code> (the canonical form is <code>'[|]'(a,b)</code>).</li>
</ul></li>
<li>Both have macros.
<ul>
<li>Lisp has defmacro.</li>
<li>Prolog has term_expansion/2 and goal_expansion/2.</li>
</ul></li>
</ul>
<p>I'd say Prolog = Lisp + unification + backtracking - lambda.</p>
<p>Comparison between what is difficult in various programming languages:</p>
<ul>
<li>2014 presentation &quot;That scripting language called Prolog&quot; <a href="https://www.slideshare.net/SergeiWinitzki/prolog-talk">https://www.slideshare.net/SergeiWinitzki/prolog-talk</a>
<ul>
<li>It compares what is difficult in various programming languages.</li>
<li>It defines &quot;declarative&quot;: 'Programming is &quot;declarative&quot; when <em>specifications are programs</em>.'
<ul>
<li>Slide 29: &quot;declarative programming = creating a good DSL for your domain&quot;</li>
</ul></li>
<li>Slide 24 compares SQL, Datalog, and Prolog.</li>
</ul></li>
</ul>
<p>Comparison with other relational programming languages:</p>
<p>Comparison with miniKanren:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/28467011/what-are-the-main-technical-differences-between-prolog-and-minikanren-with-resp">https://stackoverflow.com/questions/28467011/what-are-the-main-technical-differences-between-prolog-and-minikanren-with-resp</a>
<ul>
<li>William E. Byrd's answer:
<ul>
<li>Prolog is practical; miniKanren is pure.</li>
<li>Prolog unification doesn't use occurs check; miniKanren unification uses occurs check.</li>
<li>Prolog uses depth-first search; miniKanren uses complete interleaving search.</li>
<li>'[…] miniKanren is being used for research in &quot;relational&quot; programming.'</li>
<li>&quot;Over time miniKanren has added more symbolic constraints, really becoming a symbolically-oriented Constraint Logic Programming language.&quot;</li>
<li>&quot;There are other very interesting logic programming languages as well, such as Mercury, Curry, and Gödel, each of which has its own take on logic programming.&quot;</li>
</ul></li>
</ul></li>
</ul>
<p>Mercury vs Prolog</p>
<ul>
<li><a href="http://lambda-the-ultimate.org/node/890">http://lambda-the-ultimate.org/node/890</a></li>
<li>&lt;2018-10-21&gt; &quot;The Prolog to Mercury transition guide&quot; <a href="https://www.mercurylang.org/information/doc-latest/transition_guide.pdf">https://www.mercurylang.org/information/doc-latest/transition_guide.pdf</a></li>
</ul>
<p>SQL? Datalog?</p>
<h3 id="programming-can-be-thought-of-as-applied-mathematics"><span class="section_number">15.5</span><span class="section_title">Programming can be thought of as applied mathematics?</span></h3>
<p>Prolog can be approached from logic, database theory, philosophy.</p>
<p>In Prolog, by default, function symbols mean themselves, and this gives us freedom to write interpreters to interpret function symbols differently.</p>
<h3 id="theorem-proving"><span class="section_number">15.6</span><span class="section_title">Theorem proving</span></h3>
<p>Problem statement of automated theorem proving: Given a formula G (query, goal), a set of axioms A, and a set of inference rules R, prove G.</p>
<p>A formula can be represented by a Prolog term.</p>
<p>An inference rule transforms a formula into another formula having the same truth value.</p>
<p>It may be better to write a theorem prover in Prolog than to use Prolog directly as theorem prover.</p>
<p>Prolog can be used as a theorem prover.</p>
<pre class="example"><code>p.
q :- p.

?- q.
true.
</code></pre>
<p>It is simple to write a theorem prover for propositional logic. But how about first-order logic?</p>
<p>What is resolution<a href="#fn97" class="footnote-ref" id="fnref97"><sup>97</sup></a>? Why is it widely used in automatic theorem proving?</p>
<p>Aren't theorem provers just constrained rewriting systems?</p>
<p>Modus ponens <span class="math inline">\( \alpha, (\alpha \to \beta) \vdash \beta \)</span>.</p>
<h3 id="logic-programming-vs-theorem-proving"><span class="section_number">15.7</span><span class="section_title">Logic programming vs theorem proving</span></h3>
<ul>
<li><a href="https://stackoverflow.com/questions/36335633/difference-between-logic-programming-and-automated-theorem-proving">https://stackoverflow.com/questions/36335633/difference-between-logic-programming-and-automated-theorem-proving</a></li>
<li><a href="https://en.wikipedia.org/wiki/Automated_theorem_proving">https://en.wikipedia.org/wiki/Automated_theorem_proving</a></li>
</ul>
<p>There is an inverse relationship between the cleverness of a theorem prover and its suitability for programming?</p>
<h3 id="avoid-using-list-too-much"><span class="section_number">15.8</span><span class="section_title">Avoid using list too much</span></h3>
<p>Perhaps think more about the relations between the individuals.</p>
<p>Perhaps normalize your predicates to sixth-normal form.</p>
<h3 id="minikanren"><span class="section_number">15.9</span><span class="section_title">miniKanren?</span></h3>
<p>Relational programming, microKanren <a href="http://matt.might.net/articles/microkanren/">http://matt.might.net/articles/microkanren/</a></p>
<p>2017 A Unified Approach to Solving Seven Programming Problems (Functional Pearl) <a href="http://io.livecode.ch/learn/gregr/icfp2017-artifact-auas7pp">http://io.livecode.ch/learn/gregr/icfp2017-artifact-auas7pp</a></p>
<p>2013 rKanren - Guided Search in miniKanren, Part I <a href="http://cgswords.github.io/rkanren/">http://cgswords.github.io/rkanren/</a></p>
<p>Schelog vs minikanren?</p>
<h3 id="dreams-speculations-ambitions"><span class="section_number">15.10</span><span class="section_title">Dreams, speculations, ambitions</span></h3>
<p>Harel 2008 <span class="citation" data-cites="harel2008can">[<a href="#ref-harel2008can">9</a>]</span> has a lovely ambition. But I'm afraid I see only two way to realize that ambition: either invent a human-level AI that can write software, or invent a machine that can do telepathy. But I believe that we will someday have at least one of that.</p>
<p>I want a browser like this. Each user should have total control of what runs on his/her machine. I should be able to tell my browser how to modify the CSS and JavaScript for certain websites. From <span class="citation" data-cites="harel2008can">[<a href="#ref-harel2008can">9</a>]</span>:</p>
<blockquote>
<p>[…] conveniently remove pieces of behavior that we don’t like and replace them with others […] I would love to be able to reprogram the interactions that the web-based systems I work with force me to follow—not to mention reprogramming my annoying and unnecessarily complicated DVD. I can’t change the way Amazon or B&amp;H respond to what I do, for example, but I can surely change everything that has to do with the way my browser and my computer deal with these websites. And how better to do that than by simply canceling some pieces of interactive behavior and playing in new ones, using the very interface on which we interact, subject, of course, to my inability to change their behavior?</p>
</blockquote>
<h3 id="dynamic-assert-retract"><span class="section_number">15.11</span><span class="section_title">Dynamic, assert, retract</span></h3>
<p>Assert accepts a clause.</p>
<pre class="example"><code>assert(man(fred)).
assert(p(A,B) :- f(A), g(A), h(A,B)).
</code></pre>
<h3 id="why-should-we-write-type-systems-as-macros"><span class="section_number">15.12</span><span class="section_title">Why should we write type systems as macros?</span></h3>
<p>WIP implementation of a Haskell-like Lisp in Racket <a href="https://github.com/lexi-lambda/hackett">https://github.com/lexi-lambda/hackett</a></p>
<p><a href="http://www.ccs.neu.edu/home/stchang/pubs/ckg-popl2017.pdf">http://www.ccs.neu.edu/home/stchang/pubs/ckg-popl2017.pdf</a></p>
<h2 id="extending-prolog"><span class="section_number">16</span><span class="section_title">Extending Prolog</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">16.1</span><span class="section_title"><a href="#first-order-logic-already-has-local-variable-scoping-and-local-assertion">First order logic already has local variable scoping and local assertion</a></span><span class="word_count">(21w~1m)</span></li>
<li><span class="section_number">16.2</span><span class="section_title"><a href="#logical-implication-is-local-variable-scoping">Logical implication is local variable scoping</a></span><span class="word_count">(70w~1m)</span></li>
</ul>
</div>
<h3 id="first-order-logic-already-has-local-variable-scoping-and-local-assertion"><span class="section_number">16.1</span><span class="section_title">First order logic already has local variable scoping and local assertion</span></h3>
<p>Scoping existential quantified.</p>
<p>Local assertion is implication.</p>
<p>We need more than Horn clauses.</p>
<h3 id="logical-implication-is-local-variable-scoping"><span class="section_number">16.2</span><span class="section_title">Logical implication is local variable scoping</span></h3>
<p>I have an example in <code>scope.pro</code>.</p>
<pre class="example"><code>fun :- (locvar(1) =&gt; locvar(A), format(&quot;locvar is ~w~n&quot;,[A]), nl).
</code></pre>
<p>The logical semantics of <code>A =&gt; B</code> is &quot;B is provable, if A is assumed to be true&quot;.</p>
<p>The operational semantics of <code>A =&gt; B</code> is:</p>
<ol>
<li>Assert A.</li>
<li>Call B.</li>
<li>Retract A.</li>
</ol>
<p>Problem: How do we &quot;undefine&quot; a local variable?</p>
<p>For example: In <code>A =&gt; B, (not(A) =&gt; C)</code>, we want A to be defined in B but undefined in C.</p>
<p>Why should we prefer monotonic logic?</p>
<h2 id="program-checking"><span class="section_number">17</span><span class="section_title">Program checking</span></h2>
<p>Motivation: We want two avoid stupid runtime mistakes that can be prevented before runtime (at &quot;compile&quot; time).</p>
<p>The problem: Given a Prolog term T, determine whether <code>call(T)</code> will throw a type error. Note that T may be a conjunction of goals.</p>
<p>I'm thinking about using abstract interpretation or partial deduction.</p>
<p>Program checking is partial deduction.</p>
<p>This program is a mistake.</p>
<pre class="example"><code>p(0).
mistake1 :- p(foo).
mistake2 :- number_string(_,_).
</code></pre>
<p>We can imagine a <code>check_goal/1</code> predicate.</p>
<p>The key idea is to unify a variable with its type.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">17.1</span><span class="section_title"><a href="#the-errors-prolog-programmers-make">The errors Prolog programmers make</a></span><span class="word_count">(58w~1m)</span></li>
<li><span class="section_number">17.2</span><span class="section_title"><a href="#typed-first-order-logic">Typed first-order logic</a></span><span class="word_count">(25w~1m)</span></li>
<li><span class="section_number">17.3</span><span class="section_title"><a href="#vanilla-prolog-type-checking">Vanilla Prolog type-checking</a></span><span class="word_count">(41w~1m)</span></li>
<li><span class="section_number">17.4</span><span class="section_title"><a href="#type-checking-interpreter">Type-checking interpreter</a></span><span class="word_count">(12w~1m)</span></li>
<li><span class="section_number">17.5</span><span class="section_title"><a href="#abstract-interpretation">Abstract interpretation</a></span><span class="word_count">(39w~1m)</span></li>
<li><span class="section_number">17.6</span><span class="section_title"><a href="#problem-the-type-of-variables">Problem: the type of variables</a></span><span class="word_count">(44w~1m)</span></li>
<li><span class="section_number">17.7</span><span class="section_title"><a href="#problem-non-terminating-predicates">Problem: non-terminating predicates</a></span><span class="word_count">(3w~1m)</span></li>
<li><span class="section_number">17.8</span><span class="section_title"><a href="#checking-when-unchecked-code-calls-checked-code">Checking when unchecked code calls checked code</a></span><span class="word_count">(7w~1m)</span></li>
<li><span class="section_number">17.9</span><span class="section_title"><a href="#manual-checking">Manual checking</a></span><span class="word_count">(2w~1m)</span></li>
</ul>
</div>
<h3 id="the-errors-prolog-programmers-make"><span class="section_number">17.1</span><span class="section_title">The errors Prolog programmers make</span></h3>
<p>The errors made by a Prolog programmer include:</p>
<ul>
<li>type error: instantiating an input argument to a term of a wrong type</li>
<li>mode error: not instantiating an input argument</li>
<li>termination error: infinite loop, left recursion</li>
</ul>
<p>In this example, the first argument of interpret is n/1 or a +/1.</p>
<pre class="example"><code>interpret(n(A),A).
interpret(A+B,C) :- C is A+B.
</code></pre>
<p>A call such as <code>interpret(1-2,A)</code> should raise an exception instead of failing.</p>
<h3 id="typed-first-order-logic"><span class="section_number">17.2</span><span class="section_title">Typed first-order logic</span></h3>
<p>Another name for typed logic is many-sorted logic.<a href="#fn98" class="footnote-ref" id="fnref98"><sup>98</sup></a></p>
<p>Typing relation relates symbol to type (Cartesian product of sets) Example: <span class="math inline">\( T(p^2, Integer \times String) \)</span>.</p>
<pre class="example"><code>type(p/2, relation([integer,string])).
</code></pre>
<h3 id="vanilla-prolog-type-checking"><span class="section_number">17.3</span><span class="section_title">Vanilla Prolog type-checking</span></h3>
<p>Suppose that we have a predicate <code>p/1</code> that expects an integer or a var. We can type-check it like this:</p>
<pre class="example"><code>% public
:- export(cp/1).
cp(A) :-
    check_or_throw(p(A),before),
    p(A),
    check_or_throw(p(A),after).

% private
p(0).
p(1).

check(p(A),before) :- integer(A).
check(p(A),before) :- var(A).

check(p(A),after) :- integer(A).

check_or_throw(A,T) :- check(A,T), !.
check_or_throw(A,T) :- throw(error(check_failed(A,T),_)).
</code></pre>
<p>The advantage is that it is vanilla Prolog. No domain-specific type-specification languages.</p>
<p>The disadvantage is that it is often done unnecessarily.</p>
<h3 id="type-checking-interpreter"><span class="section_number">17.4</span><span class="section_title">Type-checking interpreter</span></h3>
<p>One step further than that is to make a checking interpreter.</p>
<pre class="example"><code>cp(A) :- interpret(p(A)).

interpret(G) :- check(G,before), call(G), check(G,after).
</code></pre>
<h3 id="abstract-interpretation"><span class="section_number">17.5</span><span class="section_title">Abstract interpretation</span></h3>
<p>The semantics is: If the check succeeds, then the goal will not fail due to stupid type error.</p>
<p>Unsatisfiability is not a type error. For example, the following <code>q/1</code> is <em>unsatisfiable</em>, but it does not throw a type error.</p>
<pre class="example"><code>p(0).

q(A) :- p(A), A = 1.
</code></pre>
<h3 id="problem-the-type-of-variables"><span class="section_number">17.6</span><span class="section_title">Problem: the type of variables</span></h3>
<p>We mean the type of the term bound to the variable. Attributed variables are suitable for this scenario. But not all Prolog implementations have attributed variables. So we use gensym?</p>
<p>Type-checking variables would be easier if Prolog variables were explicitly quantified.</p>
<h3 id="problem-non-terminating-predicates"><span class="section_number">17.7</span><span class="section_title">Problem: non-terminating predicates</span></h3>
<pre class="example"><code>check(p(A,B),before) :- integer(A).
check(p(A,B),after) :- string(B).

p(A,B) :- p(A,B).
</code></pre>
<h3 id="checking-when-unchecked-code-calls-checked-code"><span class="section_number">17.8</span><span class="section_title">Checking when unchecked code calls checked code</span></h3>
<h3 id="manual-checking"><span class="section_number">17.9</span><span class="section_title">Manual checking</span></h3>
<pre class="example"><code>interpret(A,_) :- var(A), !, instantiation_error(A).
interpret(A,_) :- \+exp(A), !, type_error(exp,A).
interpret(n(A),Z) :- !, Z=A.
interpret(A+B,Z) :- !, Z is A+B.
interpret(A*B,Z) :- !, Z is A*B.

exp(n(_)).
exp(_+_).
exp(_*_).
</code></pre>
<h2 id="sometimes-we-want-function-and-determinism"><span class="section_number">18</span><span class="section_title">Sometimes we want function and determinism</span></h2>
<p>Sometimes we really want to write a function and not a general relation. The sign of such unfilfilled desire is: Each clause begins with pattern-matching and cut, as in this example:</p>
<pre class="example"><code>interpret(n(A),Z) :- !, Z=A.
interpret(A+B,Z) :- !, interpret(A,A0), interpret(B,B0), Z is A0+B0.
interpret(A*B,Z) :- !, interpret(A,A0), interpret(B,B0), Z is A0*B0.
</code></pre>
<p>It would be nice if we could write it in a functional style like this which might then be rewritten with <code>term_expansion/2</code>:</p>
<pre class="example"><code>:- function interpret(E) = case(E,[
    n(A) -&gt; A
    , A+B -&gt; interpret(A) + interpret(B)
    , A*B -&gt; interpret(A) * interpret(B)
]).
</code></pre>
<h2 id="prolog-implementation"><span class="section_number">19</span><span class="section_title">Prolog implementation</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">19.1</span><span class="section_title"><a href="#how-would-we-implement-prolog-in-c">How would we implement Prolog in C?</a></span><span class="word_count">(79w~1m)</span></li>
<li><span class="section_number">19.2</span><span class="section_title"><a href="#why-does-swi-prolog-use-git-submodules-instead-of-a-mono-repo">Why does SWI-Prolog use Git submodules instead of a mono-repo?</a></span><span class="word_count">(121w~1m)</span></li>
<li><span class="section_number">19.3</span><span class="section_title"><a href="#how-to-contribute-to-swi-prolog">How to contribute to SWI-Prolog?</a></span><span class="word_count">(33w~1m)</span></li>
<li><span class="section_number">19.4</span><span class="section_title"><a href="#foreign-language-interface">Foreign language interface</a></span><span class="word_count">(241w~2m)</span></li>
<li><span class="section_number">19.5</span><span class="section_title"><a href="#what-is-a-unicode-character">What is a Unicode character?</a></span><span class="word_count">(47w~1m)</span></li>
<li><span class="section_number">19.6</span><span class="section_title"><a href="#the-problem-with-dynamic-database">The problem with dynamic database</a></span><span class="word_count">(48w~1m)</span></li>
<li><span class="section_number">19.7</span><span class="section_title"><a href="#prolog-parser-in-prolog">Prolog parser in Prolog</a></span><span class="word_count">(4w~1m)</span></li>
<li><span class="section_number">19.8</span><span class="section_title"><a href="#java">Java</a></span><span class="word_count">(1w~1m)</span></li>
<li><span class="section_number">19.9</span><span class="section_title"><a href="#p-translates-prolog-to-c.">P# translates Prolog to C#.</a></span><span class="word_count">(5w~1m)</span></li>
</ul>
</div>
<h3 id="how-would-we-implement-prolog-in-c"><span class="section_number">19.1</span><span class="section_title">How would we implement Prolog in C?</span></h3>
<p>I am thinking of these:</p>
<ul>
<li>struct Prolog_interpreter</li>
<li>struct Prolog_term</li>
</ul>
<p>But there are no integers in logic; there are only logical symbols and non-logical symbols.</p>
<pre class="example"><code>// .h

struct Prolog_term_;
typedef struct Prolog_term_ Prolog_term;

bool prolog_term_as_int (const Prolog_term*, int*);
bool prolog_term_as_strz (const Prolog_term*, size_t, char*);

// .c

struct Prolog_interpreter {
    Prolog_term* clauses;
    size_t cap;
};

enum Prolog_term_type {
    Prolog_integer = 0, // but there are no integers in logic?
    Prolog_string = 1,
    Prolog_atom = 2,
    Prolog_functor = 3,
    Prolog_var = 4,
    Prolog_foreign_object = 5,
};

struct Prolog_term_ {
    Prolog_term_type type;
};

struct Prolog_string {
    Prolog_term_ term;
    size_t num_bytes;
    char* bytes;
};

struct Prolog_atom {
    Prolog_term_ term;
    int id;
    Prolog_string* string;
};

struct Prolog_functor {
    Prolog_term_ term;
    Prolog_atom name;
    size_t arity;
    Prolog_term* args;
};

struct Prolog_var {
    Prolog_term_ term;
    Prolog_term* value; // NULL if unbound
};

bool prolog_unify (Prolog_term* a, Prolog_term* b) {
    // ???
}
</code></pre>
<p>We can use GMP (GNU multiprecision math library) for arbitrary-precision arithmetics. &quot;GNU MP is a portable library written in C for arbitrary precision arithmetic on integers, rational numbers, and floating-point numbers.&quot;<a href="#fn99" class="footnote-ref" id="fnref99"><sup>99</sup></a></p>
<p>What a C preprocessor does is explained in GNU CPP Overview<a href="#fn100" class="footnote-ref" id="fnref100"><sup>100</sup></a>.</p>
<p>How does SWI-Prolog implement Prolog in C?</p>
<p>SWI-Prolog has the macros <code>PL_succeed</code> and <code>PL_fail</code>.</p>
<h3 id="why-does-swi-prolog-use-git-submodules-instead-of-a-mono-repo"><span class="section_number">19.2</span><span class="section_title">Why does SWI-Prolog use Git submodules instead of a mono-repo?</span></h3>
<p>&lt;2019-04-06&gt; Jan Wielemaker wrote on Discourse<a href="#fn101" class="footnote-ref" id="fnref101"><sup>101</sup></a>:</p>
<blockquote>
<p>Submodules have had their value in the past when several of the modules were practically managed by other people. At the moment all package modules are practically in maintenance stage and this doesn’t matter too much, but I still like to be able to do so. Submodules were also intended to be shared with other Prolog systems. That too isn’t active right now, but work is going on between XSB and SWI, so who knows?</p>
</blockquote>
<p>XSB Prolog source code is in a Subversion repository.</p>
<p>Reading &quot;Subversion Design&quot;<a href="#fn102" class="footnote-ref" id="fnref102"><sup>102</sup></a> helps us understand SVN.</p>
<ul>
<li>Subversion can track an empty directory. Git cannot.</li>
<li>Both SVN<a href="#fn103" class="footnote-ref" id="fnref103"><sup>103</sup></a><a href="#fn104" class="footnote-ref" id="fnref104"><sup>104</sup></a> and Git have problems with merge conflicts that involve renames.</li>
</ul>
<h3 id="how-to-contribute-to-swi-prolog"><span class="section_number">19.3</span><span class="section_title">How to contribute to SWI-Prolog?</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">19.3.1</span><span class="section_title"><a href="#how-to-clone-the-git-repository">How to clone the Git repository?</a></span><span class="word_count">(29w~1m)</span></li>
</ul>
</div>
<h4 id="how-to-clone-the-git-repository"><span class="section_number">19.3.1</span><span class="section_title">How to clone the Git repository?</span></h4>
<p>&lt;2019-04-06&gt; SubmitPatch.html<a href="#fn105" class="footnote-ref" id="fnref105"><sup>105</sup></a> is a little messy. See unix.html<a href="#fn106" class="footnote-ref" id="fnref106"><sup>106</sup></a> about git submodules. See also Discourse<a href="#fn107" class="footnote-ref" id="fnref107"><sup>107</sup></a>.</p>
<p>It is not a simple git-clone, because we are using submodules.</p>
<h3 id="foreign-language-interface"><span class="section_number">19.4</span><span class="section_title">Foreign language interface</span></h3>
<p>SWI-Prolog has a foreign language interface<a href="#fn108" class="footnote-ref" id="fnref108"><sup>108</sup></a>, but I demand more.</p>
<p>I want to call C code from Prolog without writing a C wrapper. I want Prolog to marshal the arguments and unmarshal the return values.</p>
<p>Even more, I want to write low-level code <em>directly in Prolog</em>. A solution already exists: SWI-Prolog pack &quot;ffi&quot;:<a href="#fn109" class="footnote-ref" id="fnref109"><sup>109</sup></a></p>
<ul>
<li>&quot;This package deals with calling C functions from shared objects (DLLs) from Prolog without writing wrappers&quot;</li>
<li>It parses C header files and C source files!</li>
</ul>
<p>I want to write C code in Prolog. I want to have C with type inference and other cool features in Prolog.</p>
<p>I dream of writing foreign code directly in Prolog. I dream of a Prolog code that can output an amd64 ELF binary. Related in mailing list<a href="#fn110" class="footnote-ref" id="fnref110"><sup>110</sup></a>. Related from the 1990s<a href="#fn111" class="footnote-ref" id="fnref111"><sup>111</sup></a>. Related: Warren 1980 <span class="citation" data-cites="warren1980logic">[<a href="#ref-warren1980logic">29</a>]</span>.</p>
<p>There are two problems: emitting machine code, and executing machine code.</p>
<p>Options for emitting machine code:</p>
<ul>
<li>Design a DSL like ASN.1 to describe binary layout such as C struct or Pascal record. I have a sketch in database_internal_dcg.pro.</li>
<li>Design an language that can be represented in Prolog and translated to C.</li>
<li>Reuse LLVM.</li>
<li>Building something like LLVM. Write our own intermediate representation. Static-single-assignment three-address code.</li>
<li>Write amd64 machine code directly. This is bad. Too tightly coupled. We will want to generate i386, arm, and jvm machine codes.</li>
</ul>
<p>Options for executing machine code:</p>
<ul>
<li>Write machine code to some memory area, set PROT_EXEC with mprotect, and call the address.</li>
<li>Write an ELF SO object and use dlopen.</li>
</ul>
<p>The skeleton of the minimum viable product:</p>
<pre class="example"><code>example :-
    compile(ret, ByteCode),
    write_bytes(ByteCode).

nb_write_address(+Address, -Thing)
</code></pre>
<h3 id="what-is-a-unicode-character"><span class="section_number">19.5</span><span class="section_title">What is a Unicode character?</span></h3>
<p>This question is tricky.</p>
<p>Does a character correspond to a code point?</p>
<p>What about accents, ligatures, etc.?</p>
<p>Is an accent by itself a character?</p>
<p>Is a hanzi radical a character?</p>
<p>Is a hanzi a character?</p>
<p>How many bytes are in a character?</p>
<p>What are equivalent characters? What is Unicode normalization?<a href="#fn112" class="footnote-ref" id="fnref112"><sup>112</sup></a></p>
<h3 id="the-problem-with-dynamic-database"><span class="section_number">19.6</span><span class="section_title">The problem with dynamic database</span></h3>
<pre class="example"><code>do_something :-
    assert(a), ...
</code></pre>
<p>Dynamic database is like global variable. There can only be one instance of <code>do_something</code> running without confusing the dynamic database.</p>
<p>But we can replace each occurence of <code>assert(A)</code> with <code>assert(local(G,A))</code> where G is generated by <code>gensym/2</code>. This is like rewriting C global variables into structs.</p>
<pre class="example"><code>int x;
int f () {
    return x;
}

// becomes

struct global {
    int x;
};

int f (struct global* g) {
    return g-&gt;x;
}
</code></pre>
<h3 id="prolog-parser-in-prolog"><span class="section_number">19.7</span><span class="section_title">Prolog parser in Prolog</span></h3>
<p><a href="https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/parser.html">https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/parser.html</a></p>
<h3 id="java"><span class="section_number">19.8</span><span class="section_title">Java</span></h3>
<p><a href="https://stackoverflow.com/questions/1817010/embedded-prolog-interpreter-compiler-for-java">https://stackoverflow.com/questions/1817010/embedded-prolog-interpreter-compiler-for-java</a></p>
<p><a href="https://github.com/raydac/java-prolog-parser">https://github.com/raydac/java-prolog-parser</a></p>
<h3 id="p-translates-prolog-to-c."><span class="section_number">19.9</span><span class="section_title">P# translates Prolog to C#.</span></h3>
<p><a href="https://pdfs.semanticscholar.org/12ec/568a6583d3d66b6821f28269f06937a9f2eb.pdf">https://pdfs.semanticscholar.org/12ec/568a6583d3d66b6821f28269f06937a9f2eb.pdf</a></p>
<h2 id="swi-prolog-packs"><span class="section_number">20</span><span class="section_title">SWI-Prolog packs</span></h2>
<p>I want to use a pack. I want to know:</p>
<ul>
<li>How do I install a pack the easy way? Use <code>pack_install/1</code>.</li>
<li>How do I install a pack manually outside SWI-Prolog without <code>pack_install/1</code>?</li>
<li>How do I install a specific version of a pack?</li>
<li>How do I freeze my dependencies to avoid silent breakage?</li>
<li>How do I use multiple versions of a pack? My program depends on A and B. A depends on C version 1. B depends on C version 2. It seems the packs must be updated.</li>
<li>To what directory are packs installed? <code>pack_install/1</code> will prompt you where to install.</li>
</ul>
<h2 id="what-i-like-about-prolog-and-lisp"><span class="section_number">21</span><span class="section_title">What I like about Prolog and Lisp</span></h2>
<p>I can see the source code of everything as long as it is loaded and is non-foreign. Prolog has <code>listing/1</code> and <code>edit/1</code> and <code>help/1</code>. Emacs has <code>M-x find-function</code><a href="#fn113" class="footnote-ref" id="fnref113"><sup>113</sup></a> and <code>C-h f</code> or <code>M-x describe-function</code>. SBCL has <code>describe</code>.<a href="#fn114" class="footnote-ref" id="fnref114"><sup>114</sup></a></p>
<p>We can think of Prolog as Lisp with M-expression instead of S-expression.</p>
<h2 id="namespacing-atoms"><span class="section_number">22</span><span class="section_title">Namespacing atoms</span></h2>
<p>When we write a predicate that deconstructs an instance of an algebraic data type, we don't want the constructors to be namespaced.</p>
<p>When we use an atom as a name under the unique name assumption, in a multifile predicate, sometimes we want the atom to be namespaced.</p>
<h2 id="parsing-prolog"><span class="section_number">23</span><span class="section_title">Parsing Prolog?</span></h2>
<p>Prolog's grammar is <em>adaptive</em><a href="#fn115" class="footnote-ref" id="fnref115"><sup>115</sup></a>: the <code>op/3</code> directive changes the grammar.</p>
<h2 id="other-resources"><span class="section_number">24</span><span class="section_title">Other resources</span></h2>
<p><a href="https://faculty.nps.edu/ncrowe/book/book.html">Rowe 1988 book</a>: Artificial Intelligence through Prolog by Neil C. Rowe</p>
<h2 id="bibliography" class="unnumbered"><span class="section_number">25</span><span class="section_title">Bibliography</span></h2>
<div id="refs" class="references">
<div id="ref-afshari2012liberating">
<p>[1] Afshari, M. et al. 2012. Liberating the programmer with prorogued programming. <em>Proceedings of the acm international symposium on new ideas, new paradigms, and reflections on programming and software</em> (2012), 11–26. url: &lt;<a href="http://earlbarr.com/publications/prorogue.pdf">http://earlbarr.com/publications/prorogue.pdf</a>&gt;.</p>
</div>
<div id="ref-beeson2004lambda">
<p>[2] Beeson, M. 2004. Lambda logic. <em>International joint conference on automated reasoning</em> (2004), 460–474. url: &lt;<a href="https://pdfs.semanticscholar.org/9721/c012782ef25023ac300e33d6ce34ffed7e18.pdf">https://pdfs.semanticscholar.org/9721/c012782ef25023ac300e33d6ce34ffed7e18.pdf</a>&gt;.</p>
</div>
<div id="ref-boizumault2014implementation">
<p>[3] Boizumault, P. 2014. <em>The implementation of prolog</em>. Princeton University Press.</p>
</div>
<div id="ref-cabeza2000new">
<p>[4] Cabeza, D. and Hermenegildo, M. 2000. A new module system for prolog. <em>International conference on computational logic</em> (2000), 131–148. url: &lt;<a href="https://core.ac.uk/download/pdf/148663021.pdf">https://core.ac.uk/download/pdf/148663021.pdf</a>&gt;.</p>
</div>
<div id="ref-ciancarini1993logic">
<p>[5] Ciancarini, P. and Levi, G. 1993. What is logic programming good for in software engineering? <em>Advances in software engineering and knowledge engineering</em>. World Scientific. 109–134. url: &lt;<a href="https://pdfs.semanticscholar.org/2597/345fc719960dc214f41ad439ef9124ade1c6.pdf">https://pdfs.semanticscholar.org/2597/345fc719960dc214f41ad439ef9124ade1c6.pdf</a>&gt;.</p>
</div>
<div id="ref-colmerauer1996birth">
<p>[6] Colmerauer, A. and Roussel, P. 1996. The birth of prolog. <em>History of programming languages—ii</em> (1996), 331–367. url: &lt;<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.7438&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.7438&amp;rep=rep1&amp;type=pdf</a>&gt;.</p>
</div>
<div id="ref-demoen2005first">
<p>[7] Demoen, B. et al. 2005. The first 10 prolog programming contests. Bart Demoen. url: &lt;<a href="https://dtai.cs.kuleuven.be/ppcbook/ppcbook.pdf">https://dtai.cs.kuleuven.be/ppcbook/ppcbook.pdf</a>&gt;.</p>
</div>
<div id="ref-haemmerle2006modules">
<p>[8] Haemmerlé, R. and Fages, F. 2006. Modules for prolog revisited. <em>International conference on logic programming</em> (2006), 41–55. url: &lt;<a href="https://www.researchgate.net/profile/Francois_Fages/publication/220986844_Modules_for_Prolog_Revisited/links/00b495277f5b9dd5ce000000/Modules-for-Prolog-Revisited.pdf">https://www.researchgate.net/profile/Francois_Fages/publication/220986844_Modules_for_Prolog_Revisited/links/00b495277f5b9dd5ce000000/Modules-for-Prolog-Revisited.pdf</a>&gt;.</p>
</div>
<div id="ref-harel2008can">
<p>[9] Harel, D. 2008. Can programming be liberated, period? <em>Computer</em>. 41, 1 (2008), 28–37. url: &lt;<a href="http://www.wisdom.weizmann.ac.il/~harel/papers/LiberatingProgramming.pdf">http://www.wisdom.weizmann.ac.il/~harel/papers/LiberatingProgramming.pdf</a>&gt;.</p>
</div>
<div id="ref-jarke1984optimizing">
<p>[10] Jarke, M. et al. 1984. An optimizing prolog front-end to a relational query system. <em>ACM sigmod record</em> (1984), 296–306. url: &lt;<a href="https://archive.nyu.edu/jspui/bitstream/2451/14555/1/IS-84-24.pdf">https://archive.nyu.edu/jspui/bitstream/2451/14555/1/IS-84-24.pdf</a>&gt;.</p>
</div>
<div id="ref-jones1993partial">
<p>[11] Jones, N.D. et al. 1993. <em>Partial evaluation and automatic program generation</em>. Peter Sestoft. url: &lt;<a href="http://www.itu.dk/~sestoft/pebook/jonesgomardsestoft-a4.pdf">http://www.itu.dk/~sestoft/pebook/jonesgomardsestoft-a4.pdf</a>&gt;.</p>
</div>
<div id="ref-kowalski1974predicate">
<p>[12] Kowalski, R. 1974. Predicate logic as programming language. <em>IFIP congress</em> (1974), 569–544. url: &lt;<a href="http://www.doc.ic.ac.uk/~rak/papers/IFIP%2074.pdf">http://www.doc.ic.ac.uk/~rak/papers/IFIP%2074.pdf</a>&gt;.</p>
</div>
<div id="ref-liu2018logic">
<p>[13] Liu, Y.A. 2018. Logic programming applications: What are the abstractions and implementations? <em>Declarative logic programming</em> (2018), 519–548. url: &lt;<a href="https://arxiv.org/pdf/1802.07284.pdf">https://arxiv.org/pdf/1802.07284.pdf</a>&gt;.</p>
</div>
<div id="ref-maclennan1981introduction">
<p>[14] MacLennan, B.J. 1981. <em>Introduction to relational programming.</em> Naval Postgraduate School, Monterey, CA. url: &lt;<a href="https://apps.dtic.mil/dtic/tr/fulltext/u2/a101435.pdf">https://apps.dtic.mil/dtic/tr/fulltext/u2/a101435.pdf</a>&gt;.</p>
</div>
<div id="ref-maclennan1981overview">
<p>[15] MacLennan, B.J. 1981. <em>Overview of relational programming.</em> Naval Postgraduate School, Monterey, CA. url: &lt;<a href="https://apps.dtic.mil/dtic/tr/fulltext/u2/a114462.pdf">https://apps.dtic.mil/dtic/tr/fulltext/u2/a114462.pdf</a>&gt;.</p>
</div>
<div id="ref-maclennan1983relational">
<p>[16] MacLennan, B.J. 1983. <em>Relational programming.</em> Naval Postgraduate School, Monterey, CA. url: &lt;<a href="https://apps.dtic.mil/dtic/tr/fulltext/u2/a133643.pdf">https://apps.dtic.mil/dtic/tr/fulltext/u2/a133643.pdf</a>&gt;.</p>
</div>
<div id="ref-miller1986theory">
<p>[17] Miller, D. 1986. <em>A theory of modules for logic programming</em>. url: &lt;<a href="http://www.lix.polytechnique.fr/~dale/papers/slp86.pdf">http://www.lix.polytechnique.fr/~dale/papers/slp86.pdf</a>&gt;.</p>
</div>
<div id="ref-miller2012programming">
<p>[18] Miller, D. and Nadathur, G. 2012. <em>Programming with higher-order logic</em>. Cambridge University Press.</p>
</div>
<div id="ref-pmoura2003logtalk">
<p>[19] Moura, P. 2003. <em>Logtalk - Design of an Object-Oriented Logic Programming Language</em>. Department of Computer Science, University of Beira Interior, Portugal. url: &lt;<a href="https://logtalk.org/papers/thesis.pdf">https://logtalk.org/papers/thesis.pdf</a>&gt;.</p>
</div>
<div id="ref-nadathur1988overview">
<p>[20] Nadathur, G. and Miller, D. 1988. An overview of lambda-prolog. (1988). url: &lt;<a href="http://www.lix.polytechnique.fr/~dale/papers/iclp88.pdf">http://www.lix.polytechnique.fr/~dale/papers/iclp88.pdf</a>&gt;.</p>
</div>
<div id="ref-naish1996higher">
<p>[21] Naish, L. 1996. Higher-order logic programming in prolog. <em>Proc. Workshop on multi-paradigm logic programming, jicslp</em> (1996), 1–23. url: &lt;<a href="https://pdfs.semanticscholar.org/904a/b2253330cdd379c7a405f400c6f9152afdca.pdf">https://pdfs.semanticscholar.org/904a/b2253330cdd379c7a405f400c6f9152afdca.pdf</a>&gt;.</p>
</div>
<div id="ref-Peytonjones2000TacklingTA">
<p>[22] Peyton-Jones, S. 2000. Tackling the awkward squad: Monadic input/output, concurrency, exceptions, and foreign-language call. (2000). url: &lt;<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf</a>&gt;.</p>
</div>
<div id="ref-porto2011structured">
<p>[23] Porto, A. 2011. A structured alternative to prolog with simple compositional semantics. <em>Theory and Practice of Logic Programming</em>. 11, 4-5 (2011), 611–627. url: &lt;<a href="https://arxiv.org/pdf/1107.5408.pdf">https://arxiv.org/pdf/1107.5408.pdf</a>&gt;.</p>
</div>
<div id="ref-robinson1965machine">
<p>[24] Robinson, J.A. and others 1965. A machine-oriented logic based on the resolution principle. <em>Journal of the ACM</em>. 12, 1 (1965), 23–41. url: &lt;<a href="https://web.stanford.edu/class/linguist289/robinson65.pdf">https://web.stanford.edu/class/linguist289/robinson65.pdf</a>&gt;.</p>
</div>
<div id="ref-shieber1995principles">
<p>[25] Shieber, S.M. et al. 1995. Principles and implementation of deductive parsing. <em>The Journal of logic programming</em>. 24, 1-2 (1995), 3–36. url: &lt;<a href="https://www.eecs.harvard.edu/shieber/Biblio/Papers/infer.pdf">https://www.eecs.harvard.edu/shieber/Biblio/Papers/infer.pdf</a>&gt;.</p>
</div>
<div id="ref-shields2002first">
<p>[26] Shields, M. and Jones, S.P. 2002. First-class modules for haskell. <em>9th international conference on foundations of object-oriented languages (fool 9), portland, oregon</em> (2002), 28–40. url: &lt;<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/first_class_modules.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/first_class_modules.pdf</a>&gt;.</p>
</div>
<div id="ref-sterling1996logic">
<p>[27] Sterling, L. and Yalçinalp, Ü. 1996. Logic programming and software engineering—implications for software design. <em>The Knowledge Engineering Review</em>. 11, 4 (1996), 333–345. url: &lt;<a href="https://pdfs.semanticscholar.org/a58d/c68f53af502c043793f49e5cd7c7a44d2914.pdf">https://pdfs.semanticscholar.org/a58d/c68f53af502c043793f49e5cd7c7a44d2914.pdf</a>&gt;.</p>
</div>
<div id="ref-van1976semantics">
<p>[28] Van Emden, M.H. and Kowalski, R.A. 1976. The semantics of predicate logic as a programming language. <em>Journal of the ACM (JACM)</em>. 23, 4 (1976), 733–742. url: &lt;<a href="https://www.doc.ic.ac.uk/~rak/papers/kowalski-van_emden.pdf">https://www.doc.ic.ac.uk/~rak/papers/kowalski-van_emden.pdf</a>&gt;.</p>
</div>
<div id="ref-warren1980logic">
<p>[29] Warren, D.H. 1980. Logic programming and compiler writing. <em>Software: Practice and Experience</em>. 10, 2 (1980), 97–125. url: &lt;<a href="http://sovietov.com/tmp/warren1980.pdf">http://sovietov.com/tmp/warren1980.pdf</a>&gt;.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://www.amzi.com/manuals/amzi/pro/ref_io.htm">https://www.amzi.com/manuals/amzi/pro/ref_io.htm</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><a href="http://www.swi-prolog.org/pldoc/doc_for?object=open/4">http://www.swi-prolog.org/pldoc/doc_for?object=open/4</a><a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><a href="http://eclipseclp.org/doc/bips/kernel/iostream/open-4.html">http://eclipseclp.org/doc/bips/kernel/iostream/open-4.html</a><a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><a href="http://www.gprolog.org/manual/html_node/gprolog034.html#open%2F4">http://www.gprolog.org/manual/html_node/gprolog034.html#open%2F4</a><a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><a href="https://sicstus.sics.se/sicstus/docs/4.2.1/html/sicstus/mpg_002dref_002dopen.html">https://sicstus.sics.se/sicstus/docs/4.2.1/html/sicstus/mpg_002dref_002dopen.html</a><a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><a href="https://ciao-lang.org/docs/1.14/13646/CiaoDE-1.14.2-13646_ciao.html/streams_basic.html#open/4">https://ciao-lang.org/docs/1.14/13646/CiaoDE-1.14.2-13646_ciao.html/streams_basic.html#open/4</a><a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p><a href="http://www.swi-prolog.org/FAQ/PrologLAMP.txt">http://www.swi-prolog.org/FAQ/PrologLAMP.txt</a><a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p><a href="https://www3.hhu.de/stups/prob/index.php/Why_Prolog%3F">https://www3.hhu.de/stups/prob/index.php/Why_Prolog%3F</a><a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p><a href="https://www.semanticscholar.org/paper/On-the-Implementation-of-GNU-Prolog-Diaz-Abreu/2c4f697f96202f988602e88c49625a862a4ce696">https://www.semanticscholar.org/paper/On-the-Implementation-of-GNU-Prolog-Diaz-Abreu/2c4f697f96202f988602e88c49625a862a4ce696</a><a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p><a href="https://en.wikipedia.org/wiki/Comparison_of_Prolog_implementations">https://en.wikipedia.org/wiki/Comparison_of_Prolog_implementations</a><a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p><a href="http://www.david-reitter.com/compling/prolog/compare.html">http://www.david-reitter.com/compling/prolog/compare.html</a><a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p><a href="http://www.fraber.de/university/prolog/comparison.html">http://www.fraber.de/university/prolog/comparison.html</a><a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p><a href="http://tau-prolog.org/">http://tau-prolog.org/</a><a href="#fnref13" class="footnote-back">↩</a></p></li>
<li id="fn14"><p><a href="http://www.swi-prolog.org/IDE.html">http://www.swi-prolog.org/IDE.html</a><a href="#fnref14" class="footnote-back">↩</a></p></li>
<li id="fn15"><p><a href="https://stackoverflow.com/questions/5277263/good-ide-to-get-started-with-prolog">https://stackoverflow.com/questions/5277263/good-ide-to-get-started-with-prolog</a><a href="#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p><a href="https://swi-prolog.discourse.group">https://swi-prolog.discourse.group</a><a href="#fnref16" class="footnote-back">↩</a></p></li>
<li id="fn17"><p><a href="https://groups.google.com/forum/#!forum/swi-prolog">https://groups.google.com/forum/#!forum/swi-prolog</a><a href="#fnref17" class="footnote-back">↩</a></p></li>
<li id="fn18"><p><a href="https://github.com/klauscfhq/awesome-prolog/blob/master/readme.md">https://github.com/klauscfhq/awesome-prolog/blob/master/readme.md</a><a href="#fnref18" class="footnote-back">↩</a></p></li>
<li id="fn19"><p><a href="https://stackoverflow.com/questions/14168363/what-does-a-clause-without-a-head-mean-in-prolog">https://stackoverflow.com/questions/14168363/what-does-a-clause-without-a-head-mean-in-prolog</a><a href="#fnref19" class="footnote-back">↩</a></p></li>
<li id="fn20"><p><a href="https://en.wikipedia.org/wiki/Abraham%27s_family_tree">https://en.wikipedia.org/wiki/Abraham%27s_family_tree</a><a href="#fnref20" class="footnote-back">↩</a></p></li>
<li id="fn21"><p><a href="https://en.wikipedia.org/wiki/SLD_resolution">https://en.wikipedia.org/wiki/SLD_resolution</a><a href="#fnref21" class="footnote-back">↩</a></p></li>
<li id="fn22"><p><a href="http://www.swi-prolog.org/pldoc/man?section=implhistory">http://www.swi-prolog.org/pldoc/man?section=implhistory</a><a href="#fnref22" class="footnote-back">↩</a></p></li>
<li id="fn23"><p><a href="https://vanemden.wordpress.com">https://vanemden.wordpress.com</a><a href="#fnref23" class="footnote-back">↩</a></p></li>
<li id="fn24"><p><a href="https://vanemden.wordpress.com/2017/09/08/conceptual-integrity-why-it-matters-and-how-to-get-it/">https://vanemden.wordpress.com/2017/09/08/conceptual-integrity-why-it-matters-and-how-to-get-it/</a><a href="#fnref24" class="footnote-back">↩</a></p></li>
<li id="fn25"><p><a href="https://en.wikipedia.org/wiki/Extension_(predicate_logic)">https://en.wikipedia.org/wiki/Extension_(predicate_logic)</a><a href="#fnref25" class="footnote-back">↩</a></p></li>
<li id="fn26"><p><a href="https://en.wikipedia.org/wiki/Fire_triangle">https://en.wikipedia.org/wiki/Fire_triangle</a><a href="#fnref26" class="footnote-back">↩</a></p></li>
<li id="fn27"><p><a href="http://www.swi-prolog.org/pldoc/man?section=ext-compound-zero">http://www.swi-prolog.org/pldoc/man?section=ext-compound-zero</a><a href="#fnref27" class="footnote-back">↩</a></p></li>
<li id="fn28"><p><a href="http://www.swi-prolog.org/pack/list?p=plgi">http://www.swi-prolog.org/pack/list?p=plgi</a><a href="#fnref28" class="footnote-back">↩</a></p></li>
<li id="fn29"><p><a href="https://github.com/SWI-Prolog/roadmap/issues/29">https://github.com/SWI-Prolog/roadmap/issues/29</a><a href="#fnref29" class="footnote-back">↩</a></p></li>
<li id="fn30"><p><a href="http://www.swi-prolog.org/packages/xpce/UserGuide/exeobjects.html">http://www.swi-prolog.org/packages/xpce/UserGuide/exeobjects.html</a><a href="#fnref30" class="footnote-back">↩</a></p></li>
<li id="fn31"><p><a href="https://www.reddit.com/r/linux/comments/2dxik3/future_of_gnome_and_gtk_when_whole_world_is/">https://www.reddit.com/r/linux/comments/2dxik3/future_of_gnome_and_gtk_when_whole_world_is/</a><a href="#fnref31" class="footnote-back">↩</a></p></li>
<li id="fn32"><p><a href="https://www.reddit.com/r/linuxmasterrace/comments/7xkcwo/why_does_everyone_hate_gtk/">https://www.reddit.com/r/linuxmasterrace/comments/7xkcwo/why_does_everyone_hate_gtk/</a><a href="#fnref32" class="footnote-back">↩</a></p></li>
<li id="fn33"><p><a href="http://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/plunit.html%27)">http://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/plunit.html%27)</a><a href="#fnref33" class="footnote-back">↩</a></p></li>
<li id="fn34"><p><a href="https://logtalk.org/tools.html">https://logtalk.org/tools.html</a><a href="#fnref34" class="footnote-back">↩</a></p></li>
<li id="fn35"><p><a href="https://logtalk.org/manuals/userman/documenting.html">https://logtalk.org/manuals/userman/documenting.html</a><a href="#fnref35" class="footnote-back">↩</a></p></li>
<li id="fn36"><p><a href="https://logtalk.org/manuals/userman/declarative.html">https://logtalk.org/manuals/userman/declarative.html</a><a href="#fnref36" class="footnote-back">↩</a></p></li>
<li id="fn37"><p><a href="http://www.swi-prolog.org/pldoc/man?section=strings">http://www.swi-prolog.org/pldoc/man?section=strings</a><a href="#fnref37" class="footnote-back">↩</a></p></li>
<li id="fn38"><p><a href="http://www.swi-prolog.org/pldoc/man?section=ext-dquotes-motivation">http://www.swi-prolog.org/pldoc/man?section=ext-dquotes-motivation</a><a href="#fnref38" class="footnote-back">↩</a></p></li>
<li id="fn39"><p><a href="http://eclipseclp.org/wiki/Prolog/Strings">http://eclipseclp.org/wiki/Prolog/Strings</a><a href="#fnref39" class="footnote-back">↩</a></p></li>
<li id="fn40"><p><a href="http://fsl.cs.illinois.edu/images/9/9c/PrologStandard.pdf">http://fsl.cs.illinois.edu/images/9/9c/PrologStandard.pdf</a><a href="#fnref40" class="footnote-back">↩</a></p></li>
<li id="fn41"><p><a href="https://en.wiktionary.org/wiki/prorogue">https://en.wiktionary.org/wiki/prorogue</a><a href="#fnref41" class="footnote-back">↩</a></p></li>
<li id="fn42"><p><a href="https://logtalk.org/manuals/userman/features.html">https://logtalk.org/manuals/userman/features.html</a><a href="#fnref42" class="footnote-back">↩</a></p></li>
<li id="fn43"><p><a href="http://www.swi-prolog.org/pldoc/man?section=record">http://www.swi-prolog.org/pldoc/man?section=record</a><a href="#fnref43" class="footnote-back">↩</a></p></li>
<li id="fn44"><p><a href="https://docs.racket-lang.org/reference/define-struct.html">https://docs.racket-lang.org/reference/define-struct.html</a><a href="#fnref44" class="footnote-back">↩</a></p></li>
<li id="fn45"><p><a href="https://logtalk.org/documentation.html">https://logtalk.org/documentation.html</a><a href="#fnref45" class="footnote-back">↩</a></p></li>
<li id="fn46"><p><a href="https://logtalk.org/guides.html">https://logtalk.org/guides.html</a><a href="#fnref46" class="footnote-back">↩</a></p></li>
<li id="fn47"><p><a href="https://github.com/LogtalkDotOrg/logtalk3">https://github.com/LogtalkDotOrg/logtalk3</a><a href="#fnref47" class="footnote-back">↩</a></p></li>
<li id="fn48"><p><a href="https://logtalk.org/running_developer_versions.html">https://logtalk.org/running_developer_versions.html</a><a href="#fnref48" class="footnote-back">↩</a></p></li>
<li id="fn49"><p><a href="https://en.wikipedia.org/w/index.php?title=Side_effect_(computer_science)&amp;oldid=855461052">https://en.wikipedia.org/w/index.php?title=Side_effect_(computer_science)&amp;oldid=855461052</a><a href="#fnref49" class="footnote-back">↩</a></p></li>
<li id="fn50"><p><a href="https://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect">https://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect</a><a href="#fnref50" class="footnote-back">↩</a></p></li>
<li id="fn51"><p><a href="https://en.wikipedia.org/w/index.php?title=Side_effect&amp;oldid=875244456">https://en.wikipedia.org/w/index.php?title=Side_effect&amp;oldid=875244456</a><a href="#fnref51" class="footnote-back">↩</a></p></li>
<li id="fn52"><p><a href="https://www.etymonline.com/word/error">https://www.etymonline.com/word/error</a><a href="#fnref52" class="footnote-back">↩</a></p></li>
<li id="fn53"><p><a href="http://joeduffyblog.com/2015/11/03/blogging-about-midori/">http://joeduffyblog.com/2015/11/03/blogging-about-midori/</a><a href="#fnref53" class="footnote-back">↩</a></p></li>
<li id="fn54"><p><a href="http://joeduffyblog.com/2016/02/07/the-error-model/">http://joeduffyblog.com/2016/02/07/the-error-model/</a><a href="#fnref54" class="footnote-back">↩</a></p></li>
<li id="fn55"><p><a href="https://en.wikipedia.org/wiki/Symmetric_difference">https://en.wikipedia.org/wiki/Symmetric_difference</a><a href="#fnref55" class="footnote-back">↩</a></p></li>
<li id="fn56"><p><a href="http://www.dubberly.com/articles/distinguishing-between-control-and-collaboration-and-communication-and-conversation.html">http://www.dubberly.com/articles/distinguishing-between-control-and-collaboration-and-communication-and-conversation.html</a><a href="#fnref56" class="footnote-back">↩</a></p></li>
<li id="fn57"><p><a href="http://www.swi-prolog.org/howto/http/HelloHTML.html">http://www.swi-prolog.org/howto/http/HelloHTML.html</a><a href="#fnref57" class="footnote-back">↩</a></p></li>
<li id="fn58"><p><a href="http://www.swi-prolog.org/pldoc/man?section=persistency">http://www.swi-prolog.org/pldoc/man?section=persistency</a><a href="#fnref58" class="footnote-back">↩</a></p></li>
<li id="fn59"><p><a href="https://www3.cs.stonybrook.edu/~warren/xsbbook/node11.html">https://www3.cs.stonybrook.edu/~warren/xsbbook/node11.html</a><a href="#fnref59" class="footnote-back">↩</a></p></li>
<li id="fn60"><p><a href="http://www.swi-prolog.org/pldoc/man?section=cql">http://www.swi-prolog.org/pldoc/man?section=cql</a><a href="#fnref60" class="footnote-back">↩</a></p></li>
<li id="fn61"><p><a href="https://swi-prolog.discourse.group/t/scaling-to-billions-of-facts/380/2">https://swi-prolog.discourse.group/t/scaling-to-billions-of-facts/380/2</a><a href="#fnref61" class="footnote-back">↩</a></p></li>
<li id="fn62"><p><a href="https://stackoverflow.com/questions/25641240/is-it-possible-to-partially-refresh-a-materialized-view-in-postgresql">https://stackoverflow.com/questions/25641240/is-it-possible-to-partially-refresh-a-materialized-view-in-postgresql</a><a href="#fnref62" class="footnote-back">↩</a></p></li>
<li id="fn63"><p><a href="https://news.ycombinator.com/item?id=12941910">https://news.ycombinator.com/item?id=12941910</a><a href="#fnref63" class="footnote-back">↩</a></p></li>
<li id="fn64"><p><a href="https://github.com/salva/plswipl">https://github.com/salva/plswipl</a><a href="#fnref64" class="footnote-back">↩</a></p></li>
<li id="fn65"><p><a href="http://hiro-tan.org/~ekoontz/psqlog/doc/psqlog.html">http://hiro-tan.org/~ekoontz/psqlog/doc/psqlog.html</a><a href="#fnref65" class="footnote-back">↩</a></p></li>
<li id="fn66"><p><a href="https://twiki.org/cgi-bin/view/Plugins/SwiPrologToPostgreSqlAddOn">https://twiki.org/cgi-bin/view/Plugins/SwiPrologToPostgreSqlAddOn</a><a href="#fnref66" class="footnote-back">↩</a></p></li>
<li id="fn67"><p><a href="http://xsb.sourceforge.net/manual2/manual2.pdf">http://xsb.sourceforge.net/manual2/manual2.pdf</a><a href="#fnref67" class="footnote-back">↩</a></p></li>
<li id="fn68"><p><a href="http://mrhoyestokwebsite.com/Knower/Useful%20Information/Three%20Different%20Theories%20of%20Truth.htm">http://mrhoyestokwebsite.com/Knower/Useful%20Information/Three%20Different%20Theories%20of%20Truth.htm</a><a href="#fnref68" class="footnote-back">↩</a></p></li>
<li id="fn69"><p><a href="https://en.wikipedia.org/wiki/Truth">https://en.wikipedia.org/wiki/Truth</a><a href="#fnref69" class="footnote-back">↩</a></p></li>
<li id="fn70"><p><a href="http://logic.stanford.edu/herbrand/herbrand.html">http://logic.stanford.edu/herbrand/herbrand.html</a><a href="#fnref70" class="footnote-back">↩</a></p></li>
<li id="fn71"><p><a href="https://conference.imp.fu-berlin.de/cade-25/download/2015_CADE_ruleml_genesere.pdf">https://conference.imp.fu-berlin.de/cade-25/download/2015_CADE_ruleml_genesere.pdf</a><a href="#fnref71" class="footnote-back">↩</a></p></li>
<li id="fn72"><p><a href="http://www.lix.polytechnique.fr/~dale/lolli/">http://www.lix.polytechnique.fr/~dale/lolli/</a><a href="#fnref72" class="footnote-back">↩</a></p></li>
<li id="fn73"><p><a href="https://math.stackexchange.com/questions/1761680/what-formal-systems-are-various-programming-paradigms-based-on/1761959">https://math.stackexchange.com/questions/1761680/what-formal-systems-are-various-programming-paradigms-based-on/1761959</a><a href="#fnref73" class="footnote-back">↩</a></p></li>
<li id="fn74"><p><a href="https://gym.openai.com">https://gym.openai.com</a><a href="#fnref74" class="footnote-back">↩</a></p></li>
<li id="fn75"><p><a href="http://www.pathwayslms.com/swipltuts/index.html">http://www.pathwayslms.com/swipltuts/index.html</a><a href="#fnref75" class="footnote-back">↩</a></p></li>
<li id="fn76"><p><a href="http://www.pathwayslms.com/swipltuts/student/">http://www.pathwayslms.com/swipltuts/student/</a><a href="#fnref76" class="footnote-back">↩</a></p></li>
<li id="fn77"><p><a href="https://swi-prolog.discourse.group/t/improving-contributor-guide-discoverability-was-consolidating-the-71-github-repositories-to-simplify-maintenance-and-contribution/492/16">https://swi-prolog.discourse.group/t/improving-contributor-guide-discoverability-was-consolidating-the-71-github-repositories-to-simplify-maintenance-and-contribution/492/16</a><a href="#fnref77" class="footnote-back">↩</a></p></li>
<li id="fn78"><p><a href="https://github.com/SWI-Prolog/swipl-devel/pull/459">https://github.com/SWI-Prolog/swipl-devel/pull/459</a><a href="#fnref78" class="footnote-back">↩</a></p></li>
<li id="fn79"><p><a href="https://www.discourse.org">https://www.discourse.org</a><a href="#fnref79" class="footnote-back">↩</a></p></li>
<li id="fn80"><p><a href="https://twitter.com/r_Prolog/status/1092721329596444672">https://twitter.com/r_Prolog/status/1092721329596444672</a><a href="#fnref80" class="footnote-back">↩</a></p></li>
<li id="fn81"><p><a href="https://www.reddit.com/r/prolog/comments/ancj74/using_logic_programming_to_recover_c_classes_and/">https://www.reddit.com/r/prolog/comments/ancj74/using_logic_programming_to_recover_c_classes_and/</a><a href="#fnref81" class="footnote-back">↩</a></p></li>
<li id="fn82"><p><a href="https://blog.logtalk.org/2011/03/a-more-sane-implementation-of-the-term-expansion-mechanism/">https://blog.logtalk.org/2011/03/a-more-sane-implementation-of-the-term-expansion-mechanism/</a><a href="#fnref82" class="footnote-back">↩</a></p></li>
<li id="fn83"><p><a href="https://groups.google.com/forum/#!searchin/swi-prolog/clash$20module%7Csort:date/swi-prolog/f8LpJN8MYm0/uUYfUmN5AgAJ">https://groups.google.com/forum/#!searchin/swi-prolog/clash$20module%7Csort:date/swi-prolog/f8LpJN8MYm0/uUYfUmN5AgAJ</a><a href="#fnref83" class="footnote-back">↩</a></p></li>
<li id="fn84"><p><a href="http://www.haskellforall.com/2016/12/dhall-non-turing-complete-configuration.html">http://www.haskellforall.com/2016/12/dhall-non-turing-complete-configuration.html</a><a href="#fnref84" class="footnote-back">↩</a></p></li>
<li id="fn85"><p><a href="https://stackoverflow.com/questions/6695788/programming-in-the-large-with-prolog">https://stackoverflow.com/questions/6695788/programming-in-the-large-with-prolog</a><a href="#fnref85" class="footnote-back">↩</a></p></li>
<li id="fn86"><p><a href="https://en.wikipedia.org/wiki/Adaptive_grammar">https://en.wikipedia.org/wiki/Adaptive_grammar</a><a href="#fnref86" class="footnote-back">↩</a></p></li>
<li id="fn87"><p><a href="https://news.ycombinator.com/item?id=2330830">https://news.ycombinator.com/item?id=2330830</a><a href="#fnref87" class="footnote-back">↩</a></p></li>
<li id="fn88"><p><a href="https://stackoverflow.com/questions/953185/composable-grammars">https://stackoverflow.com/questions/953185/composable-grammars</a><a href="#fnref88" class="footnote-back">↩</a></p></li>
<li id="fn89"><p><a href="https://en.wikipedia.org/wiki/Scannerless_parsing">https://en.wikipedia.org/wiki/Scannerless_parsing</a><a href="#fnref89" class="footnote-back">↩</a></p></li>
<li id="fn90"><p><a href="https://en.wikipedia.org/wiki/The_lexer_hack">https://en.wikipedia.org/wiki/The_lexer_hack</a><a href="#fnref90" class="footnote-back">↩</a></p></li>
<li id="fn91"><p><a href="https://rmod.inria.fr/archives/papers/Reng10cDynamicGrammars.pdf">https://rmod.inria.fr/archives/papers/Reng10cDynamicGrammars.pdf</a><a href="#fnref91" class="footnote-back">↩</a></p></li>
<li id="fn92"><p><a href="https://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/ISO-Hiord.html">https://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/ISO-Hiord.html</a><a href="#fnref92" class="footnote-back">↩</a></p></li>
<li id="fn93"><p><a href="https://blog.logtalk.org/2009/12/lambda-expressions-in-logtalk/">https://blog.logtalk.org/2009/12/lambda-expressions-in-logtalk/</a><a href="#fnref93" class="footnote-back">↩</a></p></li>
<li id="fn94"><p><a href="https://en.wikipedia.org/wiki/Lambda_lifting">https://en.wikipedia.org/wiki/Lambda_lifting</a><a href="#fnref94" class="footnote-back">↩</a></p></li>
<li id="fn95"><p><a href="http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/naish.html">http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/naish.html</a><a href="#fnref95" class="footnote-back">↩</a></p></li>
<li id="fn96"><p><a href="https://github.com/webyrd/miniKanren-uncourse/wiki/Other-Interesting-Logic-or-Relational-Programming-Languages">https://github.com/webyrd/miniKanren-uncourse/wiki/Other-Interesting-Logic-or-Relational-Programming-Languages</a><a href="#fnref96" class="footnote-back">↩</a></p></li>
<li id="fn97"><p><a href="https://en.wikipedia.org/wiki/Resolution_(logic)">https://en.wikipedia.org/wiki/Resolution_(logic)</a><a href="#fnref97" class="footnote-back">↩</a></p></li>
<li id="fn98"><p><a href="http://www.cs.miami.edu/home/geoff/Courses/CSC749-17F/Content/Typed1stOrder.shtml">http://www.cs.miami.edu/home/geoff/Courses/CSC749-17F/Content/Typed1stOrder.shtml</a><a href="#fnref98" class="footnote-back">↩</a></p></li>
<li id="fn99"><p><a href="https://gmplib.org/manual/Introduction-to-GMP.html">https://gmplib.org/manual/Introduction-to-GMP.html</a><a href="#fnref99" class="footnote-back">↩</a></p></li>
<li id="fn100"><p><a href="https://gcc.gnu.org/onlinedocs/cpp/Overview.html#Overview">https://gcc.gnu.org/onlinedocs/cpp/Overview.html#Overview</a><a href="#fnref100" class="footnote-back">↩</a></p></li>
<li id="fn101"><p><a href="https://swi-prolog.discourse.group/t/consolidating-the-71-github-repositories-to-simplify-maintenance-and-contribution/492/10">https://swi-prolog.discourse.group/t/consolidating-the-71-github-repositories-to-simplify-maintenance-and-contribution/492/10</a><a href="#fnref101" class="footnote-back">↩</a></p></li>
<li id="fn102"><p><a href="https://svn.apache.org/repos/asf/subversion/trunk/notes/subversion-design.html">https://svn.apache.org/repos/asf/subversion/trunk/notes/subversion-design.html</a><a href="#fnref102" class="footnote-back">↩</a></p></li>
<li id="fn103"><p><a href="https://stackoverflow.com/questions/28465362/svn-tree-conflict-when-merging-renamed-folder">https://stackoverflow.com/questions/28465362/svn-tree-conflict-when-merging-renamed-folder</a><a href="#fnref103" class="footnote-back">↩</a></p></li>
<li id="fn104"><p><a href="https://www.theregister.co.uk/2017/03/17/subversion_svn_file_renaming/">https://www.theregister.co.uk/2017/03/17/subversion_svn_file_renaming/</a><a href="#fnref104" class="footnote-back">↩</a></p></li>
<li id="fn105"><p><a href="http://www.swi-prolog.org/howto/SubmitPatch.html">http://www.swi-prolog.org/howto/SubmitPatch.html</a><a href="#fnref105" class="footnote-back">↩</a></p></li>
<li id="fn106"><p><a href="http://www.swi-prolog.org/build/unix.html">http://www.swi-prolog.org/build/unix.html</a><a href="#fnref106" class="footnote-back">↩</a></p></li>
<li id="fn107"><p><a href="https://swi-prolog.discourse.group/t/being-friendly-to-quick-contributions/493/3">https://swi-prolog.discourse.group/t/being-friendly-to-quick-contributions/493/3</a><a href="#fnref107" class="footnote-back">↩</a></p></li>
<li id="fn108"><p><a href="http://www.swi-prolog.org/pldoc/man?section=foreign">http://www.swi-prolog.org/pldoc/man?section=foreign</a><a href="#fnref108" class="footnote-back">↩</a></p></li>
<li id="fn109"><p><a href="http://www.swi-prolog.org/pack/list?p=ffi">http://www.swi-prolog.org/pack/list?p=ffi</a><a href="#fnref109" class="footnote-back">↩</a></p></li>
<li id="fn110"><p><a href="https://groups.google.com/forum/#!topic/comp.lang.prolog/-WhsxJqPRRU">https://groups.google.com/forum/#!topic/comp.lang.prolog/-WhsxJqPRRU</a><a href="#fnref110" class="footnote-back">↩</a></p></li>
<li id="fn111"><p><a href="https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/compiler2.html">https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/compiler2.html</a><a href="#fnref111" class="footnote-back">↩</a></p></li>
<li id="fn112"><p><a href="https://en.wikipedia.org/wiki/Unicode_equivalence">https://en.wikipedia.org/wiki/Unicode_equivalence</a><a href="#fnref112" class="footnote-back">↩</a></p></li>
<li id="fn113"><p><a href="https://emacsredux.com/blog/2014/06/18/quickly-find-emacs-lisp-sources/">https://emacsredux.com/blog/2014/06/18/quickly-find-emacs-lisp-sources/</a><a href="#fnref113" class="footnote-back">↩</a></p></li>
<li id="fn114"><p><a href="https://stackoverflow.com/questions/33707068/how-can-i-view-the-definition-of-a-function-in-lisp-sbcl">https://stackoverflow.com/questions/33707068/how-can-i-view-the-definition-of-a-function-in-lisp-sbcl</a><a href="#fnref114" class="footnote-back">↩</a></p></li>
<li id="fn115"><p><a href="https://web.cs.wpi.edu/~jshutt/adapt/top.html">https://web.cs.wpi.edu/~jshutt/adapt/top.html</a><a href="#fnref115" class="footnote-back">↩</a></p></li>
</ol>
</section>
                </div>
            </div>
        </main>
        <footer class="site-footer h-card">
            <data class="u-url" href="/"></data>
            <div class="wrapper">
                <p>This page was created on 2018-04-11 00:00 +0700.</p>
                <p class="rss-subscribe">The
                    <a href="/feed.xml">RSS feed</a> of this website has not been implemented.</p>
                <p>
                    I used Disqus, but I removed it because it hijacks my links and redirects them to third-party ad networks.
                    On 2019-05-27, a friend of mine reported that links on my website were broken,
                    and I caught Disqus red-handed redirecting my links to pwieu.com.
                </p>
            </div>
        </footer>
    </body>
</html>
