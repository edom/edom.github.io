<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="UTF-8"/>
        <title>Computation</title>
        <link rel="stylesheet" href="/assets/main.css"/>
        <script>
// Help the reader estimate how much time the reading is going to take.
// Show word count and reading time estimation in TOC entry.
//
// TOC = table of contents
//
// Known issue: This janks: this DOM manipulation is done after the page is rendered.
// If we don't want jank, we have to manipulate the HTML source before it reaches the browser.
// We assume that the user doesn't refresh the page while reading.
// The benefit of fixing that jank is not enough for me to justify trying to fix it.
document.addEventListener("DOMContentLoaded", function () {
    function count_word (string) {
        return string.trim().split(/\s+/).length;
    }
    function show_quantity (count, singular) {
        let plural = singular + "s"; // For this script only.
        return count + " " + ((count == 1) ? singular : plural);
    }
    function create_length_indicator (word, minute) {
        let e = document.createElement("span");
        e.className = "toc_entry__length_indicator";
        e.textContent = " (" + show_quantity(word, "word") + " ~ " + show_quantity(minute, "minute") + ")";
        return e;
    }
    // We assume that readers read this many words per minute with 100% comprehension.
    // This assumption may not hold for dense texts such as philosophy and mathematics.
    const wpm_assumption = 200;
    // We assume a certain Jekyll template.
    let page = document.querySelector("main.page-content");
    if (page === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"main.page-content\" does not match anything");
        return;
    }
    let page_title = document.querySelector("header.post-header h1.post-title");
    if (page_title === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"header.post-header h1.post-title\" does not match anything");
        return;
    }
    let page_word = count_word(page.textContent);
    let page_minute = Math.ceil(page_word / wpm_assumption);
    page_title.insertAdjacentElement("afterend", create_length_indicator(page_word, page_minute));
    // We violate the HTML specification.
    // The page may have several elements with the same ID.
    // We assume that Org HTML Export generates a DIV element with ID "table-of-contents".
    // We assume that Jekyll Markdown-to-HTML generates a UL element with ID "markdown-toc".
    // This only works for Org HTML Export's TOC.
    let toc_entries = document.querySelectorAll("#table-of-contents a, #text-table-of-contents a");
    toc_entries.forEach((toc_entry_a) => {
        let href = toc_entry_a.getAttribute("href"); // We assume that this is a string like "#org0123456".
        if (href.charAt(0) !== '#') {
            console.log("toc_generate_estimate: Impossible: " + href + " does not begin with hash sign");
            return;
        }
        // We can't just document.querySelector(href) because target_id may contain invalid ID characters such as periods.
        let target_id = href.substring(1);
        let id_escaped = target_id.replace("\"", "\\\"");
        let h_elem = document.querySelector("[id=\"" + id_escaped + "\"]"); // We assume that this is the h1/h2/h3 element referred by the TOC entry.
        if (h_elem === null) { // We assume that this is impossible.
            console.log("toc_generate_estimate: Impossible: " + href + " does not refer to anything");
            return;
        }
        let section = h_elem.parentNode;
        let section_word = count_word(section.textContent);
        let section_minute = Math.ceil(section_word / wpm_assumption);
        toc_entry_a.insertAdjacentElement("afterend", create_length_indicator(section_word, section_minute));
    });
});
        </script>

        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12628443-6"></script>
<script>
  window['ga-disable-UA-12628443-6'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-12628443-6');
</script>
        
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            jax: ["input/TeX","input/MathML","input/AsciiMath",
            "output/CommonHTML"
            ],
            extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "a11y/accessibility-menu.js"],
            TeX: {
                extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
                , equationNumbers: {
                    autoNumber: "AMS"
                }
            },
            "CommonHTML": {
                scale: 100
            },
            "fast-preview": {
                disabled: true,
            }
        });
        </script>
        <style>
            /*
            PreviewHTML produces small Times New Roman text.
            PreviewHTML scale doesn't work.
            */
            .MathJax_PHTML { font-size: 110%; }
        </style>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js" async defer></script>
    </head>
    <body>
        <header class="site-header" role="banner">
            <div class="wrapper">
                <a class="site-title" rel="author" href="/">Erik Dominikus's home page</a>
            </div>
        </header>
    <div style="display:none;">\(
    \renewcommand\emptyset{\varnothing}
    \newcommand\abs[1]{\left|#1\right|}
    \newcommand\dom{\textrm{dom}}
    \newcommand\cod{\textrm{cod}}
    \newcommand\Bernoulli{\textrm{Bernoulli}}
    \newcommand\Binomial{\textrm{Binomial}}
    \newcommand\Expect[1]{\mathbb{E}[#1]}
    \newcommand\Nat{\mathbb{N}}
    \newcommand\Integers{\mathbb{Z}}
    \newcommand\Real{\mathbb{R}}
    \newcommand\Rational{\mathbb{Q}}
    \newcommand\Complex{\mathbb{C}}
    \newcommand\Pr{\mathrm{P}}
    \newcommand\Time{\text{Time}}
    \newcommand\DTime{\text{DTime}}
    \newcommand\NTime{\text{NTime}}
    \newcommand\TimeP{\text{P}}
    \newcommand\TimeNP{\text{NP}}
    \newcommand\TimeExp{\text{ExpTime}}
    \newcommand\norm[1]{\left\lVert#1\right\rVert}
    \newcommand\bbA{\mathbb{A}}
    \newcommand\bbC{\mathbb{C}}
    \newcommand\bbD{\mathbb{D}}
    \newcommand\bbE{\mathbb{E}}
    \newcommand\bbN{\mathbb{N}}
    \newcommand\frakI{\mathfrak{I}}
    % deprecated; use TimeExp
    \newcommand\ExpTime{\text{ExpTime}}
    \newcommand\Compute{\text{Compute}}
    \newcommand\Search{\text{Search}}
    % model theory structure
    \newcommand\struc[1]{\mathcal{#1}}
    \)</div>
        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
                    <header class="post-header">
                        <h1 class="post-title">Computation</h1>
                    </header>
                </article>
                <div class="post-content">
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1</span><span class="section_title"><a href="#what-is-computation">What is computation?</a></span><span class="word_count">(1013w~6m)</span></li>
<li><span class="section_number">2</span><span class="section_title"><a href="#what-is-computation-theory">What is computation theory?</a></span><span class="word_count">(151w~1m)</span></li>
<li><span class="section_number">3</span><span class="section_title"><a href="#the-mathematics-part">The mathematics part</a></span><span class="word_count">(1369w~7m)</span></li>
</ul>
</div>
<h2 id="what-is-computation"><span class="section_number">1</span><span class="section_title">What is computation?</span></h2>
<p>Here we analyze the meaning of computation in everyday usage. Then we formalize a computation model as a logical structure. Then we define what it means to compute a function with respect to that model.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.1</span><span class="section_title"><a href="#what-are-computers-machines-automatons-robots">What are computers, machines, automatons, robots?</a></span><span class="word_count">(321w~2m)</span></li>
<li><span class="section_number">1.2</span><span class="section_title"><a href="#what-is-an-algorithm">What is an algorithm?</a></span><span class="word_count">(136w~1m)</span></li>
<li><span class="section_number">1.3</span><span class="section_title"><a href="#what-is-to-compute-something">What is to compute something?</a></span><span class="word_count">(108w~1m)</span></li>
<li><span class="section_number">1.4</span><span class="section_title"><a href="#undoing-chronic-ontological-sloppiness">Undoing chronic ontological sloppiness</a></span><span class="word_count">(262w~2m)</span></li>
<li><span class="section_number">1.5</span><span class="section_title"><a href="#digressions">Digressions</a></span><span class="word_count">(154w~1m)</span></li>
</ul>
</div>
<h3 id="what-are-computers-machines-automatons-robots"><span class="section_number">1.1</span><span class="section_title">What are computers, machines, automatons, robots?</span></h3>
<p>In 1640, a <em>computer</em> is a human calculator.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> In 1897, a computer is a mechanical calculator.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> In 1945, a computer is an electronic calculator.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> All those computers ran approximation algorithms to generate look-up tables of values of transcendental functions. There are also <em>analog computers</em> made with operational amplifiers<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>, as opposed to <em>digital computers</em> made with logic gates<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>. Both analog and digital computers are made with transistors, but analog computers operate the transistors outside the saturated region, whereas digital computers operate the transistors in the saturated region. Analog to digital is knob to switch, that is, continuous to discrete. Analog computers use transistors as amplifiers. Digital computers use transistors as switches. However, as we build stronger computers, we begin trying to simulate reality, and we wonder whether the Universe is just an extremely powerful computer. Some time in the 1970s, a computer is a desktop computer, calculation gained a numerical connotation, and a calculator is a computer specialized for numerical problems, and thus calculation is numerical computation, and a human calculator is a human who can mentally manipulate digits quickly and correctly. The world progressed explosively, despite being built on increasingly complex computer systems with ever-more undefined behaviors, occasionally killing people. However, modernization does not change the nature of computation: finite, discrete, sequential, precise, algorithmic.</p>
<p>In 1540, a <em>machine</em> is any structure or device.<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> The word &quot;machine&quot; may have come from a Proto-Indo-European word that means &quot;that which enables&quot;.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> Some machines are <em>programmable</em>. Such machine implements several functions that can be chosen by a <em>program</em> which is a part of the machine's input. The program chooses which function the machine shall compute.</p>
<p>In 1610, an <em>automaton</em> is a self-acting machine.<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> Thus an automaton has an energy source or is connected to an energy source that enables the automaton to run with minimal human intervention.</p>
<p>In 1923, the English word &quot;robot&quot; came from the Czech word &quot;robotnik&quot; that means &quot;forced worker&quot;.<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a></p>
<h3 id="what-is-an-algorithm"><span class="section_number">1.2</span><span class="section_title">What is an algorithm?</span></h3>
<p>In 1690, an <em>algorithm</em> is an Arabic system of computation.<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a> It is the historically-and-interculturally mangled name of Muhammad ibn Musa al-Khwarizmi<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a> who lived in the 8th century. An <em>algorithm</em> is a finite description of how a computer computes something. In the medievals, an algorithm is a numerical approximation scheme to be run by humans. Anyone who knows basic arithmetics can mindlessly carry out an algorithm and produce a correct answer without any understanding of why or how the algorithm works.</p>
<p>An algorithm restates a function as a composition of <em>primitives</em>.</p>
<p>Some note about ontology: The long addition algorithm does not describe how to add two numbers <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. It describes how to manipulate two <em>representations</em> <span class="math inline">\(e(x)\)</span> and <span class="math inline">\(e(y)\)</span> in order to produce a third representation <span class="math inline">\(e(x+y)\)</span> that represents the sum of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</p>
<h3 id="what-is-to-compute-something"><span class="section_number">1.3</span><span class="section_title">What is to compute something?</span></h3>
<p>What do we mean when we say &quot;This machine computes <span class="math inline">\(f(x)\)</span> given <span class="math inline">\(x\)</span>&quot;? What do we mean by &quot;This calculator can compute square roots&quot;?</p>
<p>We can analyze the transitive verb &quot;to compute&quot; with these two questions: What computes? What is computed?</p>
<p>An example usage is &quot;this machine computes the sum of two numbers&quot;.</p>
<p>A machine <em>computes</em> the expression <span class="math inline">\(f(x)\)</span> from the value <span class="math inline">\(x\)</span> iff the machine starts with a representation of <span class="math inline">\(x\)</span> and ends with a representation of the result of evaluating <span class="math inline">\(f(x)\)</span>.</p>
<p>A machine computes the function <span class="math inline">\(f:D\to C\)</span> iff the machine computes <span class="math inline">\(f(x)\)</span> from <span class="math inline">\(x\)</span> for each <span class="math inline">\(x\in D\)</span>.</p>
<p>Piccinini distinguishes abstract computation and concrete computation <span class="citation" data-cites="sep-computation-physicalsystems">[<a href="#ref-sep-computation-physicalsystems">7</a>]</span>.</p>
<h3 id="undoing-chronic-ontological-sloppiness"><span class="section_number">1.4</span><span class="section_title">Undoing chronic ontological sloppiness</span></h3>
<p>First, we undo the chronic ontologically-sloppy habit of conflating a thing and a representation of the thing. &quot;123&quot; is not a number, but a <em>representation</em> of a number. We cannot manipulate numbers physically because they do not have material existence. We can only manipulate the physical representations of those numbers. When we &quot;add two numbers&quot;, we are actually manipulating the representations of those numbers in a way that corresponds to adding those numbers. Formally, if <span class="math inline">\(e : \Nat \to \{0,1\}^*\)</span> is an encoding scheme, then <span class="math inline">\( e(x+y) = e(x) +_e e(y) \)</span>, where <span class="math inline">\(+\)</span> is the operation that we think we do, and <span class="math inline">\(+_e\)</span> is the operation that we actually do. We think we are adding numbers, but we are actually writing symbols on paper or juggling symbols in our mind.</p>
<p>Then, we un-conflate a program and a machine running the program. A program does not <em>compute</em>; it is the machine that computes. A program cannot do anything on its own; a machine has to run it. When we say &quot;a program computes a function&quot;, we actually mean that running the program on the machine causes the machine to compute that function.</p>
<p>Unfortunately, the ontologically correct thing is very wordy, so I write in conflated manner. For example, when I write &quot;this program adds two numbers&quot;, what I really mean is &quot;running the program causes the machine to manipulate two representations in a way that corresponds to adding two numbers&quot;. Fortunately, the only time we have to care about this ontological issue is when we are talking about the foundations of computation.</p>
<h3 id="digressions"><span class="section_number">1.5</span><span class="section_title">Digressions</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.5.1</span><span class="section_title"><a href="#genus-differentia-definition-of-computation">Genus-differentia definition of computation?</a></span><span class="word_count">(30w~1m)</span></li>
<li><span class="section_number">1.5.2</span><span class="section_title"><a href="#computation-as-information-transformation">Computation as information transformation</a></span><span class="word_count">(25w~1m)</span></li>
<li><span class="section_number">1.5.3</span><span class="section_title"><a href="#computation-as-modelconcretion">Computation as model/concretion?</a></span><span class="word_count">(24w~1m)</span></li>
<li><span class="section_number">1.5.4</span><span class="section_title"><a href="#diving-into-philosophy-of-computation">Diving into philosophy of computation</a></span><span class="word_count">(13w~1m)</span></li>
<li><span class="section_number">1.5.5</span><span class="section_title"><a href="#machine">Machine</a></span><span class="word_count">(46w~1m)</span></li>
<li><span class="section_number">1.5.6</span><span class="section_title"><a href="#even-more-historical">Even more historical?</a></span><span class="word_count">(21w~1m)</span></li>
</ul>
</div>
<h4 id="genus-differentia-definition-of-computation"><span class="section_number">1.5.1</span><span class="section_title">Genus-differentia definition of computation?</span></h4>
<p>A computation is (what) that (what)?</p>
<p>Process? Activity? Mechanism?</p>
<p>A program describes the computation performed by a machine. A program modulates the machine. Manipulates computational resources to compute something.</p>
<h4 id="computation-as-information-transformation"><span class="section_number">1.5.2</span><span class="section_title">Computation as information transformation</span></h4>
<p>Computation is answering a question.</p>
<p>What is the relationship between computation and answering questions?</p>
<p>A computer reduces information? Transforms information?</p>
<p>Computation is transformation of information?</p>
<h4 id="computation-as-modelconcretion"><span class="section_number">1.5.3</span><span class="section_title">Computation as model/concretion?</span></h4>
<p>Computation is running a program on a machine.</p>
<p>It seems that the defining feature of computation is conditional and repetition.</p>
<p>Program is a model.</p>
<h4 id="diving-into-philosophy-of-computation"><span class="section_number">1.5.4</span><span class="section_title">Diving into philosophy of computation</span></h4>
<p>Ian Horswill wrote an introductory article &quot;What is computation?&quot;<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>.</p>
<h4 id="machine"><span class="section_number">1.5.5</span><span class="section_title">Machine</span></h4>
<p>A <em>machine</em> is a tool that <em>computes</em> what the machine is designed for. A machine has material existence. It is a physical implement.</p>
<p>Digression: In <a href="philo.html">file:philo.html</a>, I write that a machine is a tool, that is something that we use to extend our self (what we control).</p>
<h4 id="even-more-historical"><span class="section_number">1.5.6</span><span class="section_title">Even more historical?</span></h4>
<p>Leibniz used the term &quot;calculation&quot;? Turing used &quot;effective calculability&quot; to mean &quot;algorithmic&quot;? Computation is calculation? It's just following rules?</p>
<h2 id="what-is-computation-theory"><span class="section_number">2</span><span class="section_title">What is computation theory?</span></h2>
<p>Computation theory spans philosophy, physics, and mathematics. The mathematics part<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a> studies logical models of computation, not computation itself. Which part of computation theory are we interested in? This document is mostly the mathematics part, because there is a one-million-dollar prize for solving the P vs NP problem. See Piccinini 2017 <span class="citation" data-cites="sep-computation-physicalsystems">[<a href="#ref-sep-computation-physicalsystems">7</a>]</span> if you are interested in the philosophy and physics parts.</p>
<p>1999 Immerman <span class="citation" data-cites="Immerman99descriptivecomplexity">[<a href="#ref-Immerman99descriptivecomplexity">4</a>]</span>, 2009 Arora &amp; Barak <span class="citation" data-cites="Arora2009">[<a href="#ref-Arora2009">1</a>]</span>, 2009 Marek &amp; Remmel <span class="citation" data-cites="Marek2009">[<a href="#ref-Marek2009">6</a>]</span>, 2002 Boolos, Burgess, &amp; Jeffrey <span class="citation" data-cites="Boolos2002">[<a href="#ref-Boolos2002">2</a>]</span>, 1987 Rogers <span class="citation" data-cites="Rogers1987">[<a href="#ref-Rogers1987">5</a>]</span>.</p>
<p>Where are the researchers? There is ACM Special Interest Group on Logic and Computation (SIGLOG)<a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a>. There is also Computational Complexity Conference<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a>.</p>
<p>We can think of computation theory as refining these hierarchies: automaton power hierarchy<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>, problem complexity hierarchy, logic strength hierarchy, Chomsky language hierarchy<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a>, arithmetical hierarchy<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a>, formal system power hierarchy<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a>, and so on. They are related to each other. We want to find out which feature gives which power.</p>
<h2 id="the-mathematics-part"><span class="section_number">3</span><span class="section_title">The mathematics part</span></h2>
<p>There are many computation models<a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a>. All of them imply some <em>operating conditions</em>: there are no electrical disruptions, fires, cosmic rays, and so on. All of them also imply a sequence of operations.</p>
<p>We often assume that the computation model is a Turing machine. But, ontologically, a Turing machine is a computation model, not a machine, and thus should be called a Turing model.</p>
<p>A <em>computation model</em> is a formal system that represents the relevant aspects of the internal states of a computing machine.</p>
<p>Now we define &quot;to compute the function <span class="math inline">\(f : D \to C\)</span>&quot; with respect to the computation model <span class="math inline">\((D,C,S,d,c,t)\)</span> where <span class="math inline">\(d : D \to S\)</span>, and <span class="math inline">\(c : C \to S\)</span>, and <span class="math inline">\(t\)</span> has arity <span class="math inline">\((S,S)\)</span>. The computation model is a three-sorted structure. The functions <span class="math inline">\(d\)</span> and <span class="math inline">\(c\)</span> together bridge two things: (1) our high-level thought of the machine computes, and (2) the logical system that abstracts the machine's internal state and computation. Let <span class="math inline">\(S\)</span> be the computation model's domain of discourse, that is, the set of each mathematical object that is a simplified representation of a machine internal state. Let <span class="math inline">\(t\)</span> be a relation symbol of arity 2. The relation <span class="math inline">\(t\)</span> represents the state transition relation. Define the transitive closure of <span class="math inline">\(t\)</span> as <span class="math inline">\(T(x,y) = (TC(t))(x,y) = t(x,y) \vee \exists z (t(x,z) \wedge T(z,y))\)</span> where <span class="math inline">\(TC\)</span> is the transitive-closure operator.</p>
<p>Machine <span class="math inline">\(M\)</span> computes function <span class="math inline">\(f : D \to C\)</span> according to computation model <span class="math inline">\((D,C,S,d,c,t)\)</span> iff <span class="math display">\[
compute(M,f) = \forall x : T(d(x), c(f(x)))
\]</span></p>
<p>We can focus on the computation model, and focus on the substructure <span class="math inline">\((S,t)\)</span> instead.</p>
<p>A machine <em>computes</em> the function <span class="math inline">\(f : D \to C\)</span> according to the computation model <span class="math inline">\((S,c,d,t)\)</span>, iff, for all <span class="math inline">\(x \in D\)</span>, it is true that <span class="math inline">\(T(d(x),c(f(x)))\)</span>, that is, the machine starts at state <span class="math inline">\(d(x)\)</span> and finishes at state <span class="math inline">\(c(f(x))\)</span>.</p>
<p>A <em>computation model</em> is a logical system that has a domain of discourse representing machine internal state, and has an arity-2 relation symbol <span class="math inline">\(t\)</span> representing the state transition relation.</p>
<p>TODO <span class="citation" data-cites="vardi1998computational">[<a href="#ref-vardi1998computational">8</a>]</span></p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.1</span><span class="section_title"><a href="#encoding-scheme">Encoding scheme</a></span><span class="word_count">(80w~1m)</span></li>
<li><span class="section_number">3.2</span><span class="section_title"><a href="#computable-algorithm-finite-description">Computable, algorithm, finite description</a></span><span class="word_count">(49w~1m)</span></li>
<li><span class="section_number">3.3</span><span class="section_title"><a href="#is-computation-inherently-sequential-computation-as-sequence-of-steps">Is computation inherently sequential? Computation as sequence of steps</a></span><span class="word_count">(75w~1m)</span></li>
<li><span class="section_number">3.4</span><span class="section_title"><a href="#logic-model">Logic, model</a></span><span class="word_count">(3w~1m)</span></li>
<li><span class="section_number">3.5</span><span class="section_title"><a href="#problem-formula-input-output-model-relation">Problem, formula, input, output, model, relation</a></span><span class="word_count">(247w~2m)</span></li>
<li><span class="section_number">3.6</span><span class="section_title"><a href="#complexity">Complexity</a></span><span class="word_count">(213w~2m)</span></li>
<li><span class="section_number">3.7</span><span class="section_title"><a href="#problem-reduction">Problem, reduction</a></span><span class="word_count">(10w~1m)</span></li>
<li><span class="section_number">3.8</span><span class="section_title"><a href="#digressions-1">Digressions</a></span><span class="word_count">(59w~1m)</span></li>
<li><span class="section_number">3.9</span><span class="section_title"><a href="#encoding-affects-complexity">Encoding affects complexity</a></span><span class="word_count">(114w~1m)</span></li>
<li><span class="section_number">3.10</span><span class="section_title"><a href="#what-makes-an-encoding-reasonable">What makes an encoding reasonable?</a></span><span class="word_count">(26w~1m)</span></li>
<li><span class="section_number">3.11</span><span class="section_title"><a href="#rant-the-sad-state-of-computational-complexity-texts">Rant: The sad state of computational complexity texts?</a></span><span class="word_count">(178w~1m)</span></li>
</ul>
</div>
<h3 id="encoding-scheme"><span class="section_number">3.1</span><span class="section_title">Encoding scheme</span></h3>
<p>Now we define encoding.</p>
<p>An encoding is a representation of something. A representation is not the represented, but a representation behaves in the way the represented does. Formally, an <em>encoding scheme</em> is a computable bijective function <span class="math inline">\(e : D \to A^*\)</span> where <span class="math inline">\(A\)</span> is an alphabet. Thus, an encoding scheme is an <em>algorithm</em> that describes a bijective function.</p>
<p>If &quot;algorithm&quot; and &quot;encoding scheme&quot; depend on each other, then there is only one logical conclusion: <em>Algorithm and encoding-scheme are the same thing.</em></p>
<h3 id="computable-algorithm-finite-description"><span class="section_number">3.2</span><span class="section_title">Computable, algorithm, finite description</span></h3>
<p>Function <span class="math inline">\(f\)</span> is <em>computable</em> by formal system <span class="math inline">\(S\)</span> iff <span class="math inline">\(S\)</span> has a <em>finite description</em> of <span class="math inline">\(f\)</span>.</p>
<p>An <em>algorithm</em> solves a <em>problem</em>. A problem can be solved by many algorithms with different resource usage characteristics.</p>
<p>An algorithm is a finite description of what a machine is supposed to do.</p>
<h3 id="is-computation-inherently-sequential-computation-as-sequence-of-steps"><span class="section_number">3.3</span><span class="section_title">Is computation inherently sequential? Computation as sequence of steps</span></h3>
<p>In a Turing machine, a step is a state transition that consists of reading the tape cell, writing the tape cell, moving the tape head, and changing the internal state. In <span class="math inline">\(\lambda\)</span>-calculus, a step is a <span class="math inline">\(\beta\)</span>-reduction of an expression composed from more primitive subexpressions. These examples suggest that we can define computation as a <em>sequence</em> of steps.</p>
<p>Each of those models is a special case of deciders.</p>
<h3 id="logic-model"><span class="section_number">3.4</span><span class="section_title">Logic, model</span></h3>
<p>See <a href="logic.html">file:logic.html</a>.</p>
<h3 id="problem-formula-input-output-model-relation"><span class="section_number">3.5</span><span class="section_title">Problem, formula, input, output, model, relation</span></h3>
<p>&quot;Problem&quot; comes from Greek &quot;problema&quot; which means &quot;a task, that which is proposed, a question&quot;.<a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a> Therefore, a problem <em>is</em> a question, or, formally, a <em>logical formula</em>.</p>
<p><em>A problem is a formula.</em> For example, the problem &quot;Given an <span class="math inline">\(x\)</span>, what is <span class="math inline">\(x+x\)</span>?&quot; is the formula <span class="math inline">\( x+x = y \)</span> in first-order logic with equality and some arithmetics. Note that some logic is embedded in English.<a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a>.</p>
<table>
<caption>Some common problem shapes</caption>
<thead>
<tr class="header">
<th>name</th>
<th>shape</th>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>decision problem</td>
<td><span class="math inline">\( p(x) \)</span></td>
<td><span class="math inline">\(x\)</span></td>
<td></td>
</tr>
<tr class="even">
<td>search problem</td>
<td><span class="math inline">\( p(x) \)</span></td>
<td></td>
<td><span class="math inline">\(x\)</span></td>
</tr>
<tr class="odd">
<td>function problem</td>
<td><span class="math inline">\( f(x) = y \)</span></td>
<td><span class="math inline">\(x\)</span></td>
<td><span class="math inline">\(y\)</span></td>
</tr>
</tbody>
</table>
<p>A problem may have <em>inputs</em> and <em>outputs</em>. An <em>input</em> of a problem is a free variable in the formula. An <em>output</em> of a problem is a free variable in the formula.</p>
<p>Another example: the problem &quot;Is the sum of two even numbers even?&quot; is the formula <span class="math inline">\( E(x) \wedge E(y) \to E(x+y) \)</span>.</p>
<p>What does it mean to solve a problem (answer a question)? Solving a problem is answering a question. Answering a question corresponds to <em>proving a formula</em>. Answering a question corresponds to <em>finding a model</em> of a formula?</p>
<p>A <em>problem</em> may be <em>modeled</em> by a <em>relation</em> between questions and answers. For example, the problem <span class="math inline">\( \forall x \exists y : x+x = y \)</span> is modeled by the relation <span class="math inline">\( \{ (0,0), (1,2), (2,4), \ldots \} \)</span> and is also modeled by the relation <span class="math inline">\( \{ (\epsilon,\epsilon), (1,11), (11,1111), \ldots \} \)</span>.</p>
<p>Do not conflate a problem and a model of it. A problem is a formula, <em>not</em> a relation.</p>
<p>Compare various definitions of &quot;problem&quot;<a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a><a href="#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a>.</p>
<p>A problem is <span class="citation" data-cites="sep-computational-complexity">[<a href="#ref-sep-computational-complexity">3</a>]</span></p>
<p>Problem can be <em>composed</em> as formulas can be composed.</p>
<h3 id="complexity"><span class="section_number">3.6</span><span class="section_title">Complexity</span></h3>
<p>The worst-case time complexity<a href="#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a> of machine <span class="math inline">\(m\)</span> for input <span class="math inline">\(x\)</span> is <span class="math inline">\(t(m,x)\)</span>, the number of steps <span class="math inline">\(m\)</span> makes between the beginning and the halting. The <em>worst-case time complexity</em> of <span class="math inline">\(m\)</span> for input <em>size</em> <span class="math inline">\(n\)</span> is <span class="math inline">\(T(m,n) = \left\vert \max_{|x| = n} t(m,x) \right\vert\)</span>. We can also write asymptotic statements such as <span class="math inline">\(T(m,n) \in O(f(n))\)</span>.</p>
<p>An algorithm implies a machine.</p>
<p>The complexity class of a problem is the worst-case time complexity of the most efficient algorithm solving that problem.</p>
<p>A <em>machine</em> <span class="math inline">\(M\)</span> is a <em>transition relation</em> <span class="math inline">\(T\)</span> (an <em>acyclic</em> binary relation). <span class="math display">\[
T(x,y) = \text{\(M\) can state-transition from \(x\) to \(y\).}
\]</span></p>
<p><span class="math inline">\(M\)</span> <em>computes</em> <span class="math inline">\(P\)</span> iff a subgraph of the shortcut of <span class="math inline">\(T\)</span> is isomorphic to <span class="math inline">\(P\)</span>. (If <span class="math inline">\(T\)</span> were cyclic, this definition would fail.)</p>
<p>Related: <a href="https://en.wikipedia.org/wiki/Graph_isomorphism">graph isomorphism</a>, <a href="https://en.wikipedia.org/wiki/Subgraph_isomorphism_problem">subgraph isomorphism problem</a>.</p>
<p><em>Deterministic</em> machine equals <em>functional</em> relation.</p>
<p><span class="math inline">\(G\)</span> <em>accepts</em> <span class="math inline">\(v\)</span> iff <span class="math inline">\(F^\infty(\{v\}) = \emptyset\)</span> where <span class="math inline">\(F\)</span> is the graph's fringe function. The <em>language</em> recognized by <span class="math inline">\(G\)</span> is the largest <span class="math inline">\(L \subseteq V\)</span> such that <span class="math inline">\(F^\infty(L) = \emptyset\)</span>.</p>
<p>A Turing machine is <span class="math inline">\((C,I,f)\)</span> where <span class="math inline">\(C\)</span> is countable and <span class="math inline">\(f\)</span> is recursive.</p>
<p><a href="https://en.wikipedia.org/wiki/Register_machine">https://en.wikipedia.org/wiki/Register_machine</a></p>
<p>Example: a state of a Turing machine is <span class="math inline">\((c,l,h,r)\)</span> where <span class="math inline">\(c\)</span> is a configuration, <span class="math inline">\(l\)</span> is the tape content to the left of the head, <span class="math inline">\(h\)</span> is the tape content at the head, and <span class="math inline">\(r\)</span> is the tape content to the right of the head.</p>
<h3 id="problem-reduction"><span class="section_number">3.7</span><span class="section_title">Problem, reduction</span></h3>
<p>Sometimes we can <em>reduce</em> a problem into another problem?</p>
<h3 id="digressions-1"><span class="section_number">3.8</span><span class="section_title">Digressions</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.8.1</span><span class="section_title"><a href="#pullback">Pullback</a></span><span class="word_count">(46w~1m)</span></li>
<li><span class="section_number">3.8.2</span><span class="section_title"><a href="#cheating">Cheating</a></span><span class="word_count">(14w~1m)</span></li>
</ul>
</div>
<h4 id="pullback"><span class="section_number">3.8.1</span><span class="section_title">Pullback</span></h4>
<p>We can model the apparent function computed by the machine as <span class="math inline">\(g : A^* \to A^*\)</span> where <span class="math inline">\(g(e(x)) = e(f(x))\)</span>. We then do some algebraic manipulation:</p>
<span class="math display">\[\begin{align*}
\\ g(e(x)) &amp;= e(f(x))
\\ (g \circ e)(x) &amp;= (e \circ f)(x)
\\ g \circ e &amp;\equiv e \circ f
\end{align*}
\]</span>
<p>An equation of the shape <span class="math inline">\(g \circ e \equiv e \circ f\)</span> is a special case of pullbacks<a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a> in category theory.</p>
<h4 id="cheating"><span class="section_number">3.8.2</span><span class="section_title">Cheating</span></h4>
<p>&quot;Cheating&quot; with an unreasonable encoding is a common error in P vs NP &quot;proofs&quot;.</p>
<h3 id="encoding-affects-complexity"><span class="section_number">3.9</span><span class="section_title">Encoding affects complexity</span></h3>
<p>Encoding a natural number <span class="math inline">\(n\)</span> in unary notation takes <span class="math inline">\(n\)</span> symbols. Encoding the same number in binary notation takes approximately <span class="math inline">\(\log_2(n)\)</span> symbols.</p>
<p>Adding two natural numbers <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> takes <span class="math inline">\(m+n\)</span> steps in unary notation, but only approximately <span class="math inline">\(\log(\max(m,n))\)</span> steps in positional notation.</p>
<p>Why don't encode a number as its prime factorization, to simplify multiplication while complicating addition?</p>
<p>What do we formally mean by &quot;reasonable encoding&quot;?</p>
<p>Why do we assume that numbers are encoded in positional notation<a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a>, not unary notation<a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a>?</p>
<p>My guess: What we mean by reasonable encoding is an <em>order-preserving homomorphism</em>:</p>
<span class="math display">\[\begin{align*}
a &lt; b &amp;\iff e(a) &lt;_e e(b)
\\
a = b &amp;\iff e(a) = e(b)
\end{align*}
\]</span>
<p>A homomorphism preserves structure. But which structure?</p>
<p>We may encode the natural numbers as the bitwise-negation of the base-2 representation: 1, 0, 11, 10, 01, 00, etc.</p>
<h3 id="what-makes-an-encoding-reasonable"><span class="section_number">3.10</span><span class="section_title">What makes an encoding reasonable?</span></h3>
<p>A <em>reasonable encoding</em> is an encoding that is easy to compute and is easy to invert.</p>
<p>A reasonable encoding has a finite description.</p>
<h3 id="rant-the-sad-state-of-computational-complexity-texts"><span class="section_number">3.11</span><span class="section_title">Rant: The sad state of computational complexity texts?</span></h3>
<p>It is philosophically appaling that most computational complexity texts readily show what a problem is <em>represented</em> as, but never clearly and <em>formally define</em> what a problem <em>is</em>. It is appaling that they spend hundreds of pages discussing something undefined.</p>
<div id="refs" class="references">
<div id="ref-Arora2009">
<p>[1] Arora, S. and Barak, B. 2009. <em>Computational complexity: A modern approach</em>. Cambridge University Press.</p>
</div>
<div id="ref-Boolos2002">
<p>[2] Boolos, G.S. et al. 2002. <em>Computability and logic</em>. Cambridge University Press.</p>
</div>
<div id="ref-sep-computational-complexity">
<p>[3] Dean, W. 2016. Computational complexity theory. <em>The stanford encyclopedia of philosophy</em>. E.N. Zalta, ed. <a href="https://plato.stanford.edu/archives/win2016/entries/computational-complexity/">https://plato.stanford.edu/archives/win2016/entries/computational-complexity/</a>; Metaphysics Research Lab, Stanford University. url: &lt;<a href="https://plato.stanford.edu/archives/win2016/entries/computational-complexity/">https://plato.stanford.edu/archives/win2016/entries/computational-complexity/</a>&gt;.</p>
</div>
<div id="ref-Immerman99descriptivecomplexity">
<p>[4] Immerman, N. 1999. Descriptive complexity.</p>
</div>
<div id="ref-Rogers1987">
<p>[5] Jr., H.R. 1987. <em>Theory of recursive functions and effective computability</em>. MIT Press.</p>
</div>
<div id="ref-Marek2009">
<p>[6] Marek, V.W. and Remmel, J.B. 2009. The complexity of recursive constraint satisfaction problems. <em>Annals of Pure and Applied Logic</em>. 161, 3 (2009), 447–457. DOI:<a href="https://doi.org/http://dx.doi.org/10.1016/j.apal.2009.07.005">https://doi.org/http://dx.doi.org/10.1016/j.apal.2009.07.005</a>. url: &lt;<a href="http://www.sciencedirect.com/science/article/pii/S0168007209001523">http://www.sciencedirect.com/science/article/pii/S0168007209001523</a>&gt;.</p>
</div>
<div id="ref-sep-computation-physicalsystems">
<p>[7] Piccinini, G. 2017. Computation in physical systems. <em>The stanford encyclopedia of philosophy</em>. E.N. Zalta, ed. <a href="https://plato.stanford.edu/archives/sum2017/entries/computation-physicalsystems/">https://plato.stanford.edu/archives/sum2017/entries/computation-physicalsystems/</a>; Metaphysics Research Lab, Stanford University. url: &lt;<a href="https://plato.stanford.edu/archives/sum2017/entries/computation-physicalsystems/">https://plato.stanford.edu/archives/sum2017/entries/computation-physicalsystems/</a>&gt;.</p>
</div>
<div id="ref-vardi1998computational">
<p>[8] Vardi, M.Y. 1998. Computational model theory: An overview. <em>Logic Journal of the IGPL</em>. 6, 4 (1998), 601–624. url: &lt;<a href="https://www.cs.rice.edu/~vardi/papers/wollic97-igpl.pdf">https://www.cs.rice.edu/~vardi/papers/wollic97-igpl.pdf</a>&gt;.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://www.etymonline.com/word/computer">https://www.etymonline.com/word/computer</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><a href="https://www.etymonline.com/word/computer">https://www.etymonline.com/word/computer</a><a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><a href="https://www.etymonline.com/word/computer">https://www.etymonline.com/word/computer</a><a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><a href="https://en.wikipedia.org/wiki/Operational_amplifier">https://en.wikipedia.org/wiki/Operational_amplifier</a><a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><a href="https://en.wikipedia.org/wiki/Logic_gate">https://en.wikipedia.org/wiki/Logic_gate</a><a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><a href="https://www.etymonline.com/word/machine">https://www.etymonline.com/word/machine</a><a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p><a href="https://www.etymonline.com/word/machine">https://www.etymonline.com/word/machine</a><a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p><a href="https://www.etymonline.com/word/automaton">https://www.etymonline.com/word/automaton</a><a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p><a href="https://www.etymonline.com/word/robot">https://www.etymonline.com/word/robot</a><a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p><a href="https://www.etymonline.com/word/algorithm">https://www.etymonline.com/word/algorithm</a><a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p><a href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi</a><a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p><a href="http://www.cs.northwestern.edu/~ian/What%20is%20computation.pdf">http://www.cs.northwestern.edu/~ian/What%20is%20computation.pdf</a><a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p><a href="https://en.wikipedia.org/wiki/Theory_of_computation">https://en.wikipedia.org/wiki/Theory_of_computation</a><a href="#fnref13" class="footnote-back">↩</a></p></li>
<li id="fn14"><p><a href="https://siglog.acm.org/about/">https://siglog.acm.org/about/</a><a href="#fnref14" class="footnote-back">↩</a></p></li>
<li id="fn15"><p><a href="http://www.computationalcomplexity.org/">http://www.computationalcomplexity.org/</a><a href="#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p><a href="https://en.wikipedia.org/wiki/Automata_theory">https://en.wikipedia.org/wiki/Automata_theory</a><a href="#fnref16" class="footnote-back">↩</a></p></li>
<li id="fn17"><p><a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">https://en.wikipedia.org/wiki/Chomsky_hierarchy</a><a href="#fnref17" class="footnote-back">↩</a></p></li>
<li id="fn18"><p><a href="https://en.wikipedia.org/wiki/Arithmetical_hierarchy">https://en.wikipedia.org/wiki/Arithmetical_hierarchy</a><a href="#fnref18" class="footnote-back">↩</a></p></li>
<li id="fn19"><p><a href="https://en.wikipedia.org/wiki/Reverse_mathematics#The_big_five_subsystems_of_second-order_arithmetic">https://en.wikipedia.org/wiki/Reverse_mathematics#The_big_five_subsystems_of_second-order_arithmetic</a><a href="#fnref19" class="footnote-back">↩</a></p></li>
<li id="fn20"><p><a href="https://en.wikipedia.org/wiki/Model_of_computation">https://en.wikipedia.org/wiki/Model_of_computation</a><a href="#fnref20" class="footnote-back">↩</a></p></li>
<li id="fn21"><p><a href="https://www.etymonline.com/word/problem">https://www.etymonline.com/word/problem</a><a href="#fnref21" class="footnote-back">↩</a></p></li>
<li id="fn22"><p>English is at least second-order, as demonstrated by the Geach–Kaplan sentence &quot;Some critics admire only one another&quot; <a href="https://en.wikipedia.org/wiki/Nonfirstorderizability">https://en.wikipedia.org/wiki/Nonfirstorderizability</a><a href="#fnref22" class="footnote-back">↩</a></p></li>
<li id="fn23"><p><a href="https://en.wikipedia.org/wiki/Computational_complexity_theory">https://en.wikipedia.org/wiki/Computational_complexity_theory</a><a href="#fnref23" class="footnote-back">↩</a></p></li>
<li id="fn24"><p><a href="https://plato.stanford.edu/entries/computational-complexity/">https://plato.stanford.edu/entries/computational-complexity/</a><a href="#fnref24" class="footnote-back">↩</a></p></li>
<li id="fn25"><p><a href="https://en.wikipedia.org/wiki/Worst-case_complexity">https://en.wikipedia.org/wiki/Worst-case_complexity</a><a href="#fnref25" class="footnote-back">↩</a></p></li>
<li id="fn26"><p><a href="https://en.wikipedia.org/wiki/Pullback_(category_theory)">https://en.wikipedia.org/wiki/Pullback_(category_theory)</a><a href="#fnref26" class="footnote-back">↩</a></p></li>
<li id="fn27"><p><a href="https://en.wikipedia.org/wiki/Positional_notation">https://en.wikipedia.org/wiki/Positional_notation</a><a href="#fnref27" class="footnote-back">↩</a></p></li>
<li id="fn28"><p><a href="https://en.wikipedia.org/wiki/Unary_numeral_system">https://en.wikipedia.org/wiki/Unary_numeral_system</a><a href="#fnref28" class="footnote-back">↩</a></p></li>
</ol>
</section>
                </div>
            </div>
        </main>
                        <div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
var disqus_config = function () {
    this.page.url = "https://edom.github.io/compute.html";  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = "https://edom.github.io/compute.html"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://edom-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                        <footer class="site-footer h-card">
            <data class="u-url" href="/"></data>
            <div class="wrapper">
                <p>This page was created on 2017-06-29 22:40 +0700.</p>
                <p class="rss-subscribe">There is an
                    <a href="/feed.xml">RSS feed</a>, but it's unused because this site is a wiki, not a blog.</p>
                <p>Stop writing books, papers, and blogs!
                    Write a personal wiki instead!
                    Or, even better, contribute to a community wiki.
                </p>
            </div>
        </footer>
    </body>
</html>
