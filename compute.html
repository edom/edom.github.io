<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Computing Research Group</title>
        <link rel="stylesheet" href="/assets/main.css"/>
        <script>
// Help the reader estimate how much time the reading is going to take.
// Show word count and reading time estimation in TOC entry.
//
// TOC = table of contents
//
// Known issue: This janks: this DOM manipulation is done after the page is rendered.
// If we don't want jank, we have to manipulate the HTML source before it reaches the browser.
// We assume that the user doesn't refresh the page while reading.
// The benefit of fixing that jank is not enough for me to justify trying to fix it.
document.addEventListener("DOMContentLoaded", function () {
    function count_word (string) {
        return string.trim().split(/\s+/).length;
    }
    function show_quantity (count, singular) {
        let plural = singular + "s"; // For this script only.
        return count + " " + ((count == 1) ? singular : plural);
    }
    function create_length_indicator (word, minute) {
        let e = document.createElement("span");
        e.className = "toc_entry__length_indicator";
        e.textContent = " (" + show_quantity(word, "word") + " ~ " + show_quantity(minute, "minute") + ")";
        return e;
    }
    // We assume that readers read this many words per minute with 100% comprehension.
    // This assumption may not hold for dense texts such as philosophy and mathematics.
    const wpm_assumption = 200;
    // We assume a certain Jekyll template.
    let page = document.querySelector("main.page-content");
    if (page === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"main.page-content\" does not match anything");
        return;
    }
    let page_title = document.querySelector("header.post-header h1.post-title");
    if (page_title === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"header.post-header h1.post-title\" does not match anything");
        return;
    }
    let page_word = count_word(page.textContent);
    let page_minute = Math.ceil(page_word / wpm_assumption);
    page_title.insertAdjacentElement("afterend", create_length_indicator(page_word, page_minute));
    // We violate the HTML specification.
    // The page may have several elements with the same ID.
    // We assume that Org HTML Export generates a DIV element with ID "table-of-contents".
    // We assume that Jekyll Markdown-to-HTML generates a UL element with ID "markdown-toc".
    // This only works for Org HTML Export's TOC.
    let toc_entries = document.querySelectorAll("#table-of-contents a, #text-table-of-contents a");
    toc_entries.forEach((toc_entry_a) => {
        let href = toc_entry_a.getAttribute("href"); // We assume that this is a string like "#org0123456".
        if (href.charAt(0) !== '#') {
            console.log("toc_generate_estimate: Impossible: " + href + " does not begin with hash sign");
            return;
        }
        // We can't just document.querySelector(href) because target_id may contain invalid ID characters such as periods.
        let target_id = href.substring(1);
        let id_escaped = target_id.replace("\"", "\\\"");
        let h_elem = document.querySelector("[id=\"" + id_escaped + "\"]"); // We assume that this is the h1/h2/h3 element referred by the TOC entry.
        if (h_elem === null) { // We assume that this is impossible.
            console.log("toc_generate_estimate: Impossible: " + href + " does not refer to anything");
            return;
        }
        let section = h_elem.parentNode;
        let section_word = count_word(section.textContent);
        let section_minute = Math.ceil(section_word / wpm_assumption);
        toc_entry_a.insertAdjacentElement("afterend", create_length_indicator(section_word, section_minute));
    });
});
        </script>

        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12628443-6"></script>
<script>
  window['ga-disable-UA-12628443-6'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-12628443-6');
</script>
        
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            jax: ["input/TeX","input/MathML","input/AsciiMath",
            "output/CommonHTML"
            ],
            extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "a11y/accessibility-menu.js"],
            TeX: {
                extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
                , equationNumbers: {
                    autoNumber: "AMS"
                }
            },
            "CommonHTML": {
                scale: 100
            },
            "fast-preview": {
                disabled: true,
            }
        });
        </script>
        <style>
            /*
            PreviewHTML produces small Times New Roman text.
            PreviewHTML scale doesn't work.
            */
            .MathJax_PHTML { font-size: 110%; }
        </style>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js" async defer></script>
    </head>
    <body>
        <header class="site-header" role="banner">
            <div class="wrapper">
                <a class="site-title" rel="author" href="/">Erik Dominikus Research Group</a>
            </div>
        </header>
    <div style="display:none;">\(
    \renewcommand\emptyset{\varnothing}
    \newcommand\abs[1]{\left|#1\right|}
    \newcommand\dom{\textrm{dom}}
    \newcommand\cod{\textrm{cod}}
    \newcommand\Bernoulli{\textrm{Bernoulli}}
    \newcommand\Binomial{\textrm{Binomial}}
    \newcommand\Expect[1]{\mathbb{E}[#1]}
    \newcommand\Nat{\mathbb{N}}
    \newcommand\Integers{\mathbb{Z}}
    \newcommand\Real{\mathbb{R}}
    \newcommand\Rational{\mathbb{Q}}
    \newcommand\Complex{\mathbb{C}}
    \newcommand\Pr{\mathrm{P}}
    \newcommand\Time{\text{Time}}
    \newcommand\DTime{\text{DTime}}
    \newcommand\NTime{\text{NTime}}
    \newcommand\TimeP{\text{P}}
    \newcommand\TimeNP{\text{NP}}
    \newcommand\TimeExp{\text{ExpTime}}
    \newcommand\norm[1]{\left\lVert#1\right\rVert}
    \newcommand\bbA{\mathbb{A}}
    \newcommand\bbC{\mathbb{C}}
    \newcommand\bbD{\mathbb{D}}
    \newcommand\bbE{\mathbb{E}}
    \newcommand\bbN{\mathbb{N}}
    \newcommand\frakI{\mathfrak{I}}
    % deprecated; use TimeExp
    \newcommand\ExpTime{\text{ExpTime}}
    \newcommand\Compute{\text{Compute}}
    \newcommand\Search{\text{Search}}
    % model theory structure
    \newcommand\struc[1]{\mathcal{#1}}
    \)</div>
        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
                    <header class="post-header">
                        <h1 class="post-title">Computing Research Group</h1>
                    </header>
                </article>
                <div class="post-content">
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1</span><span class="section_title"><a href="#what">What?</a></span><span class="word_count">(747w~4m)</span></li>
<li><span class="section_number">2</span><span class="section_title"><a href="#philosophy-of-language">Philosophy of language?</a></span><span class="word_count">(690w~4m)</span></li>
<li><span class="section_number">3</span><span class="section_title"><a href="#a-computation-is-what">A computation is what?</a></span><span class="word_count">(1863w~10m)</span></li>
<li><span class="section_number">4</span><span class="section_title"><a href="#an-algorithm-is-what">An algorithm is what?</a></span><span class="word_count">(331w~2m)</span></li>
<li><span class="section_number">5</span><span class="section_title"><a href="#computation-theory-is-what">Computation theory is what?</a></span><span class="word_count">(162w~1m)</span></li>
<li><span class="section_number">6</span><span class="section_title"><a href="#computer-science-is-what">Computer science is what?</a></span><span class="word_count">(76w~1m)</span></li>
<li><span class="section_number">7</span><span class="section_title"><a href="#the-mathematics-part">The mathematics part</a></span><span class="word_count">(1237w~7m)</span></li>
<li><span class="section_number">8</span><span class="section_title"><a href="#digressions-1">Digressions</a></span><span class="word_count">(1380w~7m)</span></li>
</ul>
</div>
<h2 id="what"><span class="section_number">1</span><span class="section_title">What?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.1</span><span class="section_title"><a href="#computing-theory">Computing theory</a></span><span class="word_count">(119w~1m)</span></li>
<li><span class="section_number">1.2</span><span class="section_title"><a href="#how-should-we-parse">How should we parse?</a></span><span class="word_count">(24w~1m)</span></li>
<li><span class="section_number">1.3</span><span class="section_title"><a href="#programming-language-research">Programming language research</a></span><span class="word_count">(135w~1m)</span></li>
<li><span class="section_number">1.4</span><span class="section_title"><a href="#software-engineering">Software engineering</a></span><span class="word_count">(327w~2m)</span></li>
<li><span class="section_number">1.5</span><span class="section_title"><a href="#how-should-we-make-an-intelligent-machines">How should we make an intelligent machines?</a></span><span class="word_count">(43w~1m)</span></li>
<li><span class="section_number">1.6</span><span class="section_title"><a href="#what-is-the-relationship-between-mind-and-brain">What is the relationship between mind and brain?</a></span><span class="word_count">(29w~1m)</span></li>
<li><span class="section_number">1.7</span><span class="section_title"><a href="#what-is-a-model">What is a model?</a></span><span class="word_count">(7w~1m)</span></li>
<li><span class="section_number">1.8</span><span class="section_title"><a href="#when-should-we-care-about-a-philosophically-sound-foundation-of-mathematics">When should we care about a philosophically sound foundation of mathematics?</a></span><span class="word_count">(41w~1m)</span></li>
<li><span class="section_number">1.9</span><span class="section_title"><a href="#semantics-semiotics-linguistics-confusion">Semantics, semiotics, linguistics, confusion</a></span><span class="word_count">(30w~1m)</span></li>
</ul>
</div>
<h3 id="computing-theory"><span class="section_number">1.1</span><span class="section_title">Computing theory</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.1.1</span><span class="section_title"><a href="#what-is-computation-software-program-algorithm-etc.">What is computation, software, program, algorithm, etc.?</a></span><span class="word_count">(20w~1m)</span></li>
<li><span class="section_number">1.1.2</span><span class="section_title"><a href="#what-is-the-relationship-between-p-and-np">What is the relationship between P and NP?</a></span><span class="word_count">(43w~1m)</span></li>
<li><span class="section_number">1.1.3</span><span class="section_title"><a href="#should-we-merge-approximation-theory-and-propositional-calculus">Should we merge approximation theory and propositional calculus?</a></span><span class="word_count">(57w~1m)</span></li>
</ul>
</div>
<h4 id="what-is-computation-software-program-algorithm-etc."><span class="section_number">1.1.1</span><span class="section_title">What is computation, software, program, algorithm, etc.?</span></h4>
<p>What is computation? What is software? What is a program? What is an algorithm?</p>
<h4 id="what-is-the-relationship-between-p-and-np"><span class="section_number">1.1.2</span><span class="section_title">What is the relationship between P and NP?</span></h4>
<p>What is the <a href="pnptry.html">relationship between P and NP</a>? We are trying to understand the P vs NP problem, which requires <a href="compute.html">computation</a>, <a href="model.html">model</a>, and <a href="logic.html">logic</a>. We were motivated by the prize money<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, but our chances seem slim.</p>
<h4 id="should-we-merge-approximation-theory-and-propositional-calculus"><span class="section_number">1.1.3</span><span class="section_title">Should we merge approximation theory and propositional calculus?</span></h4>
<p>Why do we want that?</p>
<p>Boolean metric spaces merge logic and analysis? How do we define a sensible approximation error? How do we define the <em>distance</em> between two formulas? The formula <span class="math inline">\( p \wedge q \)</span> <em>approximates</em> the formula <span class="math inline">\( p \wedge q \wedge r \)</span>. What is the approximation <em>error</em>?</p>
<p>What are these papers?<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a><a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<h3 id="how-should-we-parse"><span class="section_number">1.2</span><span class="section_title">How should we parse?</span></h3>
<p>How should we <a href="parse.html">parse</a>? While studying parsing, we had to understand Brzozowski quotient and set division, so we wrote <a href="division.html">Generalizing division</a>.</p>
<h3 id="programming-language-research"><span class="section_number">1.3</span><span class="section_title">Programming language research</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.3.1</span><span class="section_title"><a href="#what-language-is-like-prolog-but-has-anonymous-predicates-and-anonymous-modules">What language is like Prolog but has anonymous predicates and anonymous modules?</a></span><span class="word_count">(15w~1m)</span></li>
<li><span class="section_number">1.3.2</span><span class="section_title"><a href="#what-should-programming-language-be">What should programming language be?</a></span><span class="word_count">(90w~1m)</span></li>
<li><span class="section_number">1.3.3</span><span class="section_title"><a href="#where-should-we-publish-our-programming-language-research-findings">Where should we publish our programming language research findings?</a></span><span class="word_count">(30w~1m)</span></li>
</ul>
</div>
<h4 id="what-language-is-like-prolog-but-has-anonymous-predicates-and-anonymous-modules"><span class="section_number">1.3.1</span><span class="section_title">What language is like Prolog but has anonymous predicates and anonymous modules?</span></h4>
<p>We are <a href="prolog.html">using Prolog</a>.</p>
<h4 id="what-should-programming-language-be"><span class="section_number">1.3.2</span><span class="section_title">What should programming language be?</span></h4>
<p>What should <a href="proglang.html">programming language</a> be?</p>
<p>How should <a href="haskell.html">Haskell</a> be improved?</p>
<ul>
<li>How do we use Haskell without fmap, ap, and other annoying syntactic baggages? How do we have Maybe(A) = A union {Nothing}? (The original question that started it all.)</li>
<li>What does a set-theoretic type system look like? (The consequence of wanting Maybe(A) = A union {Nothing}.)</li>
<li>What if the denotational semantics directly involve functors and monads?</li>
<li>Why should we use that language / write programs that way?</li>
<li>Is there an efficient implementation?</li>
</ul>
<p>How should lambda calculus be implemented? What is an optimal implementation?</p>
<h4 id="where-should-we-publish-our-programming-language-research-findings"><span class="section_number">1.3.3</span><span class="section_title">Where should we publish our programming language research findings?</span></h4>
<p>Should we publish at ICFP, PLDI, POPL, SPLASH/OOPSLA, or Salon des Refusés?</p>
<p>POPL has the &quot;Off the beaten track&quot;.</p>
<p>I want maximum open access.</p>
<h3 id="software-engineering"><span class="section_number">1.4</span><span class="section_title">Software engineering</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.4.1</span><span class="section_title"><a href="#how-should-we-build-software">How should we build software?</a></span><span class="word_count">(17w~1m)</span></li>
<li><span class="section_number">1.4.2</span><span class="section_title"><a href="#how-do-we-reverse-engineer-software">How do we reverse-engineer software?</a></span><span class="word_count">(139w~1m)</span></li>
<li><span class="section_number">1.4.3</span><span class="section_title"><a href="#management-hiring-salary">Management, hiring, salary?</a></span><span class="word_count">(27w~1m)</span></li>
<li><span class="section_number">1.4.4</span><span class="section_title"><a href="#what-is-software-engineering">What is software engineering?</a></span><span class="word_count">(56w~1m)</span></li>
<li><span class="section_number">1.4.5</span><span class="section_title"><a href="#how-should-we-build-freelibre-open-source-software">How should we build free/libre open-source software?</a></span><span class="word_count">(32w~1m)</span></li>
<li><span class="section_number">1.4.6</span><span class="section_title"><a href="#what-1">What?</a></span><span class="word_count">(60w~1m)</span></li>
</ul>
</div>
<h4 id="how-should-we-build-software"><span class="section_number">1.4.1</span><span class="section_title">How should we build software?</span></h4>
<p>Sometimes I think about forward software engineering, such as <a href="softeng.html">making lasting software sooner</a>.</p>
<h4 id="how-do-we-reverse-engineer-software"><span class="section_number">1.4.2</span><span class="section_title">How do we reverse-engineer software?</span></h4>
<p>Sometimes I think about <a href="reveng.html">reverse software engineering</a>, such as <a href="ps1.html">Reverse-engineering PlayStation 1 3D games to control the camera</a>. I am interested in reverse-engineering these PlayStation 1 games: Street Fighter EX Plus Alpha, Virtual Hiryu No Ken, and Tekken 3.</p>
<p>I wanted to automate stock trading with my broker which has a stock trading application written in Java 6. Thus I wrote <a href="rejava.html">Reverse engineering the network protocol used by a Java desktop application</a>. But now I think financial economy is just a big Ponzi scheme full of rent-seeking, full of people who want to get a slice of the pie of real economy without growing the pie of real economy, full of people who just want to extract value from society without creating value, people who only take but don't give, people who only shuffle money around.</p>
<h4 id="management-hiring-salary"><span class="section_number">1.4.3</span><span class="section_title">Management, hiring, salary?</span></h4>
<p>I tried to think about <a href="engman.html">managing software engineers</a>. I thought about <a href="salary.html">software engineer salary</a>.</p>
<p>&quot;When hiring senior engineers, you’re not buying, you’re selling.&quot; (Alexander von Franqué)<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<h4 id="what-is-software-engineering"><span class="section_number">1.4.4</span><span class="section_title">What is software engineering?</span></h4>
<p>Is software engineering engineering? What is engineering?</p>
<p>If software is a pure art, then its construction shouldn't be time-limited. A painter doesn't paint with deadlines. A painting is finished when the painter feels it's finished. However, a painter, when asked to paint a very specific painting, can estimate how many days it will take.</p>
<h4 id="how-should-we-build-freelibre-open-source-software"><span class="section_number">1.4.5</span><span class="section_title">How should we build free/libre open-source software?</span></h4>
<p>I am thinking about open-source. I prefer cooperation to competition. I write <a href="opensrc.html">Making contributable open-source projects</a>, <a href="community.html">Building online communities</a>. I am thinking about maintaining open-source projects.</p>
<h4 id="what-1"><span class="section_number">1.4.6</span><span class="section_title">What?</span></h4>
<p>I summarized the <a href="smf.html">Standard MIDI file format</a>. I was thinking about making a digital audio workstation, but I changed my mind about music.</p>
<p>&lt;2018-10-28&gt; Systemd programmers are not competent enough for what they are doing.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a><a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<p>Computers feel slow not because hardware sucks, but because programmers tell it to do stupid things. Ever-stronger hardware lets more programmers get away with writing ever-shittier software.</p>
<h3 id="how-should-we-make-an-intelligent-machines"><span class="section_number">1.5</span><span class="section_title">How should we make an intelligent machines?</span></h3>
<p>I am looking for an AI that helps me process data into information. Thus I write <a href="intelligence.html">Making intelligence</a> and <a href="endo.html">The endofunction model of worlds and agents, and its philosophical implications</a>. But I think my chances are slim.</p>
<h3 id="what-is-the-relationship-between-mind-and-brain"><span class="section_number">1.6</span><span class="section_title">What is the relationship between mind and brain?</span></h3>
<p>What is the <a href="philo.html">relationship between mind and brain</a>?</p>
<p>Our brain is analog, but our mind is digital? Is our brain analog or digital?<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a><a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a></p>
<h3 id="what-is-a-model"><span class="section_number">1.7</span><span class="section_title">What is a model?</span></h3>
<p>What is a <a href="model.html">model</a>?</p>
<h3 id="when-should-we-care-about-a-philosophically-sound-foundation-of-mathematics"><span class="section_number">1.8</span><span class="section_title">When should we care about a philosophically sound foundation of mathematics?</span></h3>
<p>Math seems to work just fine even if it isn't philosophically justified. Why should we care about finitism?</p>
<p>I am <a href="finite.html">looking for a philosophically sound foundation of mathematics</a>. It may be finitism.</p>
<h3 id="semantics-semiotics-linguistics-confusion"><span class="section_number">1.9</span><span class="section_title">Semantics, semiotics, linguistics, confusion</span></h3>
<p>Jake Mitchell pointed out<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> that there are a lot of confusing pair of terms in philosophy: sense and reference, signifier and signified, use-mention distinction, concept and object.</p>
<h2 id="philosophy-of-language"><span class="section_number">2</span><span class="section_title">Philosophy of language?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">2.1</span><span class="section_title"><a href="#the-english-suffix--er-means-one-who-does">The English suffix -er means one who does</a></span><span class="word_count">(58w~1m)</span></li>
<li><span class="section_number">2.2</span><span class="section_title"><a href="#the-english-suffix--ion-nominalizes-latinate-verbs">The English suffix -ion nominalizes Latinate verbs</a></span><span class="word_count">(255w~2m)</span></li>
<li><span class="section_number">2.3</span><span class="section_title"><a href="#how-do-we-answer-what-is-something">How do we answer &quot;What is something?&quot;</a></span><span class="word_count">(304w~2m)</span></li>
<li><span class="section_number">2.4</span><span class="section_title"><a href="#concrete-and-abstract-objects">Concrete and abstract objects?</a></span><span class="word_count">(74w~1m)</span></li>
</ul>
</div>
<h3 id="the-english-suffix--er-means-one-who-does"><span class="section_number">2.1</span><span class="section_title">The English suffix -er means one who does</span></h3>
<p>&quot;Computer&quot; comes from &quot;compute&quot; and &quot;-er&quot;. Thus, a computer is a thing that computes.</p>
<p>Appending -er to a verb V forms the noun Ver which means &quot;one who does V&quot;, which we often stretch to mean &quot;a thing that does V&quot;, so that a Ver does not have to be a person.</p>
<h3 id="the-english-suffix--ion-nominalizes-latinate-verbs"><span class="section_number">2.2</span><span class="section_title">The English suffix -ion nominalizes Latinate verbs</span></h3>
<p>Nominalization turns a word into a noun.<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a></p>
<p>&quot;Computation&quot; comes from &quot;compute&quot; and &quot;-ation&quot;.</p>
<p>The suffix -ation comes from -ate + -ion.<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a> Appending -ion to a Latinate verb Vate forms the noun Vation.</p>
<p>For example, an explosion is an action, but not a process, and not a condition, and not a state. However, an explosion looks fast because we are humans and we are relatively stationary to the explosion; it would look slow if we were traveling near the speed of light with respect to the explosion.</p>
<p>A process is an action that takes some time?</p>
<p>Computation is a process. This is supported by the usage &quot;this computation does not terminate&quot;, the usage &quot;this computation produces 123&quot;, and the non-usage &quot;this computation is 123&quot;.</p>
<p>The sentence S V O translates to the logic formula V(S,O). Example: &quot;John eats bread&quot; translates to &quot;eat(John,bread)&quot;, or, &quot;john(x), bread(y), eat(x,y)&quot;.</p>
<p>S V O = S does NV to O, where NV is the nominalized V. Examples. He is renovating (renewing) his house = he is doing a renovation to his house. He is manducating the food = he is doing a manducation to the food. He is computing the number = he is doing a computation to the number? How can we do something to an abstract thing with no material existence?</p>
<p>NV is P = S VP iff S V. Stealing is bad = S steals iff S is bad. Stealing is taking others' belongings without their permission = S steals iff S takes others' belongings without their permission.</p>
<p><span class="citation" data-cites="hamm2013formal">[<a href="#ref-hamm2013formal">6</a>]</span>. <span class="citation" data-cites="zucchi2013language">[<a href="#ref-zucchi2013language">18</a>]</span> paywall.</p>
<h3 id="how-do-we-answer-what-is-something"><span class="section_number">2.3</span><span class="section_title">How do we answer &quot;What is something?&quot;</span></h3>
<p>It is difficult. Consider this example: What is an elephant? There are several possible answers:</p>
<ul>
<li>An elephant E is an individual whose genetic code makes it belong to a species of the Elephantidae family, such that E can mate with other members of the species and produce fertile offsprings. But this begets another question: what is a member of the Elephantidae family?</li>
<li>An elephant is a big gray mammal with proboscis.</li>
</ul>
<p>But those are what <em>we think</em> an elephant is, not what an elephant is. What is the essence of an elephant? What is true of elephants regardless whether there were humans to describe elephants? An individual's genes determine whether it is an elephant, but the genes themselves are not the elephant.</p>
<p>We often conflate a thing and its representations. For example, in everyday conversation, we call a drawing of an elephant an &quot;elephant&quot;, and we call an elephant statue an &quot;elephant&quot;. Ontologically, they are a drawing and a statue, and not an elephant. But calling them &quot;drawing&quot; and &quot;statue&quot; is considered uninformative. Therefore, the semantics of language depends on context.</p>
<p>Of these two conversations, the first one is practically correct but ontologically wrong, and the second one is practically wrong but ontologically correct.</p>
<ul>
<li>&quot;What is this?&quot; &quot;An elephant.&quot;</li>
<li>&quot;What is this?&quot; &quot;A drawing.&quot; &quot;I know. A drawing of what?&quot; &quot;An elephant.&quot;</li>
</ul>
<p>The practically correct conversation is the one that conveys the most information. If something has higher computational complexity, then it has more information? It is harder to see that the drawing is of an elephant than it is to see that the drawing is a drawing.</p>
<p>Suppose that I draw an elephant on a sheet of paper. Is it a sheet of paper, is it a drawing, or is it an elephant?</p>
<p>Kurzgesagt has a video<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a> that discusses &quot;What is something&quot; from physics point of view.</p>
<h3 id="concrete-and-abstract-objects"><span class="section_number">2.4</span><span class="section_title">Concrete and abstract objects?</span></h3>
<p>Concrete objects exist in material space. Abstract objects exist in ideal space. The mind manipulates abstract objects. The hand manipulates concrete objects. But those definitions have problems with dreaming, hallucination, imagination. If I imagine myself holding a box, is that box a concrete object? No. That box exists only in my imagination.</p>
<p>Concrete objects are real? Abstract objects are not real? But how can something unreal be true?</p>
<p>Abstract vs concrete objects <span class="citation" data-cites="sep-abstract-objects">[<a href="#ref-sep-abstract-objects">13</a>]</span>.</p>
<h2 id="a-computation-is-what"><span class="section_number">3</span><span class="section_title">A computation is what?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.1</span><span class="section_title"><a href="#how-do-we-answer-that-question">How do we answer that question?</a></span><span class="word_count">(122w~1m)</span></li>
<li><span class="section_number">3.2</span><span class="section_title"><a href="#the-thing-common-to-all-computers-must-be-computation">The thing common to all computers must be computation</a></span><span class="word_count">(347w~2m)</span></li>
<li><span class="section_number">3.3</span><span class="section_title"><a href="#linguistic-analysis-of-compute">Linguistic analysis of &quot;compute&quot;</a></span><span class="word_count">(111w~1m)</span></li>
<li><span class="section_number">3.4</span><span class="section_title"><a href="#a-computation-does-not-always-end">A computation does not always end</a></span><span class="word_count">(106w~1m)</span></li>
<li><span class="section_number">3.5</span><span class="section_title"><a href="#to-compute-is-to-do-mathematics">To compute is to do mathematics?</a></span><span class="word_count">(104w~1m)</span></li>
<li><span class="section_number">3.6</span><span class="section_title"><a href="#a-computation-is-a-discrete-model-of-reality">A computation is a discrete model of reality?</a></span><span class="word_count">(230w~2m)</span></li>
<li><span class="section_number">3.7</span><span class="section_title"><a href="#to-compute-a-function-is-what">To compute a function is what?</a></span><span class="word_count">(198w~1m)</span></li>
<li><span class="section_number">3.8</span><span class="section_title"><a href="#a-relation-is-a-triple-of-domain-codomain-pairing">A relation is a triple of domain-codomain-pairing</a></span><span class="word_count">(83w~1m)</span></li>
<li><span class="section_number">3.9</span><span class="section_title"><a href="#what-can-be-computed">What can be computed?</a></span><span class="word_count">(214w~2m)</span></li>
<li><span class="section_number">3.10</span><span class="section_title"><a href="#do-not-conflate-a-thing-and-its-representations">Do not conflate a thing and its representations</a></span><span class="word_count">(354w~2m)</span></li>
</ul>
</div>
<h3 id="how-do-we-answer-that-question"><span class="section_number">3.1</span><span class="section_title">How do we answer that question?</span></h3>
<p>We want to define the noun &quot;computer&quot;, the noun &quot;computation&quot;, and the verb &quot;compute&quot;. How do we do that?</p>
<p>We understand a word by scrutinizing its <em>origin</em> (where it comes from, how it is formed) and <em>usage</em> (how it is used). We analyze the English suffixes -er and -ation. We define the nouns &quot;computer&quot; and &quot;computation&quot; in terms of the verb &quot;compute&quot; and those suffixes. Thus, the real problem is defining &quot;compute&quot;, &quot;-er&quot;, and &quot;-ation&quot;.</p>
<p>We analyze the subject and object of the verb &quot;compute&quot;.</p>
<p>We analyze what and how analog and digital computers compute.</p>
<p>We find out what is common among all computers. We look at some history of computers.</p>
<p>We craft a definition of &quot;compute&quot; that satisfies all those computers.</p>
<h3 id="the-thing-common-to-all-computers-must-be-computation"><span class="section_number">3.2</span><span class="section_title">The thing common to all computers must be computation</span></h3>
<p>Both analog and digital computers compute, but what and how? Let us compare an analog adder and a digital adder.</p>
<p>An <em>analog inverting adder</em> is modeled as a network of operational amplifiers and resistors.<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a><a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a> The inputs are <span class="math inline">\(v_1\)</span> and <span class="math inline">\(v_2\)</span>. The output is <span class="math inline">\(v_3\)</span>. Each of <span class="math inline">\(v_?,r_?,g_?\)</span> is a random variable (which implies a probability distribution), not a number, due to physical imperfections. Thus an analog computer computes inexactly. The operation of a two-input inverting adder is modeled as: <span class="math display">\[
v_3 = - r_f \cdot \left( g_1 \cdot v_1 + g_2 \cdot v_2 \right)
\]</span></p>
<p>A <em>digital adder</em> is modeled as a network of logic gates.<a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a> A number is represented as a bit string. The inputs are <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>; each is <span class="math inline">\(n\)</span> bits long. The output is <span class="math inline">\(s\)</span>. The index <span class="math inline">\(k\)</span> goes from 0 to <span class="math inline">\(n-1\)</span>. The operation of a ripple adder is modeled as:</p>
<span class="math display">\[\begin{align*}
s_k &amp;= (a_k \oplus b_k) \oplus c_{k-1}
\\ c_k &amp;= a_k \wedge b_k \wedge c_{k-1}
\\ c_{-1} &amp;= 0
\end{align*}
\]</span>
<p>What is common: Computation is the operation done by a computer. The above equations are <em>models</em> of computation. Both analog and digital adder computes addition. But the analog one models the addition of two random variables; the digital one models the modular addition of natural numbers modulo <span class="math inline">\(2^n\)</span>.</p>
<p>In 1640, a <em>computer</em> is a human calculator.<a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a> In 1897, a computer is a mechanical calculator.<a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a> In 1945, a computer is an electronic calculator.<a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a> All those computers ran approximation algorithms to generate look-up tables of values of transcendental functions. There are also <em>analog computers</em> made with operational amplifiers<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a>, as opposed to <em>digital computers</em> made with logic gates<a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a>.</p>
<p>As we build stronger computers, we begin trying to simulate reality, and we wonder whether the Universe is just an extremely powerful computer. The world progressed explosively, despite being built on increasingly complex computer systems with ever-more undefined behaviors, occasionally killing people. However, modernization does not change the essence of computation.</p>
<p>In the 1970s, a computer was a desktop computer, calculation gained a numerical connotation,</p>
<p>A calculator is a computer specialized for numerical problems. and thus calculation is numerical computation. In 2019, a human calculator is a human who can mentally manipulate digits quickly and correctly.</p>
<h3 id="linguistic-analysis-of-compute"><span class="section_number">3.3</span><span class="section_title">Linguistic analysis of &quot;compute&quot;</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.3.1</span><span class="section_title"><a href="#the-subject-and-object-of-compute-are-concrete-and-abstract-respectively">The subject and object of &quot;compute&quot; are concrete and abstract, respectively</a></span><span class="word_count">(61w~1m)</span></li>
<li><span class="section_number">3.3.2</span><span class="section_title"><a href="#adjectives-tell-us-what-about-computations">Adjectives tell us what about computations?</a></span><span class="word_count">(48w~1m)</span></li>
</ul>
</div>
<h4 id="the-subject-and-object-of-compute-are-concrete-and-abstract-respectively"><span class="section_number">3.3.1</span><span class="section_title">The subject and object of &quot;compute&quot; are concrete and abstract, respectively</span></h4>
<p>The subject of &quot;compute&quot; is a concrete object (with material existence). Examples of such subjects are some machines and some animals<a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a>.</p>
<p>The object of &quot;compute&quot; is an abstract object (with no material existence). For example, it makes sense to compute a number, but it does not make sense to compute a chair.</p>
<h4 id="adjectives-tell-us-what-about-computations"><span class="section_number">3.3.2</span><span class="section_title">Adjectives tell us what about computations?</span></h4>
<p>Reversible computation relates erasure of information, entropy, and heat. &quot;Reversible&quot; implies that there is a forward direction.</p>
<p>Is interactive computation computation<a href="#fn22" class="footnote-ref" id="fnref22"><sup>22</sup></a>?</p>
<p>Must algorithms describe only terminating computations? An operating system describes an interactive computation. Computers do not exist in a vacuum. Computers interact with reality.</p>
<h3 id="a-computation-does-not-always-end"><span class="section_number">3.4</span><span class="section_title">A computation does not always end</span></h3>
<p>A machine &quot;computes <span class="math inline">\(y\)</span> from <span class="math inline">\(x\)</span>&quot; iff the machine ends with a representation of <span class="math inline">\(y\)</span> if the machine is started with a representation of <span class="math inline">\(x\)</span>. Alas, this definition has two big problems:</p>
<ul>
<li>Must a computation be <em>started</em> by something outside the computer?</li>
<li>What is <em>representation</em>?</li>
</ul>
<p>A computation may not end. A Turing machine may compute without terminating.<a href="#fn23" class="footnote-ref" id="fnref23"><sup>23</sup></a><a href="#fn24" class="footnote-ref" id="fnref24"><sup>24</sup></a> For example, a machine may compute 2/3 (whose binary expansion 0.10… does not terminate) by repeatedly printing 10 forever.</p>
<p>(In this document, I always use &quot;may&quot; in the epistemic sense, and never in the deontic sense<a href="#fn25" class="footnote-ref" id="fnref25"><sup>25</sup></a>. Thus &quot;may not&quot; and &quot;does not have to&quot; have the same meaning.)</p>
<h3 id="to-compute-is-to-do-mathematics"><span class="section_number">3.5</span><span class="section_title">To compute is to do mathematics?</span></h3>
<p>The way we use the verb &quot;compute&quot; implies that computation is a model of how reality does some mathematics.</p>
<p>What do we mean by &quot;doing mathematics&quot;?</p>
<p>Something computes iff we think it does some mathematics. <em>To compute is to do some mathematics.</em> Mathematics is not only arithmetics, but also logic, etc.</p>
<p>But what about analog computers, such as an operational amplifier that &quot;adds two real numbers&quot;, or &quot;integrate a real function&quot;?</p>
<p>An analog computer can integrate a real function. A digital computer cannot.</p>
<p>Are there programmable analog computers?</p>
<p>What does a programmable analog computer look like?</p>
<p>How would analog computers have conditionals, loops, and other constructs?</p>
<h3 id="a-computation-is-a-discrete-model-of-reality"><span class="section_number">3.6</span><span class="section_title">A computation is a discrete model of reality?</span></h3>
<p>Problem: analog computers invalidate this definition.</p>
<p>Our knowledge of physics is a model of reality.</p>
<p>Computation is a circumstantial/occasional/special discretization of the laws of physics. We can model an electronic computer containing 100 bipolar-junction transistors as 300 numbers, each representing voltage at each terminal of each transistor. We can also model the same computer as 100 bits.</p>
<p>Computation is a discrete sequential logical model of reality.</p>
<p>A machine simply acts according to the laws of physics, but we interpret some of such acts as a computation. This implies that a computation is what we think a physical system does, not what the system actually does. Thus, <em>a computation is a discrete sequential model of what some physical systems do</em>.</p>
<p>Computation is our way of thinking about what the machine does. We invent the concept of computation because we are eager to patterns everywhere. Our understanding of computation enables us to manipulate machines into doing what we want.</p>
<p>Computation has no material existence. What exist materially are machines acting according to the laws of physics.</p>
<p>A computation is an <em>explanation</em> of what a machine does. If machine A computes Y from X, and machine B computes Z from Y, then the machine built from those machines computes Z from X.</p>
<p>However, if objective reality exists, then the machine will still compute, regardless of whether we exist to describe what the machine does.</p>
<h3 id="to-compute-a-function-is-what"><span class="section_number">3.7</span><span class="section_title">To compute a function is what?</span></h3>
<p>A machine &quot;computes the function <span class="math inline">\(f:D\to C\)</span>&quot; iff, for each <span class="math inline">\(x\in D\)</span>, the machine computes <span class="math inline">\(f(x)\)</span> from <span class="math inline">\(x\)</span>. But a mathematical function may be infinite, whereas a machine is finite. We often ignore ontology and say that a machine computes the function <span class="math inline">\(f\)</span> to mean that the machine computes an interesting <em>finite subfunction</em> of <span class="math inline">\(f\)</span>. No machine can manipulate <em>every</em> number, because there is always a number that is too big to physically represent. It is physically impossible to manipulate extremely big natural numbers. For example, no machine truly implements the addition of every possible two natural numbers, because it is physically impossible. We can <em>describe</em> an extremely large number, but we can only visually imagine five to nine things.</p>
<p>What is a function?</p>
<p>We must distinguish relations and expressions. Which of these is a function: <span class="math inline">\(\{(0,1),(1,2),\ldots\}\)</span> or <span class="math inline">\(x \mapsto x+1\)</span>? Neither. A function <span class="math inline">\(f : D \to C\)</span> is a <em>triple of sets</em> <span class="math inline">\((D,C,F)\)</span> where <span class="math inline">\(F \subseteq D \times C\)</span>, and <span class="math inline">\(f(x)=y\)</span> means <span class="math inline">\((x,y) \in F\)</span>, and <span class="math inline">\(\forall x \forall y ( x = y \to f(x) = f(y) )\)</span>. See also Rapaport 2005 <span class="citation" data-cites="rapaport2005philosophy">[<a href="#ref-rapaport2005philosophy">12</a>]</span>, section 7.3.1.3 (&quot;Interlude: functions described as machines&quot;), page 239.</p>
<h3 id="a-relation-is-a-triple-of-domain-codomain-pairing"><span class="section_number">3.8</span><span class="section_title">A relation is a triple of domain-codomain-pairing</span></h3>
<p>A function is <em>extensionally</em> described by showing each pairing in the function. Thus this only works for <em>finite</em> functions, because we do not have the time to write down each pairing in an infinite function. The magic ellipsis is not an extensional description. An example of such ellipsis is the triple dots &quot;<span class="math inline">\(\ldots\)</span>&quot; in <span class="math inline">\(0,1,2,\ldots\)</span>. Such ellipsis means &quot;and so on&quot;.</p>
<p>See also Rapaport 2005 <span class="citation" data-cites="rapaport2005philosophy">[<a href="#ref-rapaport2005philosophy">12</a>]</span>, section 7.3.1 (&quot;What is a function?&quot;) and its descendants, from page 236.</p>
<h3 id="what-can-be-computed"><span class="section_number">3.9</span><span class="section_title">What can be computed?</span></h3>
<p>A machine &quot;computes the set <span class="math inline">\(D\)</span>&quot; iff, for each <span class="math inline">\(x \in D\)</span>, the machine <em>can</em> determine the truth of <span class="math inline">\(r(x) \in R(D)\)</span>, where <span class="math inline">\(r\)</span> is the computation's encoding scheme, and <span class="math inline">\(R(D) = \{ r(x) ~|~ x \in D \}\)</span>.</p>
<p>A machine &quot;computes the (infinite) sequence <span class="math inline">\(x\)</span>&quot; iff the machine computes every finite prefix of <span class="math inline">\(x\)</span>. That means: given ever-longer time to run, the machine computes an ever-longer prefix of the sequence. Thus, a computation does not have to end; it may run forever. The sequence <span class="math inline">\(x\)</span> can be identified by the function <span class="math inline">\(f : \Nat \to A\)</span>, in the way <span class="math inline">\(x_k = f(k)\)</span>.</p>
<p>Turing 1937 <span class="citation" data-cites="turing1937computable">[<a href="#ref-turing1937computable">15</a>]</span> defines a computable number as a number whose digits can be generated by a machine. Thus, to compute a number is to compute the sequence of its digits, using an algorithm (a finite description).</p>
<p>A machine that <em>generates</em> a sequence computes something from <em>nothing</em>.</p>
<p>What does an operating system compute?</p>
<p>Piccinini distinguishes abstract computation and concrete computation <span class="citation" data-cites="sep-computation-physicalsystems">[<a href="#ref-sep-computation-physicalsystems">11</a>]</span>.</p>
<p>Defining computation as the execution of an algorithm raises difficult issues <span class="citation" data-cites="scheutz2006computation">[<a href="#ref-scheutz2006computation">14</a>]</span>.</p>
<p>Rapaport's 2005 book <span class="citation" data-cites="rapaport2005philosophy">[<a href="#ref-rapaport2005philosophy">12</a>]</span> deals with things in the layer below the layer we work at.</p>
<p>Does a quantum computation consist of discrete steps?</p>
<p>Immerman 1999 <span class="citation" data-cites="Immerman99descriptivecomplexity">[<a href="#ref-Immerman99descriptivecomplexity">7</a>]</span>, in Definition 2.4 (page 25), defines what it means for a Turing machine to compute a query.</p>
<h3 id="do-not-conflate-a-thing-and-its-representations"><span class="section_number">3.10</span><span class="section_title">Do not conflate a thing and its representations</span></h3>
<p>First, we undo the chronic ontologically-sloppy habit of conflating a thing and a representation of the thing. &quot;123&quot; is not a number, but a <em>representation</em> of a number. We cannot manipulate numbers physically because they do not have material existence. We can only manipulate the physical representations of those numbers. When we &quot;add two numbers&quot;, we are actually manipulating the representations of those numbers in a way that corresponds to adding those numbers. Formally, if <span class="math inline">\(e : \Nat \to \{0,1\}^*\)</span> is an encoding scheme, then <span class="math inline">\( e(x+y) = e(x) +_e e(y) \)</span>, where <span class="math inline">\(+\)</span> is the operation that we think we do, and <span class="math inline">\(+_e\)</span> is the operation that we actually do. We think we are adding numbers, but we are actually writing symbols on paper or juggling symbols in our mind.</p>
<p>Then, we un-conflate a program and a machine running the program. A program does not <em>compute</em>; it is the machine that computes. A program cannot do anything on its own; a machine has to run it. When we say &quot;a program computes a function&quot;, we actually mean that running the program on the machine causes the machine to compute that function.</p>
<p>An algorithm describes how to compute something but does not compute what is described, because an algorithm is a mathematical object with no material existence. An algorithm describing how to calculate a number does not itself calculate the number, in the same way a recipe describing how to cook an egg does not itself cook the egg. A recipe has no material existence; what has material existence is the physical medium (such as ink and paper) that is used to describe that recipe in the symbols we agreed upon.</p>
<p>Unfortunately, the ontologically correct thing is very wordy, so I write in conflated manner. For example, when I write &quot;this program adds two numbers&quot;, what I really mean is &quot;running the program causes the machine to manipulate two representations in a way that corresponds to adding two numbers&quot;. Fortunately, the only time we have to care about this ontological issue is when we are talking about the foundations of computation.</p>
<h2 id="an-algorithm-is-what"><span class="section_number">4</span><span class="section_title">An algorithm is what?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">4.1</span><span class="section_title"><a href="#an-algorithm-is-what-1">An algorithm is what?</a></span><span class="word_count">(272w~2m)</span></li>
<li><span class="section_number">4.2</span><span class="section_title"><a href="#algorithm-is-how-problem-is-what">Algorithm is how, problem is what</a></span><span class="word_count">(30w~1m)</span></li>
<li><span class="section_number">4.3</span><span class="section_title"><a href="#algorithm-machine-implementation-and-computation-are-what">Algorithm, machine, implementation, and computation are what?</a></span><span class="word_count">(28w~1m)</span></li>
</ul>
</div>
<h3 id="an-algorithm-is-what-1"><span class="section_number">4.1</span><span class="section_title">An algorithm is what?</span></h3>
<p>In 1690, an <em>algorithm</em> is an Arabic system of computation.<a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a> It is the historically-and-interculturally mangled name of Muhammad ibn Musa al-Khwarizmi<a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a> who lived in the 8th century. An <em>algorithm</em> is a finite description of how a computer computes something. In the medievals, an algorithm is a numerical approximation scheme to be run by humans. Anyone who knows basic arithmetics can mindlessly carry out an algorithm and produce a correct answer without any understanding of why or how the algorithm works.</p>
<p>An algorithm restates a function as a composition of <em>primitives</em>.</p>
<p>Some note about ontology: The long addition algorithm does not describe how to add two numbers <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. It describes how to manipulate two <em>representations</em> <span class="math inline">\(e(x)\)</span> and <span class="math inline">\(e(y)\)</span> in order to produce a third representation <span class="math inline">\(e(x+y)\)</span> that represents the sum of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</p>
<p>An approximation scheme describes a number iff the sequence of approximations converges to the number. The approximation may never reach the number, but it always gets closer.</p>
<p>An algorithm is a finite description. Description implies language, presumably a formal language. Language implies syntax and semantics. Thus an algorithm is a string in a language.</p>
<p>There are many formal languages: Turing, Post, primitive recursive arithmetics, lambda calculus, ML-family languages, computation models<a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a>, etc. There are lots of computation models, each capturing different aspect, but most are equivalently powerful.</p>
<p>The language should have a sensible cost model so that we can define space complexity and time complexity.</p>
<p>Rapaport 2015 <span class="citation" data-cites="rapaport2005philosophy">[<a href="#ref-rapaport2005philosophy">12</a>]</span> p. 269 mentions Moschovakis's idea of algorithms as recursors. See Vardi 2012 <span class="citation" data-cites="vardi2012algorithm">[<a href="#ref-vardi2012algorithm">17</a>]</span>, Gurevich 2011 <span class="citation" data-cites="gurevich2011algorithm">[<a href="#ref-gurevich2011algorithm">5</a>]</span>, Gurevich 2012 <span class="citation" data-cites="gurevich2012foundational">[<a href="#ref-gurevich2012foundational">4</a>]</span>, Moschovakis 2001 <span class="citation" data-cites="moschovakis2001algorithm">[<a href="#ref-moschovakis2001algorithm">10</a>]</span>. See also Japaridze's computability logic<a href="#fn29" class="footnote-ref" id="fnref29"><sup>29</sup></a><a href="#fn30" class="footnote-ref" id="fnref30"><sup>30</sup></a>. It is a game-theoretic model of computation.</p>
<h3 id="algorithm-is-how-problem-is-what"><span class="section_number">4.2</span><span class="section_title">Algorithm is how, problem is what</span></h3>
<p>An algorithm describes <em>how</em> to compute something.</p>
<p>A problem describes <em>what</em> to compute.</p>
<p>See also Rapaport 2005 <span class="citation" data-cites="rapaport2005philosophy">[<a href="#ref-rapaport2005philosophy">12</a>]</span> page 242, about the difference between formulas and algorithms.</p>
<h3 id="algorithm-machine-implementation-and-computation-are-what"><span class="section_number">4.3</span><span class="section_title">Algorithm, machine, implementation, and computation are what?</span></h3>
<p>If algorithm A describes how to compute C, and machine M implements algorithm A, then machine M computes C.</p>
<p>Are there undescribable computations?</p>
<h2 id="computation-theory-is-what"><span class="section_number">5</span><span class="section_title">Computation theory is what?</span></h2>
<p>Computation theory spans philosophy, physics, and mathematics. The mathematics part<a href="#fn31" class="footnote-ref" id="fnref31"><sup>31</sup></a> studies logical models of computation, not computation itself. Which part of computation theory are we interested in? This document is mostly the mathematics part, because there is a one-million-dollar prize for solving the P vs NP problem. See Piccinini 2017 <span class="citation" data-cites="sep-computation-physicalsystems">[<a href="#ref-sep-computation-physicalsystems">11</a>]</span> if you are interested in the philosophy and physics parts.</p>
<p>1999 Immerman <span class="citation" data-cites="Immerman99descriptivecomplexity">[<a href="#ref-Immerman99descriptivecomplexity">7</a>]</span>, 2009 Arora &amp; Barak <span class="citation" data-cites="Arora2009">[<a href="#ref-Arora2009">1</a>]</span>, 2009 Marek &amp; Remmel <span class="citation" data-cites="Marek2009">[<a href="#ref-Marek2009">9</a>]</span>, 2002 Boolos, Burgess, &amp; Jeffrey <span class="citation" data-cites="Boolos2002">[<a href="#ref-Boolos2002">2</a>]</span>, 1987 Rogers <span class="citation" data-cites="Rogers1987">[<a href="#ref-Rogers1987">8</a>]</span>.</p>
<p>Where are the researchers? There is ACM Special Interest Group on Logic and Computation (SIGLOG)<a href="#fn32" class="footnote-ref" id="fnref32"><sup>32</sup></a>. There is also Computational Complexity Conference<a href="#fn33" class="footnote-ref" id="fnref33"><sup>33</sup></a>.</p>
<p>We can think of computation theory as refining these hierarchies: automaton power hierarchy<a href="#fn34" class="footnote-ref" id="fnref34"><sup>34</sup></a>, problem complexity hierarchy, logic strength hierarchy, Chomsky language hierarchy<a href="#fn35" class="footnote-ref" id="fnref35"><sup>35</sup></a>, arithmetical hierarchy<a href="#fn36" class="footnote-ref" id="fnref36"><sup>36</sup></a>, formal system power hierarchy<a href="#fn37" class="footnote-ref" id="fnref37"><sup>37</sup></a>, and so on. They are related to each other. We want to find out which feature gives which power.</p>
<p>What is the difference between descriptive complexity theory and implicit complexity theory<a href="#fn38" class="footnote-ref" id="fnref38"><sup>38</sup></a>?</p>
<h2 id="computer-science-is-what"><span class="section_number">6</span><span class="section_title">Computer science is what?</span></h2>
<p>Rapaport 2005 <span class="citation" data-cites="rapaport2005philosophy">[<a href="#ref-rapaport2005philosophy">12</a>]</span> surveys various definitions and their problems. It summarizes the discussion in page 154 (3.15.4 Conclusion).</p>
<p>Computer science<a href="#fn39" class="footnote-ref" id="fnref39"><sup>39</sup></a> is not science (the application of the scientific method to make falsifiable theories).</p>
<p>Scott Schneider defines &quot;computer science&quot; as &quot;everything to do with computation, both in the abstract and in the implementation&quot;.<a href="#fn40" class="footnote-ref" id="fnref40"><sup>40</sup></a></p>
<p>Is CS a branch of math?<a href="#fn41" class="footnote-ref" id="fnref41"><sup>41</sup></a></p>
<p>If science is a Latinate synonym of the Germanic &quot;knowledge&quot;, then computer science is a synonym of &quot;computer knowledge&quot;.</p>
<h2 id="the-mathematics-part"><span class="section_number">7</span><span class="section_title">The mathematics part</span></h2>
<p>There are many computation models<a href="#fn42" class="footnote-ref" id="fnref42"><sup>42</sup></a>. All of them imply some <em>operating conditions</em>: there are no electrical disruptions, fires, cosmic rays, and so on. All of them also imply a sequence of operations.</p>
<p>We often assume that the computation model is a Turing machine. But, ontologically, a Turing machine is a computation model, not a machine, and thus should be called a Turing model.</p>
<p>A <em>computation model</em> is a formal system that represents the relevant aspects of the internal states of a computing machine.</p>
<p>Now we define &quot;to compute the function <span class="math inline">\(f : D \to C\)</span>&quot; with respect to the computation model <span class="math inline">\((D,C,S,d,c,t)\)</span> where <span class="math inline">\(d : D \to S\)</span>, and <span class="math inline">\(c : C \to S\)</span>, and <span class="math inline">\(t\)</span> has arity <span class="math inline">\((S,S)\)</span>. The computation model is a three-sorted structure. The functions <span class="math inline">\(d\)</span> and <span class="math inline">\(c\)</span> together bridge two things: (1) our high-level thought of the machine computes, and (2) the logical system that abstracts the machine's internal state and computation. Let <span class="math inline">\(S\)</span> be the computation model's domain of discourse, that is, the set of each mathematical object that is a simplified representation of a machine internal state. Let <span class="math inline">\(t\)</span> be a relation symbol of arity 2. The relation <span class="math inline">\(t\)</span> represents the state transition relation. Define the transitive closure of <span class="math inline">\(t\)</span> as <span class="math inline">\(T(x,y) = (TC(t))(x,y) = t(x,y) \vee \exists z (t(x,z) \wedge T(z,y))\)</span> where <span class="math inline">\(TC\)</span> is the transitive-closure operator.</p>
<p>Machine <span class="math inline">\(M\)</span> computes function <span class="math inline">\(f : D \to C\)</span> according to computation model <span class="math inline">\((D,C,S,d,c,t)\)</span> iff <span class="math display">\[
compute(M,f) = \forall x : T(d(x), c(f(x)))
\]</span></p>
<p>We can focus on the computation model, and focus on the substructure <span class="math inline">\((S,t)\)</span> instead.</p>
<p>A machine <em>computes</em> the function <span class="math inline">\(f : D \to C\)</span> according to the computation model <span class="math inline">\((S,c,d,t)\)</span>, iff, for all <span class="math inline">\(x \in D\)</span>, it is true that <span class="math inline">\(T(d(x),c(f(x)))\)</span>, that is, the machine starts at state <span class="math inline">\(d(x)\)</span> and finishes at state <span class="math inline">\(c(f(x))\)</span>.</p>
<p>A <em>computation model</em> is a logical system that has a domain of discourse representing machine internal state, and has an arity-2 relation symbol <span class="math inline">\(t\)</span> representing the state transition relation.</p>
<p>TODO <span class="citation" data-cites="vardi1998computational">[<a href="#ref-vardi1998computational">16</a>]</span></p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">7.1</span><span class="section_title"><a href="#encoding-scheme">Encoding scheme</a></span><span class="word_count">(80w~1m)</span></li>
<li><span class="section_number">7.2</span><span class="section_title"><a href="#computable-algorithm-finite-description">Computable, algorithm, finite description</a></span><span class="word_count">(49w~1m)</span></li>
<li><span class="section_number">7.3</span><span class="section_title"><a href="#is-computation-inherently-sequential-computation-as-sequence-of-steps">Is computation inherently sequential? Computation as sequence of steps</a></span><span class="word_count">(75w~1m)</span></li>
<li><span class="section_number">7.4</span><span class="section_title"><a href="#logic-model">Logic, model</a></span><span class="word_count">(3w~1m)</span></li>
<li><span class="section_number">7.5</span><span class="section_title"><a href="#problem-formula-input-output-model-relation">Problem, formula, input, output, model, relation</a></span><span class="word_count">(247w~2m)</span></li>
<li><span class="section_number">7.6</span><span class="section_title"><a href="#complexity">Complexity</a></span><span class="word_count">(213w~2m)</span></li>
<li><span class="section_number">7.7</span><span class="section_title"><a href="#problem-reduction">Problem, reduction</a></span><span class="word_count">(10w~1m)</span></li>
<li><span class="section_number">7.8</span><span class="section_title"><a href="#digressions">Digressions</a></span><span class="word_count">(59w~1m)</span></li>
<li><span class="section_number">7.9</span><span class="section_title"><a href="#encoding-affects-complexity">Encoding affects complexity</a></span><span class="word_count">(114w~1m)</span></li>
<li><span class="section_number">7.10</span><span class="section_title"><a href="#what-makes-an-encoding-reasonable">What makes an encoding reasonable?</a></span><span class="word_count">(26w~1m)</span></li>
<li><span class="section_number">7.11</span><span class="section_title"><a href="#rant-the-sad-state-of-computational-complexity-texts">Rant: The sad state of computational complexity texts?</a></span><span class="word_count">(46w~1m)</span></li>
</ul>
</div>
<h3 id="encoding-scheme"><span class="section_number">7.1</span><span class="section_title">Encoding scheme</span></h3>
<p>Now we define encoding.</p>
<p>An encoding is a representation of something. A representation is not the represented, but a representation behaves in the way the represented does. Formally, an <em>encoding scheme</em> is a computable bijective function <span class="math inline">\(e : D \to A^*\)</span> where <span class="math inline">\(A\)</span> is an alphabet. Thus, an encoding scheme is an <em>algorithm</em> that describes a bijective function.</p>
<p>If &quot;algorithm&quot; and &quot;encoding scheme&quot; depend on each other, then there is only one logical conclusion: <em>Algorithm and encoding-scheme are the same thing.</em></p>
<h3 id="computable-algorithm-finite-description"><span class="section_number">7.2</span><span class="section_title">Computable, algorithm, finite description</span></h3>
<p>Function <span class="math inline">\(f\)</span> is <em>computable</em> by formal system <span class="math inline">\(S\)</span> iff <span class="math inline">\(S\)</span> has a <em>finite description</em> of <span class="math inline">\(f\)</span>.</p>
<p>An <em>algorithm</em> solves a <em>problem</em>. A problem can be solved by many algorithms with different resource usage characteristics.</p>
<p>An algorithm is a finite description of what a machine is supposed to do.</p>
<h3 id="is-computation-inherently-sequential-computation-as-sequence-of-steps"><span class="section_number">7.3</span><span class="section_title">Is computation inherently sequential? Computation as sequence of steps</span></h3>
<p>In a Turing machine, a step is a state transition that consists of reading the tape cell, writing the tape cell, moving the tape head, and changing the internal state. In <span class="math inline">\(\lambda\)</span>-calculus, a step is a <span class="math inline">\(\beta\)</span>-reduction of an expression composed from more primitive subexpressions. These examples suggest that we can define computation as a <em>sequence</em> of steps.</p>
<p>Each of those models is a special case of deciders.</p>
<h3 id="logic-model"><span class="section_number">7.4</span><span class="section_title">Logic, model</span></h3>
<p>See <a href="logic.html">file:logic.html</a>.</p>
<h3 id="problem-formula-input-output-model-relation"><span class="section_number">7.5</span><span class="section_title">Problem, formula, input, output, model, relation</span></h3>
<p>&quot;Problem&quot; comes from Greek &quot;problema&quot; which means &quot;a task, that which is proposed, a question&quot;.<a href="#fn43" class="footnote-ref" id="fnref43"><sup>43</sup></a> Therefore, a problem <em>is</em> a question, or, formally, a <em>logical formula</em>.</p>
<p><em>A problem is a formula.</em> For example, the problem &quot;Given an <span class="math inline">\(x\)</span>, what is <span class="math inline">\(x+x\)</span>?&quot; is the formula <span class="math inline">\( x+x = y \)</span> in first-order logic with equality and some arithmetics. Note that some logic is embedded in English.<a href="#fn44" class="footnote-ref" id="fnref44"><sup>44</sup></a>.</p>
<table>
<caption>Some common problem shapes</caption>
<thead>
<tr class="header">
<th>name</th>
<th>shape</th>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>decision problem</td>
<td><span class="math inline">\( p(x) \)</span></td>
<td><span class="math inline">\(x\)</span></td>
<td></td>
</tr>
<tr class="even">
<td>search problem</td>
<td><span class="math inline">\( p(x) \)</span></td>
<td></td>
<td><span class="math inline">\(x\)</span></td>
</tr>
<tr class="odd">
<td>function problem</td>
<td><span class="math inline">\( f(x) = y \)</span></td>
<td><span class="math inline">\(x\)</span></td>
<td><span class="math inline">\(y\)</span></td>
</tr>
</tbody>
</table>
<p>A problem may have <em>inputs</em> and <em>outputs</em>. An <em>input</em> of a problem is a free variable in the formula. An <em>output</em> of a problem is a free variable in the formula.</p>
<p>Another example: the problem &quot;Is the sum of two even numbers even?&quot; is the formula <span class="math inline">\( E(x) \wedge E(y) \to E(x+y) \)</span>.</p>
<p>What does it mean to solve a problem (answer a question)? Solving a problem is answering a question. Answering a question corresponds to <em>proving a formula</em>. Answering a question corresponds to <em>finding a model</em> of a formula?</p>
<p>A <em>problem</em> may be <em>modeled</em> by a <em>relation</em> between questions and answers. For example, the problem <span class="math inline">\( \forall x \exists y : x+x = y \)</span> is modeled by the relation <span class="math inline">\( \{ (0,0), (1,2), (2,4), \ldots \} \)</span> and is also modeled by the relation <span class="math inline">\( \{ (\epsilon,\epsilon), (1,11), (11,1111), \ldots \} \)</span>.</p>
<p>Do not conflate a problem and a model of it. A problem is a formula, <em>not</em> a relation.</p>
<p>Compare various definitions of &quot;problem&quot;<a href="#fn45" class="footnote-ref" id="fnref45"><sup>45</sup></a><a href="#fn46" class="footnote-ref" id="fnref46"><sup>46</sup></a>.</p>
<p>A problem is <span class="citation" data-cites="sep-computational-complexity">[<a href="#ref-sep-computational-complexity">3</a>]</span></p>
<p>Problem can be <em>composed</em> as formulas can be composed.</p>
<h3 id="complexity"><span class="section_number">7.6</span><span class="section_title">Complexity</span></h3>
<p>The worst-case time complexity<a href="#fn47" class="footnote-ref" id="fnref47"><sup>47</sup></a> of machine <span class="math inline">\(m\)</span> for input <span class="math inline">\(x\)</span> is <span class="math inline">\(t(m,x)\)</span>, the number of steps <span class="math inline">\(m\)</span> makes between the beginning and the halting. The <em>worst-case time complexity</em> of <span class="math inline">\(m\)</span> for input <em>size</em> <span class="math inline">\(n\)</span> is <span class="math inline">\(T(m,n) = \left\vert \max_{|x| = n} t(m,x) \right\vert\)</span>. We can also write asymptotic statements such as <span class="math inline">\(T(m,n) \in O(f(n))\)</span>.</p>
<p>An algorithm implies a machine.</p>
<p>The complexity class of a problem is the worst-case time complexity of the most efficient algorithm solving that problem.</p>
<p>A <em>machine</em> <span class="math inline">\(M\)</span> is a <em>transition relation</em> <span class="math inline">\(T\)</span> (an <em>acyclic</em> binary relation). <span class="math display">\[
T(x,y) = \text{\(M\) can state-transition from \(x\) to \(y\).}
\]</span></p>
<p><span class="math inline">\(M\)</span> <em>computes</em> <span class="math inline">\(P\)</span> iff a subgraph of the shortcut of <span class="math inline">\(T\)</span> is isomorphic to <span class="math inline">\(P\)</span>. (If <span class="math inline">\(T\)</span> were cyclic, this definition would fail.)</p>
<p>Related: <a href="https://en.wikipedia.org/wiki/Graph_isomorphism">graph isomorphism</a>, <a href="https://en.wikipedia.org/wiki/Subgraph_isomorphism_problem">subgraph isomorphism problem</a>.</p>
<p><em>Deterministic</em> machine equals <em>functional</em> relation.</p>
<p><span class="math inline">\(G\)</span> <em>accepts</em> <span class="math inline">\(v\)</span> iff <span class="math inline">\(F^\infty(\{v\}) = \emptyset\)</span> where <span class="math inline">\(F\)</span> is the graph's fringe function. The <em>language</em> recognized by <span class="math inline">\(G\)</span> is the largest <span class="math inline">\(L \subseteq V\)</span> such that <span class="math inline">\(F^\infty(L) = \emptyset\)</span>.</p>
<p>A Turing machine is <span class="math inline">\((C,I,f)\)</span> where <span class="math inline">\(C\)</span> is countable and <span class="math inline">\(f\)</span> is recursive.</p>
<p><a href="https://en.wikipedia.org/wiki/Register_machine">https://en.wikipedia.org/wiki/Register_machine</a></p>
<p>Example: a state of a Turing machine is <span class="math inline">\((c,l,h,r)\)</span> where <span class="math inline">\(c\)</span> is a configuration, <span class="math inline">\(l\)</span> is the tape content to the left of the head, <span class="math inline">\(h\)</span> is the tape content at the head, and <span class="math inline">\(r\)</span> is the tape content to the right of the head.</p>
<h3 id="problem-reduction"><span class="section_number">7.7</span><span class="section_title">Problem, reduction</span></h3>
<p>Sometimes we can <em>reduce</em> a problem into another problem?</p>
<h3 id="digressions"><span class="section_number">7.8</span><span class="section_title">Digressions</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">7.8.1</span><span class="section_title"><a href="#pullback">Pullback</a></span><span class="word_count">(46w~1m)</span></li>
<li><span class="section_number">7.8.2</span><span class="section_title"><a href="#cheating">Cheating</a></span><span class="word_count">(14w~1m)</span></li>
</ul>
</div>
<h4 id="pullback"><span class="section_number">7.8.1</span><span class="section_title">Pullback</span></h4>
<p>We can model the apparent function computed by the machine as <span class="math inline">\(g : A^* \to A^*\)</span> where <span class="math inline">\(g(e(x)) = e(f(x))\)</span>. We then do some algebraic manipulation:</p>
<span class="math display">\[\begin{align*}
\\ g(e(x)) &amp;= e(f(x))
\\ (g \circ e)(x) &amp;= (e \circ f)(x)
\\ g \circ e &amp;\equiv e \circ f
\end{align*}
\]</span>
<p>An equation of the shape <span class="math inline">\(g \circ e \equiv e \circ f\)</span> is a special case of pullbacks<a href="#fn48" class="footnote-ref" id="fnref48"><sup>48</sup></a> in category theory.</p>
<h4 id="cheating"><span class="section_number">7.8.2</span><span class="section_title">Cheating</span></h4>
<p>&quot;Cheating&quot; with an unreasonable encoding is a common error in P vs NP &quot;proofs&quot;.</p>
<h3 id="encoding-affects-complexity"><span class="section_number">7.9</span><span class="section_title">Encoding affects complexity</span></h3>
<p>Encoding a natural number <span class="math inline">\(n\)</span> in unary notation takes <span class="math inline">\(n\)</span> symbols. Encoding the same number in binary notation takes approximately <span class="math inline">\(\log_2(n)\)</span> symbols.</p>
<p>Adding two natural numbers <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> takes <span class="math inline">\(m+n\)</span> steps in unary notation, but only approximately <span class="math inline">\(\log(\max(m,n))\)</span> steps in positional notation.</p>
<p>Why don't encode a number as its prime factorization, to simplify multiplication while complicating addition?</p>
<p>What do we formally mean by &quot;reasonable encoding&quot;?</p>
<p>Why do we assume that numbers are encoded in positional notation<a href="#fn49" class="footnote-ref" id="fnref49"><sup>49</sup></a>, not unary notation<a href="#fn50" class="footnote-ref" id="fnref50"><sup>50</sup></a>?</p>
<p>My guess: What we mean by reasonable encoding is an <em>order-preserving homomorphism</em>:</p>
<span class="math display">\[\begin{align*}
a &lt; b &amp;\iff e(a) &lt;_e e(b)
\\
a = b &amp;\iff e(a) = e(b)
\end{align*}
\]</span>
<p>A homomorphism preserves structure. But which structure?</p>
<p>We may encode the natural numbers as the bitwise-negation of the base-2 representation: 1, 0, 11, 10, 01, 00, etc.</p>
<h3 id="what-makes-an-encoding-reasonable"><span class="section_number">7.10</span><span class="section_title">What makes an encoding reasonable?</span></h3>
<p>A <em>reasonable encoding</em> is an encoding that is easy to compute and is easy to invert.</p>
<p>A reasonable encoding has a finite description.</p>
<h3 id="rant-the-sad-state-of-computational-complexity-texts"><span class="section_number">7.11</span><span class="section_title">Rant: The sad state of computational complexity texts?</span></h3>
<p>It is philosophically appaling that most computational complexity texts readily show what a problem is <em>represented</em> as, but never clearly and <em>formally define</em> what a problem <em>is</em>. It is appaling that they spend hundreds of pages discussing something undefined.</p>
<h2 id="digressions-1"><span class="section_number">8</span><span class="section_title">Digressions</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">8.1</span><span class="section_title"><a href="#the-suffix--er-works-with-all-verbs-except-modals">The suffix -er works with all verbs except modals</a></span><span class="word_count">(198w~1m)</span></li>
<li><span class="section_number">8.2</span><span class="section_title"><a href="#the-suffix--ion-expects-latinate-verbs">The suffix -ion expects Latinate verbs</a></span><span class="word_count">(146w~1m)</span></li>
<li><span class="section_number">8.3</span><span class="section_title"><a href="#genus-differentia-definition-of-computation">Genus-differentia definition of computation?</a></span><span class="word_count">(30w~1m)</span></li>
<li><span class="section_number">8.4</span><span class="section_title"><a href="#computation-as-information-transformation">Computation as information transformation</a></span><span class="word_count">(25w~1m)</span></li>
<li><span class="section_number">8.5</span><span class="section_title"><a href="#computation-as-modelconcretion">Computation as model/concretion?</a></span><span class="word_count">(24w~1m)</span></li>
<li><span class="section_number">8.6</span><span class="section_title"><a href="#diving-into-philosophy-of-computation">Diving into philosophy of computation</a></span><span class="word_count">(13w~1m)</span></li>
<li><span class="section_number">8.7</span><span class="section_title"><a href="#a-machine-is-what">A machine is what?</a></span><span class="word_count">(49w~1m)</span></li>
<li><span class="section_number">8.8</span><span class="section_title"><a href="#even-more-historical">Even more historical?</a></span><span class="word_count">(21w~1m)</span></li>
<li><span class="section_number">8.9</span><span class="section_title"><a href="#the-difference-between-analog-and-digital-is-what">The difference between analog and digital is what?</a></span><span class="word_count">(137w~1m)</span></li>
<li><span class="section_number">8.10</span><span class="section_title"><a href="#machine-automaton-robot-are-what">Machine, automaton, robot are what?</a></span><span class="word_count">(107w~1m)</span></li>
<li><span class="section_number">8.11</span><span class="section_title"><a href="#the-implicit-agency-of--er-might-have-impelled-us-to-invent-god">The implicit agency of -er might have impelled us to invent God</a></span><span class="word_count">(278w~2m)</span></li>
<li><span class="section_number">8.12</span><span class="section_title"><a href="#god-in-cantors-paradise-is-whatwhere">God in Cantor's paradise is what/where?</a></span><span class="word_count">(30w~1m)</span></li>
<li><span class="section_number">8.13</span><span class="section_title"><a href="#computation-and-reckoning-are-the-same">Computation and reckoning are the same?</a></span><span class="word_count">(334w~2m)</span></li>
</ul>
</div>
<h3 id="the-suffix--er-works-with-all-verbs-except-modals"><span class="section_number">8.1</span><span class="section_title">The suffix -er works with all verbs except modals</span></h3>
<p>The suffix -er works with both both <a href="https://en.wikipedia.org/wiki/List_of_Germanic_and_Latinate_equivalents_in_English">Germanic and Latinate</a> verbs. For example, a (Germanic) reckoner is one who reckons, and a (Latinate) computer is one who computes.</p>
<p>The suffix -er works with <a href="https://en.wikipedia.org/wiki/Neologism">neologisms</a>. Once we accept that V is a verb, we readily accept that Ver is a noun that means one who does V. For example, after we have accepted that &quot;google&quot; is a verb, we readily accept that a &quot;googler&quot; is one who &quot;googles&quot;. Conversely, once we have accepted that Ver is a noun, we readily accept that V is a verb that is done by a Ver. For example, &quot;burgle&quot; is backformed from &quot;burglar&quot;.<a href="#fn51" class="footnote-ref" id="fnref51"><sup>51</sup></a></p>
<p>The suffix -er sometimes works as a backforming &quot;anti-suffix&quot;: we can sometimes form a verb V from a noun Ver by <em>removing</em> the -er. For example, it is easy to imagine backforming &quot;cadave&quot; from &quot;cadaver&quot;, and it is not hard to imagine that &quot;to cadave&quot; means &quot;to be a dead body&quot; or &quot;to behave like a dead body&quot;.</p>
<p>Indeed the suffix -er seems to works with all verbs except modals (may, might, can, could, shall, should). Hence we say that the suffix -er is <a href="https://en.wikipedia.org/wiki/Productivity_(linguistics)">productive</a>.</p>
<h3 id="the-suffix--ion-expects-latinate-verbs"><span class="section_number">8.2</span><span class="section_title">The suffix -ion expects Latinate verbs</span></h3>
<p>Germanic verbs take -ing instead of -ion. Example: Germanic &quot;eat&quot; and Latinate &quot;manducate&quot;<a href="#fn52" class="footnote-ref" id="fnref52"><sup>52</sup></a>, and Germanic &quot;eating&quot; and Latinate &quot;manducation&quot;<a href="#fn53" class="footnote-ref" id="fnref53"><sup>53</sup></a>. Thus, in this case, Germanic -ing is Latinate -ion.</p>
<p>I think generally Latin -re → English -te → -tion.</p>
<p>This is not how those words were actually historically imported, but we can think of these words this way.</p>
<p>manducare → manducate<a href="#fn54" class="footnote-ref" id="fnref54"><sup>54</sup></a> → manducation</p>
<p>computare → computate<a href="#fn55" class="footnote-ref" id="fnref55"><sup>55</sup></a><a href="#fn56" class="footnote-ref" id="fnref56"><sup>56</sup></a> → computation</p>
<p>renovare → renovate<a href="#fn57" class="footnote-ref" id="fnref57"><sup>57</sup></a> → renovation</p>
<p>It seems that the historical path was longer: Latin infinitive → first-person singular present subjective → past participle → nominalization -ionem / -ionis → English drops -em / -is → backform -ation to -ate.</p>
<p>Latin gestare → gesto → gestatio → English gestation → gestate</p>
<p>Letin renovare → renovo → renovation → English renovation → renovate</p>
<p>Latin computare → computo → computatio → English computation → computate</p>
<p>formare → formo → formatio → formation</p>
<p>English is a mess of <a href="https://en.wikipedia.org/wiki/Doublet_(linguistics)">doublets</a>.</p>
<h3 id="genus-differentia-definition-of-computation"><span class="section_number">8.3</span><span class="section_title">Genus-differentia definition of computation?</span></h3>
<p>A computation is (what) that (what)?</p>
<p>Process? Activity? Mechanism?</p>
<p>A program describes the computation performed by a machine. A program modulates the machine. Manipulates computational resources to compute something.</p>
<h3 id="computation-as-information-transformation"><span class="section_number">8.4</span><span class="section_title">Computation as information transformation</span></h3>
<p>Computation is answering a question.</p>
<p>What is the relationship between computation and answering questions?</p>
<p>A computer reduces information? Transforms information?</p>
<p>Computation is transformation of information?</p>
<h3 id="computation-as-modelconcretion"><span class="section_number">8.5</span><span class="section_title">Computation as model/concretion?</span></h3>
<p>Computation is running a program on a machine.</p>
<p>It seems that the defining feature of computation is conditional and repetition.</p>
<p>Program is a model.</p>
<h3 id="diving-into-philosophy-of-computation"><span class="section_number">8.6</span><span class="section_title">Diving into philosophy of computation</span></h3>
<p>Ian Horswill wrote an introductory article &quot;What is computation?&quot;<a href="#fn58" class="footnote-ref" id="fnref58"><sup>58</sup></a>.</p>
<h3 id="a-machine-is-what"><span class="section_number">8.7</span><span class="section_title">A machine is what?</span></h3>
<p>A <em>machine</em> is a tool that <em>computes</em> what the machine is designed for. A machine has material existence. It is a physical implement.</p>
<p>Digression: In <a href="philo.html">file:philo.html</a>, I write that a machine is a tool, that is something that we use to extend our self (what we control).</p>
<h3 id="even-more-historical"><span class="section_number">8.8</span><span class="section_title">Even more historical?</span></h3>
<p>Leibniz used the term &quot;calculation&quot;? Turing used &quot;effective calculability&quot; to mean &quot;algorithmic&quot;? Computation is calculation? It's just following rules?</p>
<h3 id="the-difference-between-analog-and-digital-is-what"><span class="section_number">8.9</span><span class="section_title">The difference between analog and digital is what?</span></h3>
<p>Both analog and digital computers are made with transistors, but analog computers operate the transistors outside the saturated region, whereas digital computers operate the transistors in the saturated region. Analog to digital is knob to switch, that is, continuous to discrete. Analog computers use transistors as amplifiers. Digital computers use transistors as switches.</p>
<p>What does digital do better than analog? Temperature affects analog computers more than it affects digital computers. Digital signals are more immune to noises. Digital computers have a wider operating temperature range.</p>
<p>What does analog do better than digital? Analog computers degrade gracefully: computation gradually gets more and more wrong as the computer goes out of its designed operating conditions. Digital computers degrade abruptly: computation suddenly gets chaotic as the computer approaches a limit of its designed operating conditions.</p>
<h3 id="machine-automaton-robot-are-what"><span class="section_number">8.10</span><span class="section_title">Machine, automaton, robot are what?</span></h3>
<p>In 1540, a <em>machine</em> is any structure or device.<a href="#fn59" class="footnote-ref" id="fnref59"><sup>59</sup></a> The word &quot;machine&quot; may have come from a Proto-Indo-European word that means &quot;that which enables&quot;.<a href="#fn60" class="footnote-ref" id="fnref60"><sup>60</sup></a> Some machines are <em>programmable</em>. Such machine implements several functions that can be chosen by a <em>program</em> which is a part of the machine's input. The program chooses which function the machine shall compute.</p>
<p>In 1610, an <em>automaton</em> is a self-acting machine.<a href="#fn61" class="footnote-ref" id="fnref61"><sup>61</sup></a> Thus an automaton has an energy source or is connected to an energy source that enables the automaton to run with minimal human intervention.</p>
<p>In 1923, the English word &quot;robot&quot; came from the Czech word &quot;robotnik&quot; that means &quot;forced worker&quot;.<a href="#fn62" class="footnote-ref" id="fnref62"><sup>62</sup></a></p>
<h3 id="the-implicit-agency-of--er-might-have-impelled-us-to-invent-god"><span class="section_number">8.11</span><span class="section_title">The implicit agency of -er might have impelled us to invent God</span></h3>
<p>Why is -er so productive? Because every sentence that has verb can always have a subject. Because it is always possible, if not necessary, for a verb to have a doer. Because every action has an agent, because everything happens because an agent does it, perhaps this is a tacit fundamental assumption of our logic, or perhaps this reflects how the Universe works? Our language implies that the subject causes the action or outcome described by the verb? A Ver is one who Vs, that is, one who <em>causes</em> a Ving to be done, and thus there is an implicit agency in each Ver. Recall that an agency is an ability to cause.</p>
<p>There is a problem: if we assume that, then the sentence &quot;X exists&quot; implies that X causes its own existence, but it seems problematic for something to cause itself<a href="#fn63" class="footnote-ref" id="fnref63"><sup>63</sup></a>? Did we invent God because we impose, through our languages, that everything has a cause, that every verb has a doer? We invented God because we have evolved to crave explanations for everything, because craving for explanations promote survival? We want to explain everything, but our finiteness precludes us from explaining everything.</p>
<p>It is curious that Christians call Jesus &quot;Word (logos) of God&quot;<a href="#fn64" class="footnote-ref" id="fnref64"><sup>64</sup></a><a href="#fn65" class="footnote-ref" id="fnref65"><sup>65</sup></a>, and the Greek word &quot;logos&quot; also begets the English word &quot;logic&quot;.</p>
<p>Spreading religion requires language, unless our ancestors were telepathic.</p>
<p>Aren't we rambling too much? We are merely trying to define &quot;compute&quot;, which requires us to traverse linguistics, and somehow we arrived at theology? It is trivial to get lost in philosophy, as each question readily begets more questions. How do we find the way out?</p>
<h3 id="god-in-cantors-paradise-is-whatwhere"><span class="section_number">8.12</span><span class="section_title">God in Cantor's paradise is what/where?</span></h3>
<p>If a god resides in a paradise, and Cantor has made us a paradise<a href="#fn66" class="footnote-ref" id="fnref66"><sup>66</sup></a> (according to Hilbert), then what/where is the god in Cantor's paradise?</p>
<h3 id="computation-and-reckoning-are-the-same"><span class="section_number">8.13</span><span class="section_title">Computation and reckoning are the same?</span></h3>
<p>The Germanic English of &quot;compute&quot; is &quot;reckon&quot; (German rechnen, Dutch rekenen). Thus computation is reckoning.</p>
<div id="refs" class="references">
<div id="ref-Arora2009">
<p>[1] Arora, S. and Barak, B. 2009. <em>Computational complexity: A modern approach</em>. Cambridge University Press.</p>
</div>
<div id="ref-Boolos2002">
<p>[2] Boolos, G.S. et al. 2002. <em>Computability and logic</em>. Cambridge University Press.</p>
</div>
<div id="ref-sep-computational-complexity">
<p>[3] Dean, W. 2016. Computational complexity theory. <em>The stanford encyclopedia of philosophy</em>. E.N. Zalta, ed. <a href="https://plato.stanford.edu/archives/win2016/entries/computational-complexity/">https://plato.stanford.edu/archives/win2016/entries/computational-complexity/</a>; Metaphysics Research Lab, Stanford University. url: &lt;<a href="https://plato.stanford.edu/archives/win2016/entries/computational-complexity/">https://plato.stanford.edu/archives/win2016/entries/computational-complexity/</a>&gt;.</p>
</div>
<div id="ref-gurevich2012foundational">
<p>[4] Gurevich, Y. 2012. Foundational analyses of computation. <em>Conference on computability in europe</em> (2012), 264–275. url: &lt;<a href="https://pdfs.semanticscholar.org/d444/921db6240f656390c6e9114d53756fd20494.pdf">https://pdfs.semanticscholar.org/d444/921db6240f656390c6e9114d53756fd20494.pdf</a>&gt;.</p>
</div>
<div id="ref-gurevich2011algorithm">
<p>[5] Gurevich, Y. 2011. <em>What is an algorithm</em>. Technical Report. Microsoft Research, Redmond, WA. url: &lt;<a href="https://pdfs.semanticscholar.org/762f/178c7983d7431d04919453c043760d691366.pdf">https://pdfs.semanticscholar.org/762f/178c7983d7431d04919453c043760d691366.pdf</a>&gt;.</p>
</div>
<div id="ref-hamm2013formal">
<p>[6] Hamm, F. et al. 2013. <em>Formal foundations for semantic theories of nominalisation</em>. Universitätsbibliothek Johann Christian Senckenberg. url: &lt;<a href="http://www.phil.uu.nl/ozsl/articles/Lambalgen05.pdf">http://www.phil.uu.nl/ozsl/articles/Lambalgen05.pdf</a>&gt;.</p>
</div>
<div id="ref-Immerman99descriptivecomplexity">
<p>[7] Immerman, N. 1999. Descriptive complexity.</p>
</div>
<div id="ref-Rogers1987">
<p>[8] Jr., H.R. 1987. <em>Theory of recursive functions and effective computability</em>. MIT Press.</p>
</div>
<div id="ref-Marek2009">
<p>[9] Marek, V.W. and Remmel, J.B. 2009. The complexity of recursive constraint satisfaction problems. <em>Annals of Pure and Applied Logic</em>. 161, 3 (2009), 447–457. DOI:<a href="https://doi.org/http://dx.doi.org/10.1016/j.apal.2009.07.005">https://doi.org/http://dx.doi.org/10.1016/j.apal.2009.07.005</a>. url: &lt;<a href="http://www.sciencedirect.com/science/article/pii/S0168007209001523">http://www.sciencedirect.com/science/article/pii/S0168007209001523</a>&gt;.</p>
</div>
<div id="ref-moschovakis2001algorithm">
<p>[10] Moschovakis, Y.N. 2001. What is an algorithm? <em>Mathematics unlimited—2001 and beyond</em>. Springer. 919–936. url: &lt;<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.7.5576&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.7.5576&amp;rep=rep1&amp;type=pdf</a>&gt;.</p>
</div>
<div id="ref-sep-computation-physicalsystems">
<p>[11] Piccinini, G. 2017. Computation in physical systems. <em>The stanford encyclopedia of philosophy</em>. E.N. Zalta, ed. <a href="https://plato.stanford.edu/archives/sum2017/entries/computation-physicalsystems/">https://plato.stanford.edu/archives/sum2017/entries/computation-physicalsystems/</a>; Metaphysics Research Lab, Stanford University. url: &lt;<a href="https://plato.stanford.edu/archives/sum2017/entries/computation-physicalsystems/">https://plato.stanford.edu/archives/sum2017/entries/computation-physicalsystems/</a>&gt;.</p>
</div>
<div id="ref-rapaport2005philosophy">
<p>[12] Rapaport, W.J. 2005. Philosophy of computer science: An introductory course. <em>Teaching Philosophy</em>. 28, 4 (2005), 319–341. url: &lt;<a href="https://cse.buffalo.edu/~rapaport/Papers/phics.pdf">https://cse.buffalo.edu/~rapaport/Papers/phics.pdf</a>&gt;.</p>
</div>
<div id="ref-sep-abstract-objects">
<p>[13] Rosen, G. 2017. Abstract objects. <em>The stanford encyclopedia of philosophy</em>. E.N. Zalta, ed. <a href="https://plato.stanford.edu/archives/sum2017/entries/abstract-objects/">https://plato.stanford.edu/archives/sum2017/entries/abstract-objects/</a>; Metaphysics Research Lab, Stanford University. url: &lt;<a href="https://plato.stanford.edu/archives/sum2017/entries/abstract-objects/">https://plato.stanford.edu/archives/sum2017/entries/abstract-objects/</a>&gt;.</p>
</div>
<div id="ref-scheutz2006computation">
<p>[14] Scheutz, M. 2006. Computation, philosophical issues about. <em>The Encyclopedia of Cognitive Science</em>. (2006). url: &lt;<a href="https://pdfs.semanticscholar.org/5a83/113ac2d781ea672f42a77de28ba23a127c1d.pdf">https://pdfs.semanticscholar.org/5a83/113ac2d781ea672f42a77de28ba23a127c1d.pdf</a>&gt;.</p>
</div>
<div id="ref-turing1937computable">
<p>[15] Turing, A.M. 1937. On computable numbers, with an application to the entscheidungsproblem. <em>Proceedings of the London mathematical society</em>. 2, 1 (1937), 230–265. url: &lt;<a href="https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf">https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf</a>&gt;.</p>
</div>
<div id="ref-vardi1998computational">
<p>[16] Vardi, M.Y. 1998. Computational model theory: An overview. <em>Logic Journal of the IGPL</em>. 6, 4 (1998), 601–624. url: &lt;<a href="https://www.cs.rice.edu/~vardi/papers/wollic97-igpl.pdf">https://www.cs.rice.edu/~vardi/papers/wollic97-igpl.pdf</a>&gt;.</p>
</div>
<div id="ref-vardi2012algorithm">
<p>[17] Vardi, M.Y. 2012. What is an algorithm? <em>Communications of the ACM</em>. 55, 3 (2012), 5–5. url: &lt;<a href="https://cacm.acm.org/magazines/2012/3/146261-what-is-an-algorithm/fulltext">https://cacm.acm.org/magazines/2012/3/146261-what-is-an-algorithm/fulltext</a>&gt;.</p>
</div>
<div id="ref-zucchi2013language">
<p>[18] Zucchi, A. 2013. <em>The language of propositions and events: Issues in the syntax and the semantics of nominalization</em>. Springer Science &amp; Business Media.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>one million US dollars <a href="http://www.claymath.org/millennium-problems/millennium-prize-problems">http://www.claymath.org/millennium-problems/millennium-prize-problems</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><a href="https://arxiv.org/abs/0903.2567">https://arxiv.org/abs/0903.2567</a><a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><a href="https://www.um.es/beca/papers/Aviles-Algebras.pdf">https://www.um.es/beca/papers/Aviles-Algebras.pdf</a><a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><a href="https://hiringengineersbook.com/post/trouble-hiring/">https://hiringengineersbook.com/post/trouble-hiring/</a><a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><a href="https://blog.erratasec.com/2018/10/systemd-is-bad-parsing-and-should-feel.html">https://blog.erratasec.com/2018/10/systemd-is-bad-parsing-and-should-feel.html</a><a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><a href="https://www.reddit.com/r/programming/comments/9rtm1f/systemd_is_bad_parsing_and_should_feel_bad/">https://www.reddit.com/r/programming/comments/9rtm1f/systemd_is_bad_parsing_and_should_feel_bad/</a><a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p><a href="https://medium.com/the-spike/brains-as-analog-computers-fa297021f935">https://medium.com/the-spike/brains-as-analog-computers-fa297021f935</a><a href="#fnref7" class="footnote-back">↩</a></p></li>
<li id="fn8"><p><a href="https://www.forbes.com/sites/quora/2016/09/27/is-the-human-brain-analog-or-digital/">https://www.forbes.com/sites/quora/2016/09/27/is-the-human-brain-analog-or-digital/</a><a href="#fnref8" class="footnote-back">↩</a></p></li>
<li id="fn9"><p><a href="https://twitter.com/mekajfire/status/1090689517701349376">https://twitter.com/mekajfire/status/1090689517701349376</a><a href="#fnref9" class="footnote-back">↩</a></p></li>
<li id="fn10"><p><a href="https://en.wikipedia.org/wiki/Nominalization">https://en.wikipedia.org/wiki/Nominalization</a><a href="#fnref10" class="footnote-back">↩</a></p></li>
<li id="fn11"><p><a href="https://www.etymonline.com/word/-ation">https://www.etymonline.com/word/-ation</a><a href="#fnref11" class="footnote-back">↩</a></p></li>
<li id="fn12"><p>Kurzgesagt: What is something?https://www.youtube.com/watch?v=X9otDixAtFw<a href="#fnref12" class="footnote-back">↩</a></p></li>
<li id="fn13"><p><a href="https://en.wikipedia.org/wiki/Operational_amplifier_applications#Summing_amplifier">https://en.wikipedia.org/wiki/Operational_amplifier_applications#Summing_amplifier</a><a href="#fnref13" class="footnote-back">↩</a></p></li>
<li id="fn14"><p>The output is inverted for practical engineering reasons, but it is simple to chain an inverter to the adder's output. <a href="https://electronics.stackexchange.com/questions/268547/inverting-summing-amplifier-vs-non-inverting-summing-amplfier">https://electronics.stackexchange.com/questions/268547/inverting-summing-amplifier-vs-non-inverting-summing-amplfier</a><a href="#fnref14" class="footnote-back">↩</a></p></li>
<li id="fn15"><p><a href="https://en.wikipedia.org/wiki/Adder_(electronics)">https://en.wikipedia.org/wiki/Adder_(electronics)</a><a href="#fnref15" class="footnote-back">↩</a></p></li>
<li id="fn16"><p><a href="https://www.etymonline.com/word/computer">https://www.etymonline.com/word/computer</a><a href="#fnref16" class="footnote-back">↩</a></p></li>
<li id="fn17"><p><a href="https://www.etymonline.com/word/computer">https://www.etymonline.com/word/computer</a><a href="#fnref17" class="footnote-back">↩</a></p></li>
<li id="fn18"><p><a href="https://www.etymonline.com/word/computer">https://www.etymonline.com/word/computer</a><a href="#fnref18" class="footnote-back">↩</a></p></li>
<li id="fn19"><p><a href="https://en.wikipedia.org/wiki/Operational_amplifier">https://en.wikipedia.org/wiki/Operational_amplifier</a><a href="#fnref19" class="footnote-back">↩</a></p></li>
<li id="fn20"><p><a href="https://en.wikipedia.org/wiki/Logic_gate">https://en.wikipedia.org/wiki/Logic_gate</a><a href="#fnref20" class="footnote-back">↩</a></p></li>
<li id="fn21"><p>Some animals can count, and counting is a computation; thus some animals can compute. <a href="http://www.bbc.com/future/story/20121128-animals-that-can-count">http://www.bbc.com/future/story/20121128-animals-that-can-count</a><a href="#fnref21" class="footnote-back">↩</a></p></li>
<li id="fn22"><p><a href="https://en.wikipedia.org/wiki/Interactive_computation">https://en.wikipedia.org/wiki/Interactive_computation</a><a href="#fnref22" class="footnote-back">↩</a></p></li>
<li id="fn23"><p><a href="https://math.stackexchange.com/questions/1561293/must-an-algorithm-terminate">https://math.stackexchange.com/questions/1561293/must-an-algorithm-terminate</a><a href="#fnref23" class="footnote-back">↩</a></p></li>
<li id="fn24"><p>&quot;An example of a non-terminating Turing machine program is a program that calculates sequentially each digit of the decimal representation of pi&quot; <a href="http://www.alanturing.net/turing_archive/pages/reference%20articles/what%20is%20a%20turing%20machine.html">http://www.alanturing.net/turing_archive/pages/reference%20articles/what%20is%20a%20turing%20machine.html</a><a href="#fnref24" class="footnote-back">↩</a></p></li>
<li id="fn25"><p><a href="https://english.stackexchange.com/questions/189974/why-do-they-say-may-not-for-things-which-people-shouldnt-do">https://english.stackexchange.com/questions/189974/why-do-they-say-may-not-for-things-which-people-shouldnt-do</a><a href="#fnref25" class="footnote-back">↩</a></p></li>
<li id="fn26"><p><a href="https://www.etymonline.com/word/algorithm">https://www.etymonline.com/word/algorithm</a><a href="#fnref26" class="footnote-back">↩</a></p></li>
<li id="fn27"><p><a href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi</a><a href="#fnref27" class="footnote-back">↩</a></p></li>
<li id="fn28"><p><a href="https://en.wikipedia.org/wiki/Model_of_computation">https://en.wikipedia.org/wiki/Model_of_computation</a><a href="#fnref28" class="footnote-back">↩</a></p></li>
<li id="fn29"><p><a href="https://en.wikipedia.org/wiki/Computability_logic">https://en.wikipedia.org/wiki/Computability_logic</a><a href="#fnref29" class="footnote-back">↩</a></p></li>
<li id="fn30"><p><a href="http://www.csc.villanova.edu/~japaridz/CL/">http://www.csc.villanova.edu/~japaridz/CL/</a><a href="#fnref30" class="footnote-back">↩</a></p></li>
<li id="fn31"><p><a href="https://en.wikipedia.org/wiki/Theory_of_computation">https://en.wikipedia.org/wiki/Theory_of_computation</a><a href="#fnref31" class="footnote-back">↩</a></p></li>
<li id="fn32"><p><a href="https://siglog.acm.org/about/">https://siglog.acm.org/about/</a><a href="#fnref32" class="footnote-back">↩</a></p></li>
<li id="fn33"><p><a href="http://www.computationalcomplexity.org/">http://www.computationalcomplexity.org/</a><a href="#fnref33" class="footnote-back">↩</a></p></li>
<li id="fn34"><p><a href="https://en.wikipedia.org/wiki/Automata_theory">https://en.wikipedia.org/wiki/Automata_theory</a><a href="#fnref34" class="footnote-back">↩</a></p></li>
<li id="fn35"><p><a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">https://en.wikipedia.org/wiki/Chomsky_hierarchy</a><a href="#fnref35" class="footnote-back">↩</a></p></li>
<li id="fn36"><p><a href="https://en.wikipedia.org/wiki/Arithmetical_hierarchy">https://en.wikipedia.org/wiki/Arithmetical_hierarchy</a><a href="#fnref36" class="footnote-back">↩</a></p></li>
<li id="fn37"><p><a href="https://en.wikipedia.org/wiki/Reverse_mathematics#The_big_five_subsystems_of_second-order_arithmetic">https://en.wikipedia.org/wiki/Reverse_mathematics#The_big_five_subsystems_of_second-order_arithmetic</a><a href="#fnref37" class="footnote-back">↩</a></p></li>
<li id="fn38"><p><a href="http://www.cs.unibo.it/~martini/BISS/martini-1.pdf">http://www.cs.unibo.it/~martini/BISS/martini-1.pdf</a><a href="#fnref38" class="footnote-back">↩</a></p></li>
<li id="fn39"><p><a href="https://en.wikipedia.org/w/index.php?title=Computer_science&amp;oldid=875563283#Etymology">https://en.wikipedia.org/w/index.php?title=Computer_science&amp;oldid=875563283#Etymology</a><a href="#fnref39" class="footnote-back">↩</a></p></li>
<li id="fn40"><p><a href="http://www.scott-a-s.com/cs-is-not-math/">http://www.scott-a-s.com/cs-is-not-math/</a><a href="#fnref40" class="footnote-back">↩</a></p></li>
<li id="fn41"><p><a href="https://math.stackexchange.com/questions/649408/is-computer-science-a-branch-of-mathematics">https://math.stackexchange.com/questions/649408/is-computer-science-a-branch-of-mathematics</a><a href="#fnref41" class="footnote-back">↩</a></p></li>
<li id="fn42"><p><a href="https://en.wikipedia.org/wiki/Model_of_computation">https://en.wikipedia.org/wiki/Model_of_computation</a><a href="#fnref42" class="footnote-back">↩</a></p></li>
<li id="fn43"><p><a href="https://www.etymonline.com/word/problem">https://www.etymonline.com/word/problem</a><a href="#fnref43" class="footnote-back">↩</a></p></li>
<li id="fn44"><p>English is at least second-order, as demonstrated by the Geach–Kaplan sentence &quot;Some critics admire only one another&quot; <a href="https://en.wikipedia.org/wiki/Nonfirstorderizability">https://en.wikipedia.org/wiki/Nonfirstorderizability</a><a href="#fnref44" class="footnote-back">↩</a></p></li>
<li id="fn45"><p><a href="https://en.wikipedia.org/wiki/Computational_complexity_theory">https://en.wikipedia.org/wiki/Computational_complexity_theory</a><a href="#fnref45" class="footnote-back">↩</a></p></li>
<li id="fn46"><p><a href="https://plato.stanford.edu/entries/computational-complexity/">https://plato.stanford.edu/entries/computational-complexity/</a><a href="#fnref46" class="footnote-back">↩</a></p></li>
<li id="fn47"><p><a href="https://en.wikipedia.org/wiki/Worst-case_complexity">https://en.wikipedia.org/wiki/Worst-case_complexity</a><a href="#fnref47" class="footnote-back">↩</a></p></li>
<li id="fn48"><p><a href="https://en.wikipedia.org/wiki/Pullback_(category_theory)">https://en.wikipedia.org/wiki/Pullback_(category_theory)</a><a href="#fnref48" class="footnote-back">↩</a></p></li>
<li id="fn49"><p><a href="https://en.wikipedia.org/wiki/Positional_notation">https://en.wikipedia.org/wiki/Positional_notation</a><a href="#fnref49" class="footnote-back">↩</a></p></li>
<li id="fn50"><p><a href="https://en.wikipedia.org/wiki/Unary_numeral_system">https://en.wikipedia.org/wiki/Unary_numeral_system</a><a href="#fnref50" class="footnote-back">↩</a></p></li>
<li id="fn51"><p><a href="https://en.wiktionary.org/wiki/burgle">https://en.wiktionary.org/wiki/burgle</a><a href="#fnref51" class="footnote-back">↩</a></p></li>
<li id="fn52"><p><a href="https://en.wiktionary.org/wiki/manducate">https://en.wiktionary.org/wiki/manducate</a><a href="#fnref52" class="footnote-back">↩</a></p></li>
<li id="fn53"><p><a href="https://en.wiktionary.org/wiki/manducation">https://en.wiktionary.org/wiki/manducation</a><a href="#fnref53" class="footnote-back">↩</a></p></li>
<li id="fn54"><p><a href="https://en.wiktionary.org/wiki/manducate">https://en.wiktionary.org/wiki/manducate</a><a href="#fnref54" class="footnote-back">↩</a></p></li>
<li id="fn55"><p><a href="https://en.oxforddictionaries.com/definition/computate">https://en.oxforddictionaries.com/definition/computate</a><a href="#fnref55" class="footnote-back">↩</a></p></li>
<li id="fn56"><p><a href="https://en.wiktionary.org/wiki/computate">https://en.wiktionary.org/wiki/computate</a><a href="#fnref56" class="footnote-back">↩</a></p></li>
<li id="fn57"><p><a href="https://en.wiktionary.org/wiki/renovate">https://en.wiktionary.org/wiki/renovate</a><a href="#fnref57" class="footnote-back">↩</a></p></li>
<li id="fn58"><p><a href="http://www.cs.northwestern.edu/~ian/What%20is%20computation.pdf">http://www.cs.northwestern.edu/~ian/What%20is%20computation.pdf</a><a href="#fnref58" class="footnote-back">↩</a></p></li>
<li id="fn59"><p><a href="https://www.etymonline.com/word/machine">https://www.etymonline.com/word/machine</a><a href="#fnref59" class="footnote-back">↩</a></p></li>
<li id="fn60"><p><a href="https://www.etymonline.com/word/machine">https://www.etymonline.com/word/machine</a><a href="#fnref60" class="footnote-back">↩</a></p></li>
<li id="fn61"><p><a href="https://www.etymonline.com/word/automaton">https://www.etymonline.com/word/automaton</a><a href="#fnref61" class="footnote-back">↩</a></p></li>
<li id="fn62"><p><a href="https://www.etymonline.com/word/robot">https://www.etymonline.com/word/robot</a><a href="#fnref62" class="footnote-back">↩</a></p></li>
<li id="fn63"><p><a href="https://en.wikipedia.org/wiki/Causa_sui">https://en.wikipedia.org/wiki/Causa_sui</a><a href="#fnref63" class="footnote-back">↩</a></p></li>
<li id="fn64"><p><a href="https://en.wikipedia.org/wiki/Logos_(Christianity)">https://en.wikipedia.org/wiki/Logos_(Christianity)</a><a href="#fnref64" class="footnote-back">↩</a></p></li>
<li id="fn65"><p><a href="https://biblehub.com/sepd/genesis/1.htm">https://biblehub.com/sepd/genesis/1.htm</a><a href="#fnref65" class="footnote-back">↩</a></p></li>
<li id="fn66"><p><a href="https://en.wikipedia.org/wiki/Cantor%27s_paradise">https://en.wikipedia.org/wiki/Cantor%27s_paradise</a><a href="#fnref66" class="footnote-back">↩</a></p></li>
</ol>
</section>
                </div>
            </div>
        </main>
                        <div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
var disqus_config = function () {
    this.page.url = "https://edom.github.io/compute.html";  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = "https://edom.github.io/compute.html"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://edom-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                        <footer class="site-footer h-card">
            <data class="u-url" href="/"></data>
            <div class="wrapper">
                <p>This page was created on 2017-06-29 22:40 +0700.</p>
                <p class="rss-subscribe">There is an
                    <a href="/feed.xml">RSS feed</a>, but it's unused because this site is a wiki, not a blog.</p>
                <p>Stop writing books, papers, and blogs!
                    Write a personal wiki instead!
                    Or, even better, contribute to a community wiki.
                </p>
            </div>
        </footer>
    </body>
</html>
