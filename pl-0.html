<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Sketch of PL-0 programming language</title>
        <link rel="stylesheet" href="/assets/main.css"/>
        <script>
// Help the reader estimate how much time the reading is going to take.
// Show word count and reading time estimation in TOC entry.
//
// TOC = table of contents
//
// Known issue: This janks: this DOM manipulation is done after the page is rendered.
// If we don't want jank, we have to manipulate the HTML source before it reaches the browser.
// We assume that the user doesn't refresh the page while reading.
// The benefit of fixing that jank is not enough for me to justify trying to fix it.
document.addEventListener("DOMContentLoaded", function () {
    function count_word (string) {
        return string.trim().split(/\s+/).length;
    }
    function show_quantity (count, singular) {
        let plural = singular + "s"; // For this script only.
        return count + " " + ((count == 1) ? singular : plural);
    }
    function create_length_indicator (word, minute) {
        let e = document.createElement("div");
        e.className = "toc_entry__length_indicator";
        e.textContent = " (" + show_quantity(word, "word") + " ~ " + show_quantity(minute, "minute") + ")";
        return e;
    }
    // We assume that readers read this many words per minute with 100% comprehension.
    // This assumption may not hold for dense texts such as philosophy and mathematics.
    const wpm_assumption = 200;
    // We assume a certain Jekyll template.
    let page = document.querySelector("main.page-content");
    if (page === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"main.page-content\" does not match anything");
        return;
    }
    let page_title = document.querySelector("header.post-header h1.post-title");
    if (page_title === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"header.post-header h1.post-title\" does not match anything");
        return;
    }
    let page_word = count_word(page.textContent);
    let page_minute = Math.ceil(page_word / wpm_assumption);
    page_title.insertAdjacentElement("afterend", create_length_indicator(page_word, page_minute));
    // We violate the HTML specification.
    // The page may have several elements with the same ID.
    // We assume that Org HTML Export generates a DIV element with ID "table-of-contents".
    // We assume that Jekyll Markdown-to-HTML generates a UL element with ID "markdown-toc".
    // This only works for Org HTML Export's TOC.
    let toc_entries = document.querySelectorAll("#table-of-contents a, #text-table-of-contents a");
    toc_entries.forEach((toc_entry_a) => {
        let href = toc_entry_a.getAttribute("href"); // We assume that this is a string like "#org0123456".
        if (href.charAt(0) !== '#') {
            console.log("toc_generate_estimate: Impossible: " + href + " does not begin with hash sign");
            return;
        }
        // We can't just document.querySelector(href) because target_id may contain invalid ID characters such as periods.
        let target_id = href.substring(1);
        let id_escaped = target_id.replace("\"", "\\\"");
        let h_elem = document.querySelector("[id=\"" + id_escaped + "\"]"); // We assume that this is the h1/h2/h3 element referred by the TOC entry.
        if (h_elem === null) { // We assume that this is impossible.
            console.log("toc_generate_estimate: Impossible: " + href + " does not refer to anything");
            return;
        }
        let section = h_elem.parentNode;
        let section_word = count_word(section.textContent);
        let section_minute = Math.ceil(section_word / wpm_assumption);
        toc_entry_a.insertAdjacentElement("afterend", create_length_indicator(section_word, section_minute));
    });
});
        </script>

        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12628443-6"></script>
<script>
  window['ga-disable-UA-12628443-6'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-12628443-6');
</script>
        
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            jax: ["input/TeX","input/MathML","input/AsciiMath",
            "output/CommonHTML"
            ],
            extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "a11y/accessibility-menu.js"],
            TeX: {
                extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
                , equationNumbers: {
                    autoNumber: "AMS"
                }
            },
            "CommonHTML": {
                scale: 100
            },
            "fast-preview": {
                disabled: true,
            }
        });
        </script>
        <style>
            /*
            PreviewHTML produces small Times New Roman text.
            PreviewHTML scale doesn't work.
            */
            .MathJax_PHTML { font-size: 110%; }
        </style>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js" async defer></script>
    </head>
    <body>
        <header class="site-header" role="banner">
            <div class="wrapper">
                <a class="site-title" rel="author" href="/">Erik Dominikus Research Group</a>
            </div>
        </header>
    <div style="display:none;">\(
    \renewcommand\emptyset{\varnothing}
    \newcommand\abs[1]{\left|#1\right|}
    \newcommand\dom{\textrm{dom}}
    \newcommand\cod{\textrm{cod}}
    \newcommand\Bernoulli{\textrm{Bernoulli}}
    \newcommand\Binomial{\textrm{Binomial}}
    \newcommand\Expect[1]{\mathbb{E}[#1]}
    \newcommand\Nat{\mathbb{N}}
    \newcommand\Integers{\mathbb{Z}}
    \newcommand\Real{\mathbb{R}}
    \newcommand\Rational{\mathbb{Q}}
    \newcommand\Complex{\mathbb{C}}
    \newcommand\Pr{\mathrm{P}}
    \newcommand\Time{\text{Time}}
    \newcommand\DTime{\text{DTime}}
    \newcommand\NTime{\text{NTime}}
    \newcommand\TimeP{\text{P}}
    \newcommand\TimeNP{\text{NP}}
    \newcommand\TimeExp{\text{ExpTime}}
    \newcommand\norm[1]{\left\lVert#1\right\rVert}
    \newcommand\bbA{\mathbb{A}}
    \newcommand\bbC{\mathbb{C}}
    \newcommand\bbD{\mathbb{D}}
    \newcommand\bbE{\mathbb{E}}
    \newcommand\bbN{\mathbb{N}}
    \newcommand\frakI{\mathfrak{I}}
    % deprecated; use TimeExp
    \newcommand\ExpTime{\text{ExpTime}}
    \newcommand\Compute{\text{Compute}}
    \newcommand\Search{\text{Search}}
    % model theory structure
    \newcommand\struc[1]{\mathcal{#1}}
    \newcommand\SetBuilder[2]{\{#1 ~|~ #2\}}
    \newcommand\Set[1]{\{#1\}}
    \newcommand\semantics[1]{\langle #1 \rangle}
    \newcommand\bigsemantics[1]{S\left(#1\right)}
    \)</div>
        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
                    <header class="post-header">
                        <h1 class="post-title">Sketch of PL-0 programming language</h1>
                    </header>
                </article>
                <div class="post-content">
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1</span><span class="section_title"><a href="#collecting-the-semantic-design-puzzle-pieces">Collecting the semantic design puzzle pieces</a></span><span class="word_count">(2722w~14m)</span></li>
<li><span class="section_number">2</span><span class="section_title"><a href="#run-time-system">Run-time system</a></span><span class="word_count">(769w~4m)</span></li>
<li><span class="section_number">3</span><span class="section_title"><a href="#syntax-and-parsing">Syntax and parsing</a></span><span class="word_count">(370w~2m)</span></li>
<li><span class="section_number">4</span><span class="section_title"><a href="#thought">&lt;2019-11-27&gt; Thought</a></span><span class="word_count">(123w~1m)</span></li>
<li><span class="section_number">5</span><span class="section_title"><a href="#guide-for-embedding-pl-0-in-c-programs">Guide for embedding PL-0 in C++ programs</a></span><span class="word_count">(404w~3m)</span></li>
<li><span class="section_number">6</span><span class="section_title"><a href="#the-problem-is-not-binding-the-problem-is-closures">&lt;2019-11-28&gt; The problem is not binding; the problem is closures</a></span><span class="word_count">(63w~1m)</span></li>
<li><span class="section_number">7</span><span class="section_title"><a href="#bottom-up-design">Bottom-up design?</a></span><span class="word_count">(328w~2m)</span></li>
<li><span class="section_number">8</span><span class="section_title"><a href="#how-should-programming-languages-be-implemented">How should programming languages be implemented?</a></span><span class="word_count">(1471w~8m)</span></li>
<li><span class="section_number">9</span><span class="section_title"><a href="#all-programming-is-maintenance">All programming is maintenance?</a></span><span class="word_count">(34w~1m)</span></li>
<li><span class="section_number">10</span><span class="section_title"><a href="#bibliography">Bibliography</a></span><span class="word_count">(175w~1m)</span></li>
</ul>
</div>
<h2 id="collecting-the-semantic-design-puzzle-pieces"><span class="section_number">1</span><span class="section_title">Collecting the semantic design puzzle pieces</span></h2>
<p>How should we define the semantics? What properties do we want? Composability/compositionality?</p>
<p>How to design language: Ask <em>critical questions</em> and find <em>corner cases</em>. The answers constrain the language and justify the design.</p>
<p>Here we collect pieces of the semantic design puzzle.</p>
<p>There are several starting point candidates: machine code or mathematics. Where should we begin?</p>
<p>Should we bet our future on the engineers, the scientists, the philosophers, or the mathematicians?</p>
<p>In this section, we motivate and define this:</p>
<pre class="example"><code>meaning : (Expr,State) -&gt; (Expr,State)
</code></pre>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.1</span><span class="section_title"><a href="#motivation-from-a-humble-calculator">Motivation: From a humble calculator</a></span><span class="word_count">(152w~1m)</span></li>
<li><span class="section_number">1.2</span><span class="section_title"><a href="#an-example-of-building-a-programming-language">An example of building a programming language</a></span><span class="word_count">(32w~1m)</span></li>
<li><span class="section_number">1.3</span><span class="section_title"><a href="#an-interpreter-is-a-state-endofunction">An interpreter is a state endofunction</a></span><span class="word_count">(489w~3m)</span></li>
<li><span class="section_number">1.4</span><span class="section_title"><a href="#how-should-we-delimit-scopes">How should we delimit scopes?</a></span><span class="word_count">(9w~1m)</span></li>
<li><span class="section_number">1.5</span><span class="section_title"><a href="#quotation">Quotation</a></span><span class="word_count">(366w~2m)</span></li>
<li><span class="section_number">1.6</span><span class="section_title"><a href="#let-binding-substitution-maximal-sharing-graphs-factoring">Let, binding, substitution, maximal sharing, graphs, factoring</a></span><span class="word_count">(244w~2m)</span></li>
<li><span class="section_number">1.7</span><span class="section_title"><a href="#printing-externalization-representation">Printing, externalization, representation</a></span><span class="word_count">(20w~1m)</span></li>
<li><span class="section_number">1.8</span><span class="section_title"><a href="#what">What?</a></span><span class="word_count">(284w~2m)</span></li>
<li><span class="section_number">1.9</span><span class="section_title"><a href="#for-hygiene-resolve-references-before-expanding-macros">&lt;2019-12-12&gt; For hygiene, resolve references before expanding macros</a></span><span class="word_count">(149w~1m)</span></li>
<li><span class="section_number">1.10</span><span class="section_title"><a href="#semantics">Semantics</a></span><span class="word_count">(577w~3m)</span></li>
<li><span class="section_number">1.11</span><span class="section_title"><a href="#security-considerations">Security considerations</a></span><span class="word_count">(310w~2m)</span></li>
<li><span class="section_number">1.12</span><span class="section_title"><a href="#arranging-the-puzzle-pieces">Arranging the puzzle pieces?</a></span><span class="word_count">(24w~1m)</span></li>
</ul>
</div>
<h3 id="motivation-from-a-humble-calculator"><span class="section_number">1.1</span><span class="section_title">Motivation: From a humble calculator</span></h3>
<p><em>Computers can be thought of as calculators with state.</em> By &quot;state&quot;, we mean &quot;memory&quot; or &quot;storage&quot;. So, we begin by modeling a stateless calculator, and then we gradually add features.</p>
<p>Originally, computers were invented to help people do arithmetics, which is a part of mathematics. Thus we should start from mathematics.</p>
<p>We begin by writing a function that evaluates calculator expressions, and then we generalize that. Let us name the function &quot;meaning : Exp -&gt; Val&quot;. That function may be defined like this:</p>
<pre class="example"><code>Val = Int

x:Val   =&gt; x:Exp
x,y:Exp =&gt; x+y : Exp
x,y:Exp =&gt; x*y : Exp

x:Val   =&gt; meaning x = x
x,y:Exp =&gt; meaning (x+y) = meaning x + meaning y
x,y:Exp =&gt; meaning (x*y) = meaning x * meaning y
...
</code></pre>
<p>For example, meaning(2+3) = 5.</p>
<p>We add bindings/variables/substitutions. This generalizes &quot;meaning&quot; to &quot;meaning : (Bindings,Exp) -&gt; Val&quot;.</p>
<pre class="example"><code>meaning bindings (Let1 name expr body) =
  let val = meaning bindings expr
      bindings_1 = bindings LEFT-UNION {name =&gt; val}
  in  meaning bindings_1 body
</code></pre>
<p>Because Val is a subset of Exp, we generalize &quot;Val&quot; to &quot;Exp&quot;.</p>
<p>Then we add state. This generalizes &quot;Bindings&quot; to &quot;State&quot;.</p>
<p>We can rearrange &quot;meaning : State -&gt; Exp -&gt; Val&quot; to &quot;meaning : (State,Exp) -&gt; (State,Exp)&quot;. Then we can rearrange it further to &quot;meaning : State' -&gt; State'&quot; with &quot;current-expression : State' -&gt; Exp&quot;.</p>
<h3 id="an-example-of-building-a-programming-language"><span class="section_number">1.2</span><span class="section_title">An example of building a programming language</span></h3>
<p>Another point of view is that programming languages are invented to make it easier to generate machine code.</p>
<p>Suppose that we start with an arithmetic expression evaluator.</p>
<pre class="example"><code>(evaluate (* (+ 2 3) (+ 2 3)))
</code></pre>
<h3 id="an-interpreter-is-a-state-endofunction"><span class="section_number">1.3</span><span class="section_title">An interpreter is a state endofunction</span></h3>
<p>When you interpret a paragraph, you interpret each sentence sequentially. When you interpret a sentence, you change your internal state.</p>
<blockquote>
<p>Let X be 10. Compute 2*X. Forget it. Let X be 20. Compute 3*X.</p>
</blockquote>
<p>Interpreting a program fragment changes the interpreter state and produces a residual program, which is then again interpreted to change the interpreter state, and so on.</p>
<pre class="example"><code>-- An implementation in Scheme?
(define (interpret s)
  (match (get-expression s)
    ((sequence x y ...)
     (define s&#39; (interpret (set-expression s x)))
     (interpret (set-expression s (sequence y ...))))))
</code></pre>
<p>An <em>interpreter state</em> has a <em>global mapping</em>, a <em>current expression</em>, and perhaps many other things not directly exposed to the program.</p>
<p>The meaning of an expression E is a State endofunction.</p>
<p>I think I'm going to be convenient with that formalism. Let's try building a Lisp interpreter from the semantic function (Expr -&gt; State -&gt; (Expr,State)).</p>
<p>Expr is first parameter so we can write the curried expression meaning(E).</p>
<pre class="example"><code>State = (Expr,Other_State)

meaning : Expr -&gt; Other_State -&gt; (Expr,Other_State)

meaning Current_State s = (s, s)
meaning (Calculate e) s = (calculate e, s)
meaning (Interpret e) s = meaning e s
meaning (Quote e) s = (e, s)
meaning (Define name expr) s = (Unit, ???)
meaning (Let name expr body) s = (Unit, ???)
meaning (Car e) s = car (meaning e s)
meaning (Cdr e) s = cdr (meaning e s)
meaning (Namespace e ...) = (ns???, s&#39;)
meaning (Before x y) s =
  let (_, s&#39;) = meaning x s
  in  meaning y s&#39;

...
</code></pre>
<p>To find the primitives, instead ask &quot;What is the syntax of <em>fully expanded expressions</em>?&quot;</p>
<p>What are the primitives in McCarthy's original LISP?</p>
<p>From McCarthy 1959 <span class="citation" data-cites="McCarthy1959RecursiveFO">[<a href="#ref-McCarthy1959RecursiveFO">8</a>]</span>:</p>
<ul>
<li>&quot;the universal S-function 'apply' which plays the theoretical role of a universal Turing machine and the practical role of an interpreter&quot;</li>
<li>Primitive functions: atom, eq, car, cdr, cons</li>
</ul>
<p><a href="https://docs.racket-lang.org/reference/syntax-model.html#%28part._fully-expanded%29">Racket's syntax of its fully expanded programs</a></p>
<p>What are GHC's primitives?</p>
<p>Scheme? Kernel language? Qi/Shen?</p>
<p><a href="https://web.cs.wpi.edu/~jshutt/kernel.html">John N. Shutt</a> &quot;Kernel is a conservative, Scheme-like dialect of Lisp in which everything is a first-class object.&quot; What does he mean by &quot;everything&quot;?</p>
<p><a href="https://eighty-twenty.org/2011/09/29/fexprs-remain-inscrutable">Problems with the Kernel language</a></p>
<p>I think we want these forms, and there is no other way to implement these forms other than by primitives:</p>
<pre class="example"><code>(current-state) ;; This is where we differ from other Lisps?
(quote Expr) ;; We also differ by making (quote 1) not equal to 1
(interpret Expr) ;; How does this differ from the eval in other Lisps?
(car Expr) ;; pair-first
(cdr Expr) ;; pair-second
(cons Expr Expr) ;; make-pair
(bind Expr) ;; compute lexical binding
(let1 Name Expr Body) or (lambda1 Param Body)
(before Expr Expr) ;; for ordering/sequencing evaluation
(eq? Expr Expr)
(equal? Expr Expr)
(read-syntax)
(read-concrete)
(calculate Expr) ;; ???
</code></pre>
<p>The &quot;lambda&quot; construct does two things: it both <em>delimits a scope</em> and <em>binds occurrences</em>. Can we separate them into two separate constructs?</p>
<p>(λx. [(λx. x) 1]) 2</p>
<pre class="example"><code>;; (let1 Name Expr Body) delimits scope
(let1 &#39;x 1 (let1 &#39;x 2 x))
</code></pre>
<p>The <code>let1</code> form is used by <code>bind</code> for lexical scoping.</p>
<p>The <code>let1</code> form should use maximal sharing?</p>
<p>Note: <code>(define (quote one) (quote 1))</code>, not <code>(define one 1)</code>.</p>
<pre class="example"><code>meaning (Define name expr) s0 =
  let (s1,iname) = meaning name s0
      (s2,iexpr) = meaning expr s1
      s3 = s2 LEFT-UNION { iname =&gt; iexpr }
  in  (s3,iexpr)
</code></pre>
<p>Another question: should (define Name Expr) normalize to unit or to the value of Expr?</p>
<p>We agree that <code>(define Name Expr)</code> modifies the interpreter state. What we don't agree on is how <code>Expr</code> should be evaluated: lazily, eagerly, or not evaluated at all.</p>
<p>Consider the difference:</p>
<blockquote>
<p>Let X be 1+2.</p>
<p>Let X be <em>the result of</em> 1+2.</p>
<p>Let &quot;X&quot; be &quot;1+2&quot;.</p>
<p>Let X <em>be</em> John.</p>
<p>Let X <em>refer to</em> John.</p>
<p>Define &quot;chair&quot; as a seat that has back rest.</p>
<p>Define &quot;chair&quot; as a &quot;seat&quot; that has &quot;back rest&quot;.</p>
<p>Find a chair, and sit on it.</p>
<p>(Not: Find a &quot;chair&quot;.)</p>
</blockquote>
<p>Quotes are also used for hedging, connotation, innuendo, codewords, humor, etc.</p>
<p>When we encounter &quot;let X be &lt;a complex expression&gt;&quot; while reading mathematics, we do not evaluate the complex expression.</p>
<pre class="example"><code>(let x be (+ 1 2))
(let (quote x) be (quote (+ 1 2)))
(define chair as (extend seat with back-rest))
</code></pre>
<p>Should &quot;interpret&quot; be called &quot;normalize&quot; instead? Should we provide the programmers the means to &quot;reduce&quot; an expression one step instead of &quot;normalizing&quot; the expression?</p>
<p>The <code>progn</code> form can be derived by either left-folding or right-folding <code>before</code>.</p>
<pre class="example"><code>(progn x y z) = (before x (before y z))
(progn x y z) = (before (before x y) z)
</code></pre>
<p>Which of these forms should be primitive, and what should they mean?</p>
<pre class="example"><code>(define Name Expr) ;; global binding if occurs on top-level
(vector Expr ...)
(delimit-scope Expr ...) ???
(namespace Expr ...) ???
(apply Func Arg ...)
(list Expr ...) ;; can be stated in terms of cons
</code></pre>
<p>First-class interpreter state: There is an expression whose interpretation is the interpreter state.</p>
<p>An expression e is a <em>value</em> iff meaning(e,s) = s.</p>
<p>A state s is <em>terminal</em> iff interpret(s) = s.</p>
<pre class="example"><code>(define x y)
=
(hash-table-set!
  (current-interpreter-state)
  (quote x)
  (interpret y))
</code></pre>
<p>When should an expression be rewritten?</p>
<p>Perhaps we all agree that <code>(calculate (+ 1 2))</code> should evaluate to <code>3</code>.</p>
<h3 id="how-should-we-delimit-scopes"><span class="section_number">1.4</span><span class="section_title">How should we delimit scopes?</span></h3>
<p>TODO:</p>
<ul>
<li>Constructs for delimiting scope/context</li>
<li>First-class scope</li>
</ul>
<h3 id="quotation"><span class="section_number">1.5</span><span class="section_title">Quotation</span></h3>
<p>Quoting is not only a feature of written language, but also of spoken language, although it is more pronounced in written language. In spoken language, quoting is indicated by intonation, gestures, or additional clarifying words. For example: When we say if John says to Mary &quot;write the name of your dog&quot;, and Mary's dog's name is &quot;Doggy&quot;, then Mary usually interprets the utterance as &quot;Write 'Doggy'&quot; and not &quot;Write 'the name of your dog'&quot;, unless Mary is joking or uncooperative. However, if John says &quot;write as i dictate &lt;pause&gt; the name of your dog&quot;, then he may mean it literally. In spoken language, pragmatics plays more role than syntax. In written language, we elaborate syntax to compensate for missing intonation and gestures.</p>
<p>Example: Suppose Alice says to Bob, &quot;Management hates it.&quot; If Bob writes &quot;Alice said to me that management isn't too fond of it&quot;, he is not lying, although he could use another word like &quot;hinted&quot; or &quot;suggested&quot; instead of &quot;said&quot;. If Bob writes &quot;Alice said to me, 'Management isn't too fond of it'&quot;, he is lying.</p>
<p>Critical thoughts:</p>
<ul>
<li>I think <code>(equal? (quote 1) 1)</code> should evaluate to <code>#f</code>, because &quot;1&quot; is not equivalent to 1.</li>
<li>I think <code>(eq? (quote 1) 1)</code> should evaluate to <code>#f</code>, because &quot;1&quot; is not identical to 1.</li>
<li>Indeed, I think <code>(equal? (quote x) x)</code> should evaluate to <code>#f</code> for all <code>x</code>, except in evaluation errors.</li>
</ul>
<p>That is, <code>quote</code> should just quote, and not do anything else, let alone evaluate its argument.</p>
<p>The interpretation of <code>(quote x)</code> is <code>x</code>?</p>
<p>Quotation is not totally opaque. For example: It makes sense to say &quot;The first letter in 'XYZ' is X&quot;, and thus the quoted &quot;XYZ&quot; is not an opaque entity that can only either be passed around or be unquoted.</p>
<p>The question is: What should <code>(quote (1 2))</code> be?</p>
<p>It is confusing to talk about quotations. For example: <code>(quasiquote (x (unquote y) z))</code> is <code>(quote x y' z)</code> where y' is the meaning of y.</p>
<p>Should <code>equal?</code> evaluate its arguments before comparing them? Yes, because &quot;equal&quot; does not mean &quot;identical&quot;. 1+2 and 3 are equal in decimal arithmetics, but they are not identical. Two different names may refer to the same referent and thus be equal, but those different names are never identical.</p>
<pre class="example"><code>Q: Calculate 1+2.
A: 3.
(calculate (+ 1 2))

Q: Calculate &quot;1+2&quot;.
A: &quot;1+2&quot;.
(calculate (quote (+ 1 2)))

Q: Calculate X+X where X=10.
A: 20.
(calculate (let ((x 10)) (+ x x)))
different from: (let ((x 10)) (calculate (+ x x)))
(calculate (let ((f (lambda (x) (+ x 1)))) (f (f x))))
</code></pre>
<h3 id="let-binding-substitution-maximal-sharing-graphs-factoring"><span class="section_number">1.6</span><span class="section_title">Let, binding, substitution, maximal sharing, graphs, factoring</span></h3>
<p>Here we motivate why <code>let</code> should be lazy and should introduce maximal sharing.</p>
<p>We begin by the problem in which a meaningful expression L(x,1/0) has a meaningless subexpression 1/0.</p>
<p>Suppose we have defined L(x,y) = x. The question: What should be the meaning of L(x,1/0)? We know that 1/0 is syntactically valid but is meaningless. Solution: We add a <em>bottom value</em> (⊥) to the Universe. The bottom value represents errors. A bottom means an error, but the details of the error is ignored by the &quot;meaning&quot; function.</p>
<pre class="example"><code>L x y = x
L x (1/0) = ?
let y = 1/0 in L(x,y)
</code></pre>
<p>I think we expect these to have the same meaning:</p>
<pre class="example"><code>f x
let x&#39; = x in f x&#39;
</code></pre>
<p>That is, &quot;f(x)&quot; should have the same meaning as &quot;let x' = x in f(x')&quot;. Therefore, &quot;let&quot; must do substitution, not evaluation. But naïve substitution is inefficient. But maximal sharing has the same semantics as substitution and is efficient.</p>
<p>However, we don't always want &quot;let&quot; to introduce maximal sharing. Sometimes we want &quot;let&quot; to evaluate the binding before evaluating the body. We have two choices: do strictness analysis like GHC, or let the programmers choose which one they want.</p>
<p>Thus, <code>let</code> should internalize the expression into a graph with maximal sharing. Each variable is evaluated at most once. At-most-once semantics. &quot;before&quot; can be used to order evaluation. Note that ordering evaluation does not mean forcing evaluation.</p>
<pre class="example"><code>meaning(x/0) = ⊥
if L(x,y) = x then
  meaning(L(x,y)) = meaning(x)
  meaning(L(x,⊥)) = meaning(x)
  meaning(L) = (U2,U,SetBuilder ((x,y),x) x,y in U)?
  meaning(L(x)) = ??? Currying?
??? (normalize-in-normal-order (L x y)) ???
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem">Church–Rosser theorem</a>? In total functional programming, both eager and lazy evaluation produces the same result?</p>
<p>We don't want to repeat ourselves, so we add these features to our language: factoring, references, and substitutions.</p>
<pre class="example"><code>(evaluate
  (let [(x 2)
        (y 3)
        (z (+ x y))]
    (* z z)))
</code></pre>
<h3 id="printing-externalization-representation"><span class="section_number">1.7</span><span class="section_title">Printing, externalization, representation</span></h3>
<p>Not only do we want the computer to compute, but we also want it to <em>show</em> the result:</p>
<pre class="example"><code>(print (evaluate (+ 1 2)))
</code></pre>
<h3 id="what"><span class="section_number">1.8</span><span class="section_title">What?</span></h3>
<p>We want to &quot;solve&quot; a differential equation.</p>
<p>We create some things: a representation for differential equations, and a compiler (a translator) that, given a differential equation and its initial conditions, generates what? A procedure? A generator? A list of numbers?</p>
<pre class="example"><code>;; 0 = Df(x) + 2 * f(x)
(approximate
  (differential-equation
    (= 0 (+ ([d f] x) (* 2 [f x])))
    functions (f)
    variables (x))
  method [euler
    initial-conditions [(x 0)]
    step-size 1.0e-6])
</code></pre>
<p>But the form is rather inflexible: What if the users want to implement their own methods? With if the users want to approximate other things, such as a system of equations?</p>
<p>We also want to plot the result…</p>
<p>We also want to implement iterative approximation algorithms, etc.</p>
<p>Then we want to parse.</p>
<p>Note the reference to <code>my-char</code> in the <code>parse:interpret</code> block.</p>
<pre class="example"><code>(define-function (f port)
  (define-local-variables my-char my-string)
  (parse:interpret program (sequence
      (char) ;; read any char
      (set! my-char char) ;; read any char and store it to my-char
      (set! my-string (string of length 8))
      (char y)
      (char #\z)
      (char 0)
      (char code 32)
      (set! my-choice (choose (char x) (char y)))
      eof)
    with-input-from port))
</code></pre>
<p>Can we generate a pretty printer and a parser from a common description?</p>
<p>Informally, a printer is an inverse parser. For example: In a parser, the program <code>(set! x char)</code> reads a char from the stream and mutates x to refer to the char. In a printer, the same program dereferences a char from x and writes the char to the stream.</p>
<p>Note that in <code>(define x 1)</code>, we do not set <code>x</code> to <em>contain</em> 1, but we set <code>x</code> to <em>refer</em> to 1.</p>
<p>Then we also want computers to store data, etc.</p>
<p>Computers are machines that help us do mathematics.</p>
<p>Mathematics is not limited to numbers. Mathematics is about unambiguous abstract thinking.</p>
<p>Computer manipulates bits; humans give meaning to computation (what a computer does).</p>
<p>I am impressed by how van Roy &amp; Haridi 2004 <span class="citation" data-cites="van2004concepts">[<a href="#ref-van2004concepts">9</a>]</span> come up with alternative semantics.</p>
<p>We should not only make computers <em>do</em> something, but we should also make computers <em>understand</em> something, so that they can help us make them do something. When I first saw the delayed concurrent variable assignment semantics, I was amazed.</p>
<p>…</p>
<p>Finally, after all that hard work, we want to share our work. We want to improve our lives together.</p>
<h3 id="for-hygiene-resolve-references-before-expanding-macros"><span class="section_number">1.9</span><span class="section_title">&lt;2019-12-12&gt; For hygiene, resolve references before expanding macros</span></h3>
<p>For hygiene, references must be resolved (bound) before macros are expanded.</p>
<p>Example:</p>
<pre class="example"><code>A = &quot;There is Andrew.&quot;
B = &quot;There is Bob. He is talking.&quot;
A B = &quot;There is Andrew. There is Bob. He is talking.&quot;
</code></pre>
<p>Naïve syntactical concatenation of and A and B causes ambiguity.</p>
<p>But not if we resolve the references first.</p>
<pre class="example"><code>RA = &quot;There is Andrew.&quot;
RB = &quot;There is Bob. He(Bob) is talking.&quot;
RA RB = &quot;There is Andrew. There is Bob. He(Bob) is talking.&quot;
</code></pre>
<p>Ambiguity: The expression <code>(f x)</code> is ambiguous. If <code>f</code> refers to a procedure, the expression means &quot;evaluate x to ex and then compute f(ex)&quot;. If <code>f</code> refers to a macro, the expression means &quot;expand (f y) where y is a reference to x&quot;.</p>
<p>Term-rewriting rules / fexprs unify procedures and macros? The problem is we want to let the programmers how and when a fragment is expanded?</p>
<p>But it is possible to write an AST transformer that produces an invalid AST. For example, one can pull out a lexically scoped variable out of its scope.</p>
<p>We let the programmers decide. If they want hygiene, they can use AST transformers. If they don't want hygiene, they can use CST transformers.</p>
<h3 id="semantics"><span class="section_number">1.10</span><span class="section_title">Semantics</span></h3>
<p>What should a symbol mean? It usually means a hash-table lookup, where the symbol is the key and the environment is the hash table. But is there a better semantics?</p>
<p>In human languages, the meaning of a symbol is usually determined by agreement/consensus between the users of the symbol. For example, I can define &quot;foobar&quot; to mean &quot;table&quot; in a document, and the readers will be able to understand the document if they play along.</p>
<p>The meaning of a symbol may be defined in terms of the meaning of other symbols. For example, &quot;<em>chair</em>&quot; may be defined as a &quot;<em>seat</em> with <em>back rest</em>&quot;.</p>
<p>In human languages, the irreducible meanings are the <em>direct experiences</em> (such as the concepts represented by &quot;red&quot;, &quot;sweet&quot;, &quot;happy&quot;). For other examples of irreducible meanings, see <a href="https://en.wikipedia.org/wiki/Semantic_primes">Semantic primitives</a> and <a href="https://en.wikipedia.org/wiki/Natural_semantic_metalanguage">Natural semantic metalanguage</a>.</p>
<p>In Assembly, the irreducible meanings are the meaning of the execution of an instruction; such meanings can be formalized as state transformers. For example, the meaning of executing <code>inc rax</code> is to mutate the machine state such that <code>rax</code> now contains the previous value of <code>rax</code> incremented by one, modulo <span class="math inline">\( 2^{64} \)</span>.</p>
<p>Perhaps we want something like <a href="https://en.wikipedia.org/wiki/Refal">Refal</a> but in Lisp syntax?</p>
<p>How do we build meaning in mathematics? We may start from logic, axioms, natural numbers.</p>
<p><a href="https://en.wikipedia.org/wiki/Jakobson%27s_functions_of_language">Jakobson's functions of language</a></p>
<p>In Lisps, the irreducible meanings are the meaning of the values, including the side-effects.</p>
<p>How do we distinguish between &quot;Print 2 + 3&quot; and &quot;Print <em>the result of calculating</em> 2 + 3&quot;? We use <a href="https://en.wikipedia.org/wiki/Use%E2%80%93mention_distinction">Use-mention distinction</a>. See also B. C. Smith's PhD thesis.</p>
<p>A quoted word means itself.</p>
<p>Therefore, to design a programming language is to decide <em>how to build meanings from a finite set of irreducible meanings</em>. That is, how to build values.</p>
<p>However, meanings are inseparable from pragmatics. For example, the expected answer to &quot;Can you pass me the salt?&quot; is not the <em>utterance</em> &quot;Yes&quot;, but the <em>action</em> of passing the salt.</p>
<pre class="example"><code>interpret : Internal-Form -&gt; Meaning
interpret : Abstract-Syntax -&gt; Semantics
</code></pre>
<p>We must distinguish between an <em>internal form</em> and its <em>external representation</em>.</p>
<p>The <code>read</code> function transforms an external representation into an internal form?</p>
<pre class="example"><code>(calculate (+ 1 2)) -&gt; 3
(calculate (+ 1 2) into x) ???
</code></pre>
<p>A procedure can be thought of as a term rewriting rule (a reduction rule).</p>
<p>Should a <code>define</code> be interpreted as a <code>hash-set!</code> or as a <em>rule definition</em>?</p>
<p>Which syntax should we use to define a rule?</p>
<pre class="example"><code>(rewrite x 1)

(rewrite (x) (f x) (+ x x))

(define-rewrite (forall (x) [(f x) (+ x x)]))

(rewrite (f :lit x :var) :to (+ x x))

(with-variables (x)
  (with-literals (f +)
    (with-undefined-symbols-as-literals
      (with-numeric-symbols-as-numbers
        (defrule (f 0) 1)
        (defrule (f x) (* x (f (- x 1))))
      ))))

(define-function (f x) (+ x x))
</code></pre>
<p>Should <em>numeric symbols</em> (symbols that look like numbers: symbols that consist of only digits) be treated as <em>numbers</em>? I think yes, because we have the vertical-bar syntax like <code>|123|</code> to mean arbitrarily named symbols, including non-number numeric symbols.</p>
<p>The meaning of a <em>rule</em> <span class="math inline">\( A \to B \)</span> is to <em>replace</em> every <em>matching</em> occurrence of <span class="math inline">\(A\)</span> with <span class="math inline">\(B\)</span> in the <em>current expression</em>.</p>
<p>A <em>function</em> can be thought of as a rewriting rule; the function name matches literally; the function arguments match everything (are wildcards).</p>
<p>A symbol may be treated as a <em>literal</em> or a <em>variable</em>.</p>
<p>For example, in <code>(define-function (f x) ...)</code>, the symbol <code>f</code> is a literal, and <code>x</code> is a variable.</p>
<p>In a function header, the pattern <code>(head arg1 ... argN)</code> matches every list that:</p>
<ol>
<li>has length N+1, and</li>
<li>begins with something that has the same binding as <code>head</code>.</li>
</ol>
<p>What should a list such as <code>(x)</code> mean?</p>
<p>What should a list such as <code>(x y)</code> mean?</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.10.1</span><span class="section_title"><a href="#term-rewriting-semantics">Term rewriting semantics?</a></span><span class="word_count">(36w~1m)</span></li>
<li><span class="section_number">1.10.2</span><span class="section_title"><a href="#graph-reduction-semantics">Graph reduction semantics?</a></span><span class="word_count">(36w~1m)</span></li>
</ul>
</div>
<h4 id="term-rewriting-semantics"><span class="section_number">1.10.1</span><span class="section_title">Term rewriting semantics?</span></h4>
<p>For efficiency, we require that the head of a rule begins with a <em>literal</em>, so that we can <em>index</em> the rules for fast matching/retrieval.</p>
<p>The programmers are responsible for ensuring confluence by avoiding ambiguous/overlapping rules.</p>
<h4 id="graph-reduction-semantics"><span class="section_number">1.10.2</span><span class="section_title">Graph reduction semantics?</span></h4>
<p>Should the semantics be formulated in terms of expression graph reductions/transformations?</p>
<p>An S-expression can be thought of representing a <em>tree</em> (or, more precisely, a <em>graph</em>).</p>
<p>A value can be thought of as an irreducible one-vertex graph.</p>
<h3 id="security-considerations"><span class="section_number">1.11</span><span class="section_title">Security considerations</span></h3>
<p>See <a href="secure.html">file:secure.html</a>.</p>
<p>The situation:</p>
<ul>
<li>The programmer is who <em>creates</em> the program.</li>
<li>The user is who <em>runs</em> the program.</li>
<li>The programmer and the user may be two different people.</li>
</ul>
<p>The problem: How does the user limit the maximum damage doable by the programmer?</p>
<p>If we want security, it cannot be an afterthought?</p>
<p>Performance considerations -&gt; cost/performance model</p>
<p>Security considerations -&gt; security/damage model</p>
<p>But the model is not the reality; we risk modeling the wrong thing.</p>
<p>Thus, in making claims about security, we prefer false negatives (the system is actually secure, but the model says it is insecure) to false positives (the system is actually insecure, but the model says it is secure).</p>
<p>In the end, a human has to verify whether the model's simplifying assumptions actually hold for the case at hand.</p>
<p>It is impractical for users to inspect the source code of every program they run. It is more practical for them to periodically backup their data periodically into an airgapped storage and periodically verify that those backups work.</p>
<p>However, what about data &quot;theft&quot;: unwanted leakage of data?</p>
<p>You are buying a book for your child. How can you be sure that the book does not contain any material not suitable for children? We can hypothesize a language called Familyspeak with these properties:</p>
<ul>
<li>Congress defines a set of allowed words in Familyspeak. Every other word is forbidden.</li>
<li>The police enforces that law: it goes to the store and verifies that every book that claims to be written in Familyspeak indeed complies to the law.</li>
</ul>
<p>However, even though Familyspeak prevents <em>words</em> inappropriate for children, it does not prevent <em>ideas</em> inappropriate for children. For example, Familyspeak syntax may allow the words &quot;eat&quot;, &quot;your&quot;, and &quot;parents&quot;, but the idea &quot;eat your parents&quot; is inappropriate for children. Appropriate words can be arranged to convey inappropriate ideas.</p>
<p>We assume that user U's running programmer P's program proves that user U trusts programmer P. (What if U runs P's program accidentally or unknowingly?)</p>
<h3 id="arranging-the-puzzle-pieces"><span class="section_number">1.12</span><span class="section_title">Arranging the puzzle pieces?</span></h3>
<p>Now that we have the pieces of the puzzle (quotation, maximal sharing), how do we arrange them into a coherent picture?</p>
<h2 id="run-time-system"><span class="section_number">2</span><span class="section_title">Run-time system</span></h2>
<p><a href="https://drops.dagstuhl.de/opus/volltexte/2015/5475/pdf/4.pdf">Belikov 2015</a> <span class="citation" data-cites="belikov2015language">[<a href="#ref-belikov2015language">2</a>]</span></p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">2.1</span><span class="section_title"><a href="#on-choosing-the-implementation-language">On choosing the implementation language</a></span><span class="word_count">(45w~1m)</span></li>
<li><span class="section_number">2.2</span><span class="section_title"><a href="#memory-management">Memory management</a></span><span class="word_count">(284w~2m)</span></li>
<li><span class="section_number">2.3</span><span class="section_title"><a href="#converting-c-types">Converting C types</a></span><span class="word_count">(10w~1m)</span></li>
<li><span class="section_number">2.4</span><span class="section_title"><a href="#foreign-interface-mostly-c">Foreign interface, mostly C</a></span><span class="word_count">(116w~1m)</span></li>
<li><span class="section_number">2.5</span><span class="section_title"><a href="#values">Values</a></span><span class="word_count">(141w~1m)</span></li>
<li><span class="section_number">2.6</span><span class="section_title"><a href="#do-we-need-generic-functions-the-case-of-append">Do we need generic functions? The case of &quot;append&quot;</a></span><span class="word_count">(119w~1m)</span></li>
<li><span class="section_number">2.7</span><span class="section_title"><a href="#representation-of-values">Representation of values</a></span><span class="word_count">(57w~1m)</span></li>
</ul>
</div>
<h3 id="on-choosing-the-implementation-language"><span class="section_number">2.1</span><span class="section_title">On choosing the implementation language</span></h3>
<p>We choose C++ as the implementation language because we don't know any better. We considered Rust and Go but we could not make up our minds. We refuse C because we want namespaces; we refuse to manually prefix every procedure name.</p>
<h3 id="memory-management"><span class="section_number">2.2</span><span class="section_title">Memory management</span></h3>
<p>We use a <em>garbage collector</em> because we believe that that garbage collection greatly simplifies the language semantics. Also, we don't know how to implement a Lisp without garbage collection like <a href="https://github.com/wolfgangj/bone-lisp/">Bone Lisp</a>, Pre-Scheme, Carp, newLISP, Linear Lisp, and ThinLisp.</p>
<p>We use a <em>copying garbage collector</em> because we are convinced by Appel 1987 <span class="citation" data-cites="appel1987garbage">[<a href="#ref-appel1987garbage">1</a>]</span><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> that &quot;[naïve copying] garbage collection can be faster than stack allocation&quot;.</p>
<p>The drawbacks of our simple choices are:</p>
<ul>
<li>We have to overprovision physical memory if we want our programs to run at a reasonable speed.</li>
<li>We lose real-time guarantee; the program may pause for an unpredictable duration at inopportune times.</li>
</ul>
<p>We may wish to do these later:</p>
<ul>
<li>Improve the garbage collector to be generational and concurrent. Currently we stop the world while we collect garbage because we don't know how to do it concurrently.</li>
<li>Implement alternative garbage collectors and let the programmer choose.</li>
<li>Write a compiler for, say, PL-1, a language with manual memory management, and probably also static typing, on top of PL-0. Thus the real-time part of the program can be written in PL-1 while seamlessly interoperating with PL-0.</li>
</ul>
<p>How do we trace the references?</p>
<p>What is a reasonably simple implementation?</p>
<pre class="example"><code>class Object {
    // How do we maintain iterator state without new/malloc?
    // Can we just assume that the iterator state is always an intptr_t?
    // That holds for pair, list, vector, hash-table, but it does not hold for all types (CST)?

    What_Should_This_Be begin_tracing_references();

    // Or should we just abort when there is not enough C++ stack space?

    trace_references(Stack&amp;);

    // Or should we invert the control?
    // In action, copy the object if it has not been visited.

    void for_each_reachable_object_do(Consumer&lt;Object_Id&gt; action);
};

class Pair : public Object {
    Pair_Tracing_Iterator_State tracing_iterator_state;
};
</code></pre>
<p>If we assume that garbage collection is single-threaded, we can put the iterator state in each instance of Object.</p>
<p>Perhaps it is obvious that, for simplicity, <em>the garbage collection process itself should never allocate any heap memory</em>.</p>
<p>I can't think how to do garbage collection (with depth-first search) without stack memory, so the program should just abort if it runs out of stack.</p>
<p>We want precise garbage collection. The price to pay is an extra level of indirection: Objects can only be indirectly accessed by passing an Object<sub>Id</sub> to a World method, and cannot be directly accessed by raw C pointers.</p>
<h3 id="converting-c-types"><span class="section_number">2.3</span><span class="section_title">Converting C types</span></h3>
<p>void, uintN<sub>t</sub>, intN<sub>t</sub>, intptr<sub>t</sub>, for N in {8,16,32,64}.</p>
<h3 id="foreign-interface-mostly-c"><span class="section_number">2.4</span><span class="section_title">Foreign interface, mostly C</span></h3>
<p>We do not expect users to use this directly. The ideal thing for user is to make PL-0 understand C header files. That is, PL-0 should come with a C parser and preprocessor that translate signatures to PL-0 bridges. Compare: <a href="http://www.swig.org/">SWIG</a>. (But why stop there; why not go all the way and write a C interpreter/compiler in PL-0?)</p>
<p>We should use <a href="https://sourceware.org/libffi/">libffi</a> for portability.</p>
<p>Compare: <a href="https://docs.racket-lang.org/foreign/index.html">Racket Foreign Interface</a>.</p>
<p>Suppose there is a C procedure whose declaration is</p>
<pre class="example"><code>Ret proc(Arg-1, ..., Arg-n)
</code></pre>
<p>and we want to call it from PL-0.</p>
<p>With power comes responsibility: The foreign interface enables users to crash the program.</p>
<p>We must represent the <em>type</em> and construct the <em>reference</em>.</p>
<p>A <code>Type</code> is any of these:</p>
<pre class="example"><code>char
int
(unsigned int)
int32_t
uint32_t
(procedure Type (Type-1 ... Type-n))
(struct (Field-1 ... Field-k))
    where each Field-k is a list [name Type]
(union (Type-1 ... Type-n))
</code></pre>
<p>Reference constructors:</p>
<pre class="example"><code>(ref Type Address)
</code></pre>
<p>Actions:</p>
<pre class="example"><code>(read Ref) -&gt; Val
(write Ref) -&gt; Val
(call Ref) -&gt; Val
</code></pre>
<p>We can obtain symbol addresses with <code>dlsym</code>.</p>
<h3 id="values"><span class="section_number">2.5</span><span class="section_title">Values</span></h3>
<p>What should the set of values (the irreducible meanings) in a programming language be?</p>
<p>Perhaps we all agree that the set of values must include at least some integers.</p>
<p>A <em>value</em> (an <em>object</em>) is any of these:</p>
<ul>
<li>a representation of a mathematical object:
<ul>
<li>an <em>integer</em> (of arbitrary precision)</li>
<li>a <em>pair</em> (a <em>cons cell</em>)</li>
<li>a <em>unit</em> (like C void)</li>
<li>a <em>boolean</em> (false or true)</li>
<li>a <em>byte string</em></li>
</ul></li>
<li>a generic data structure:
<ul>
<li>a <em>list</em></li>
<li>a <em>vector</em> (a <em>heterogenous array</em>)</li>
<li>a <em>hash table</em></li>
</ul></li>
<li>a structure used by the interpreter:
<ul>
<li>a <em>namespace</em></li>
<li>an <em>environment</em> (a <em>context</em>)</li>
<li>a <em>rule</em>, function, macro, AST transformer</li>
<li>a <em>type</em></li>
</ul></li>
<li>a structure used by the parser:
<ul>
<li>a <em>location</em></li>
<li>a <em>concrete syntax tree</em> (CST)</li>
<li>an <em>abstract syntax tree</em> (AST)</li>
</ul></li>
<li>a structure used by the C interface
<ul>
<li>a C type representation</li>
<li>a C reference (a type and an address)</li>
</ul></li>
</ul>
<p>There are so many values; are we sure that all of them should be primitives?</p>
<p>Difference from common Lisps:</p>
<ul>
<li>In PL-0, lists and pairs are different things.</li>
<li>PL-0 does not have <em>nil</em>.</li>
</ul>
<h3 id="do-we-need-generic-functions-the-case-of-append"><span class="section_number">2.6</span><span class="section_title">Do we need generic functions? The case of &quot;append&quot;</span></h3>
<p>I want to write just <code>append</code> instead of <code>list-append</code>, <code>vector-append</code>, <code>bytestring-append</code>, etc. In other words, want <code>append</code> to be <em>polymorphic</em>.</p>
<p>What are my choices?</p>
<p>I can define <code>append</code> with <code>cond</code>.</p>
<p>But what if users also want to customize <code>append</code>?</p>
<p>They can define their own <code>append</code> using <code>cond</code> in their own namespaces and fall-back to the standard <code>append</code>.</p>
<p>Or I can define <code>append</code> to be a generic function.</p>
<p>But generic function becomes extremely tricky with subtyping. Julia solves this with a complete lattice of types. But do we have to deal with the unholy interaction between generics/polymorphism/multiple-dispatch and subtyping?</p>
<p>A combination of namespaces and <code>cond</code> is simpler than generic functions, and achieves closed ad-hoc polymorphism, but is it better?</p>
<h3 id="representation-of-values"><span class="section_number">2.7</span><span class="section_title">Representation of values</span></h3>
<p><code>read-cst</code> is similar to Racket's <code>read-syntax</code>, but <code>read-cst</code> reads comments, and the result of <code>read-cst</code> can be turned back to source code (textual representation).</p>
<p><code>read</code> is implemented by calling <code>read-cst</code> and recursively discarding location information and comment nodes.</p>
<p>Unlike in other Lisps, in PL-0, the external representation of a pair is <code>#pair(head tail)</code>, not <code>(head . tail)</code>.</p>
<h2 id="syntax-and-parsing"><span class="section_number">3</span><span class="section_title">Syntax and parsing</span></h2>
<p>We use a recursive descent parser because we don't know any better.</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.1</span><span class="section_title"><a href="#reversibility-information-preservation">Reversibility, information-preservation</a></span><span class="word_count">(151w~1m)</span></li>
<li><span class="section_number">3.2</span><span class="section_title"><a href="#locations">Locations</a></span><span class="word_count">(24w~1m)</span></li>
<li><span class="section_number">3.3</span><span class="section_title"><a href="#macro-reflection-reification-quoting">Macro, reflection, reification, quoting</a></span><span class="word_count">(22w~1m)</span></li>
<li><span class="section_number">3.4</span><span class="section_title"><a href="#annotations-user-defined-metadata-attached-to-concrete-syntax-tree-nodes">Annotations: user-defined metadata attached to concrete syntax tree nodes</a></span><span class="word_count">(163w~1m)</span></li>
</ul>
</div>
<h3 id="reversibility-information-preservation"><span class="section_number">3.1</span><span class="section_title">Reversibility, information-preservation</span></h3>
<p>I insist that the parser be reversible, because I want traceability and debuggability.</p>
<p>Each stage must be reversible: it must either be a bijection or preserve enough information from the previous stage.</p>
<p>The first stage is character + location (defined later).</p>
<p>The next stage is tokenization.</p>
<p>A token has type and a list of characters.</p>
<p>The next stage is concrete syntax tree (CST).</p>
<p>The concrete syntax tree is required for formatting and refactoring, because those activities should preserve comments.</p>
<p>In Lisp syntax, a token coincides with an AST node.</p>
<p>The next stage is abstract syntax tree.</p>
<p>An AST node has a &quot;main&quot; CST node.</p>
<p>An AST node has a &quot;preceding-whites&quot; (a list of whitespace CST nodes that precede that AST node) so that the AST node can be turned back into CST node (and so on until we reach the original substring that constitutes the CST node).</p>
<p>The parser is a recursive descent parser because I don't know how to parse.</p>
<h3 id="locations"><span class="section_number">3.2</span><span class="section_title">Locations</span></h3>
<p>A <em>location</em> is a tuple of path, line (0-based), column (0-based), byte-offset. This is like Racket srcloc.</p>
<p><code>current-location</code> parameter</p>
<p><code>read</code> from current location</p>
<p><code>raise-parse-error</code> at current location</p>
<h3 id="macro-reflection-reification-quoting"><span class="section_number">3.3</span><span class="section_title">Macro, reflection, reification, quoting</span></h3>
<p>The language should be a model of itself.</p>
<p>The language should be able to describe itself.</p>
<p>Does that cause a paradox?</p>
<h3 id="annotations-user-defined-metadata-attached-to-concrete-syntax-tree-nodes"><span class="section_number">3.4</span><span class="section_title">Annotations: user-defined metadata attached to concrete syntax tree nodes</span></h3>
<p>(Is this a good idea?)</p>
<p>We add these expression syntax rules:</p>
<ul>
<li>If M is an expression and E is an expression, then <code>E : M</code> (read: data E annotated with metadata M) is an <em>annotated expression</em>.
<ul>
<li>Alternative syntax: <code>E : M</code> can also be written <code>meta M E</code>.</li>
</ul></li>
</ul>
<p>This generalizes type systems. With type systems, you annotate an expression with a type expression. With general annotations, you annotate an expression with another expression (some of which are type expressions).</p>
<p>We assume that the outermost metadata update wins:</p>
<ul>
<li>meta M (meta N E) = meta M E</li>
</ul>
<p>We add metadata extraction function symbol <code>meta-of</code>.</p>
<p>We add these beta-reduction rules:</p>
<ul>
<li>reduce (meta M E) = reduce E</li>
<li>reduce (meta-of (meta M E)) = reduce M</li>
<li>reduce (meta-of E) = #&lt;empty-record&gt; (for expressions without metadata)</li>
</ul>
<p>This is like Java/C# annotation but more principled?</p>
<p>Annotations are not types.</p>
<p>This is an example of type annotation that our annotation above can't handle: <code>\ (x : T) -&gt; y</code>, because <code>x</code> is not an expression.</p>
<h2 id="thought"><span class="section_number">4</span><span class="section_title">&lt;2019-11-27&gt; Thought</span></h2>
<p>It is easy to process a byte list into a token list.</p>
<p>The question is: How should we interpret that token list? How should we ascribe meaning to that token list? How should we map tokens to values?</p>
<p>The lowest layer is more like a library for manipulating tokens than a language.</p>
<p>A stream of bytes is translated into a stream of tokens. A token is either <em>white</em> or <em>black</em>. A token has <em>location</em>. A token list has <em>location</em>.</p>
<p>I want to use the same name &quot;append&quot; for appending lists and appending strings; I don't want &quot;list-append&quot; and &quot;string-append&quot;. We can implement this with types or namespaces. I'm fine with explicitly-prefixed namespaces like this:</p>
<pre class="example"><code>(define (example)
  (import list)
  (import string)
  (list:append &#39;(1) &#39;(2))
  (string:append &quot;a&quot; &quot;b&quot;))
</code></pre>
<p>Peter Van Roy's &quot;Programming Paradigms for Dummies: What Every Programmer Should Know&quot; <a href="https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf">https://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf</a></p>
<h2 id="guide-for-embedding-pl-0-in-c-programs"><span class="section_number">5</span><span class="section_title">Guide for embedding PL-0 in C++ programs</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">5.1</span><span class="section_title"><a href="#pl-0-c-conventions">PL-0 C++ conventions</a></span><span class="word_count">(7w~1m)</span></li>
<li><span class="section_number">5.2</span><span class="section_title"><a href="#creating-a-virtual-machine">Creating a virtual machine</a></span><span class="word_count">(35w~1m)</span></li>
<li><span class="section_number">5.3</span><span class="section_title"><a href="#executing-programs">Executing programs</a></span><span class="word_count">(161w~1m)</span></li>
<li><span class="section_number">5.4</span><span class="section_title"><a href="#creating-primitives">Creating primitives</a></span><span class="word_count">(20w~1m)</span></li>
<li><span class="section_number">5.5</span><span class="section_title"><a href="#quoting">Quoting</a></span><span class="word_count">(20w~1m)</span></li>
<li><span class="section_number">5.6</span><span class="section_title"><a href="#macros">Macros</a></span><span class="word_count">(29w~1m)</span></li>
<li><span class="section_number">5.7</span><span class="section_title"><a href="#what-1">What?</a></span><span class="word_count">(132w~1m)</span></li>
</ul>
</div>
<h3 id="pl-0-c-conventions"><span class="section_number">5.1</span><span class="section_title">PL-0 C++ conventions</span></h3>
<p>The C++ namespace is <code>stc_pl_0</code>.</p>
<h3 id="creating-a-virtual-machine"><span class="section_number">5.2</span><span class="section_title">Creating a virtual machine</span></h3>
<p>Each instance of the <code>Machine</code> class is a virtual machine with operand stack, dictionary stack, return stack, and heap. The size of each memory area is fixed when the <code>Machine</code> is instantiated.</p>
<pre class="example"><code>Machine machine;
</code></pre>
<h3 id="executing-programs"><span class="section_number">5.3</span><span class="section_title">Executing programs</span></h3>
<p>A <em>program</em> is a sequence of tokens. For example, &quot;1&quot; is a program that pushes the word 1 to the stack. The following is a program that consists of <em>six</em> tokens (1, space, 2, space, add, newline):</p>
<pre class="example"><code>1 2 add
</code></pre>
<pre class="example"><code>void            Machine::push_source (Token_Iterator&amp;)
Token_Iterator&amp; Machine::pop_source ()
</code></pre>
<p>A <em>token iterator</em> can be created from an in-memory token list or an in-disk source file. A file-based token-iterator maintains a location (path, line, column, byte offset).</p>
<p>A <em>token</em> is a byte string with location information (to keep track of its provenance).</p>
<p>Typically, <code>Machine::step</code> is called in a loop. An iteration in the execution loop goes like this, if we ignore errors:</p>
<ul>
<li>read token</li>
<li>determine the executable of that token</li>
<li>execute that executable (a primitive, a value, a token, or a token list)</li>
</ul>
<p><em>The <code>step</code> method executes at most one token.</em> If the meaning of the token is a token list, then <code>step</code> creates a call frame and arranges the next <code>step</code> call to execute the first token of the subroutine.</p>
<p>The machine reads the current program from a token iterator.</p>
<h3 id="creating-primitives"><span class="section_number">5.4</span><span class="section_title">Creating primitives</span></h3>
<p>A <em>primitive</em> is a foreign procedure that may mutate the machine state.</p>
<pre class="example"><code>using Prim = void (Machine&amp;);
</code></pre>
<p>A primitive must not throw any C++ exceptions.</p>
<h3 id="quoting"><span class="section_number">5.5</span><span class="section_title">Quoting</span></h3>
<p>The program <code>quote W B</code> pushes <code>B</code> to the operand stack where <code>W</code> is expected to be a white token.</p>
<h3 id="macros"><span class="section_number">5.6</span><span class="section_title">Macros</span></h3>
<p>A macro is a procedure that transforms a prefix of the remaining program token stream.</p>
<p>A macro transforms a concrete syntax tree.</p>
<p>Important: Whitespaces are tokens too.</p>
<p>Macro : Cst -&gt; Cst</p>
<h3 id="what-1"><span class="section_number">5.7</span><span class="section_title">What?</span></h3>
<pre class="example"><code>% A B C muladd -&gt; A*B+C

quote muladd { mul add } def

define (muladd x y z)
  x y mul z add
end
</code></pre>
<p>Curly braces delimit a token list?</p>
<p>Macros are ordinary functions.</p>
<p><code>quote</code> reads the token right after the token currently being interpreted but does not execute it.</p>
<pre class="example"><code>1 2 quote add -&gt; 1 2 add
1 2 add -&gt; 3
</code></pre>
<p>Type information can be attached to value (Scheme), variable (C++), or function (Assembly). If we want function polymorphism (Scheme display), then we must choose to attach type information at either value or variable.</p>
<p>Why choose? Why not attach type information everywhere (to values, variables, and functions)?</p>
<p>If we want <code>read</code> to produce a value (not a type-value pair), then values must carry type information.</p>
<p>In mathematics, it is natural to overload functions (such as +). Otherwise we would have +N, +Q, +R, etc. which is ugly. Do we care about what something is, or about what can we do with it?</p>
<p>PostScript enables the programmer to choose between early binding and late binding.</p>
<h2 id="the-problem-is-not-binding-the-problem-is-closures"><span class="section_number">6</span><span class="section_title">&lt;2019-11-28&gt; The problem is not binding; the problem is closures</span></h2>
<p>If we don't have closures, then it does not matter whether we use static (lexical) or dynamic binding; the result will be the same.</p>
<p>The problem is not static vs dynamic binding. The problem is: Should we have closures or not?</p>
<p>Why do we bother having closures if programmers can do explicit closure conversion? For example:</p>
<pre class="example"><code>f x = \ y -&gt; x + y
-- gets closure-converted to
f x = (\ x y -&gt; x + y) x
</code></pre>
<h2 id="bottom-up-design"><span class="section_number">7</span><span class="section_title">Bottom-up design?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">7.1</span><span class="section_title"><a href="#example">Example</a></span><span class="word_count">(85w~1m)</span></li>
<li><span class="section_number">7.2</span><span class="section_title"><a href="#starting-with-assembly">Starting with assembly</a></span><span class="word_count">(243w~2m)</span></li>
</ul>
</div>
<h3 id="example"><span class="section_number">7.1</span><span class="section_title">Example</span></h3>
<ul>
<li>Example of bottom-up language design and how each level reduces cognitive load:
<ul>
<li>Begin with machine code.</li>
<li>Provide mnemonics for instructions.</li>
<li>Provide the illusion of infinite custom-named registers and orthogonal operands.</li>
<li>Provide macros subroutines as extensible instructions.</li>
<li>Provide the illusion of infinite custom-named registers and orthogonal operands.</li>
<li>Provide macros and subroutines as extensible instructions.</li>
<li>Provide named locations.</li>
<li>Provide the illusion of infinite memory.</li>
<li>Abstract away processor registers.</li>
<li>Abstract away pointers.</li>
<li>Expression.</li>
<li>Infix expression syntax.</li>
<li>First-class functions.</li>
<li>The program itself is a procedural program that tells the interpreter what code to generate.</li>
<li>End up with something like Randall Hyde's High Level Assembly?</li>
</ul></li>
</ul>
<h3 id="starting-with-assembly"><span class="section_number">7.2</span><span class="section_title">Starting with assembly</span></h3>
<p>PL-0 is slightly more abstract than typed assembly languages (TALs).</p>
<p>We may begin from x86 assembly.</p>
<p>First we abstract away locations, registers, memory, so that we can write something like this:</p>
<pre class="example"><code>mov dword ptr [var_1], [var_2]
</code></pre>
<p>Macro Assembler (MASM)? TASM, NASM, what?</p>
<p>There does not exist a computer with infinite memory. Why do we pretend, with garbage collection, that the computer had infinite memory? Because it simplifies most problems?</p>
<p>What is the problem with these: High-Level Assembly, typed assembly languages such as TALx86 <span class="citation" data-cites="crary1999talx86">[<a href="#ref-crary1999talx86">3</a>]</span><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>, LLVM IR, MSIL, JVM bytecodes?</p>
<p>We can add a type system to assembly language to enforce constraints like these:</p>
<ul>
<li>&quot;Add-integer&quot; takes two integers.</li>
<li>&quot;Add-pointer&quot; takes a pointer of alignment N and an integer that is an integral multiple of N.</li>
<li>It is illegal to add two pointers.</li>
</ul>
<p>For example, a type may be:</p>
<ul>
<li><code>Integer N</code> where N is 1, 2, 4, or 8</li>
<li><code>Pointer A</code> where A is the alignment (1, 2, 4, or 8)</li>
</ul>
<p>One difficulty is that the same register may sometimes contain an integer and sometimes contain a pointer.</p>
<p>We can &quot;solve&quot; that with Static Single Assignment (SSA) Form and automatic register allocation.</p>
<p>But perhaps the bigger issue is to abstract away the difference between processors; why should we care if it is an Intel processor, a Motorola processor, a Symbolics Lisp machine, or something else?</p>
<p>Even though the machine does not know about subroutines, we organize our programs into subroutines; we find it more convenient to work with subroutines than to work with instructions. We feel that the instructions are too finely-grained, unnecessarily detailed.</p>
<h2 id="how-should-programming-languages-be-implemented"><span class="section_number">8</span><span class="section_title">How should programming languages be implemented?</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">8.1</span><span class="section_title"><a href="#which-should-we-write-compilers-or-interpreters">Which should we write: compilers or interpreters?</a></span><span class="word_count">(769w~4m)</span></li>
<li><span class="section_number">8.2</span><span class="section_title"><a href="#how-should-we-make-programming-tools-such-as-compilers-interpreters-and-editors">How should we make programming tools such as compilers, interpreters, and editors?</a></span><span class="word_count">(12w~1m)</span></li>
<li><span class="section_number">8.3</span><span class="section_title"><a href="#what-meta-programming-tools-exist">What meta-programming tools exist?</a></span><span class="word_count">(126w~1m)</span></li>
<li><span class="section_number">8.4</span><span class="section_title"><a href="#meta-programming-and-language-oriented-programming">Meta-programming and language-oriented programming?</a></span><span class="word_count">(162w~1m)</span></li>
<li><span class="section_number">8.5</span><span class="section_title"><a href="#implementing-programming-languages">Implementing programming languages</a></span><span class="word_count">(3w~1m)</span></li>
<li><span class="section_number">8.6</span><span class="section_title"><a href="#should-we-use-prolog">Should we use Prolog?</a></span><span class="word_count">(115w~1m)</span></li>
<li><span class="section_number">8.7</span><span class="section_title"><a href="#write-abstract-interpreters-not-compilers">Write abstract interpreters, not compilers?</a></span><span class="word_count">(67w~1m)</span></li>
<li><span class="section_number">8.8</span><span class="section_title"><a href="#begin-with-an-interpreter-not-a-compiler">Begin with an interpreter, not a compiler</a></span><span class="word_count">(74w~1m)</span></li>
<li><span class="section_number">8.9</span><span class="section_title"><a href="#making-compilers">Making compilers?</a></span><span class="word_count">(36w~1m)</span></li>
<li><span class="section_number">8.10</span><span class="section_title"><a href="#piggybacking-a-host-language">Piggybacking a host language</a></span><span class="word_count">(4w~1m)</span></li>
<li><span class="section_number">8.11</span><span class="section_title"><a href="#how-should-lambda-calculus-be-implemented">How should lambda-calculus be implemented?</a></span><span class="word_count">(108w~1m)</span></li>
</ul>
</div>
<h3 id="which-should-we-write-compilers-or-interpreters"><span class="section_number">8.1</span><span class="section_title">Which should we write: compilers or interpreters?</span></h3>
<p>The original question was &quot;Which should we write: compilers or interpreters?&quot;, but, it seems that the real question is &quot;How should we implement programming languages?&quot;</p>
<p>I want the answer because I am trying to implement a programming language and I do not want to waste my effort.</p>
<p>Should we make compilers or interpreters?</p>
<ul>
<li>Fast code can only be generated by compilers, but the compiler itself may be written in an interpreted language.</li>
<li>Writing an interpreter is easier than writing a compiler, because writing a compiler requires creating representations of two languages (the source language and the target language) the in the host language, whereas writing a interpreter requires creating representation of one language (the source language).</li>
</ul>
<p>What is their relationship? Does one subsume the other? Can we get/derive one from the other? I think this has been answered by Futamura 1999 <span class="citation" data-cites="futamura1999partial">[<a href="#ref-futamura1999partial">5</a>]</span>:</p>
<blockquote>
<p>This paper reports the relationship between formal description of semantics (i.e., interpreter) of a programming language and an actual compiler. The paper also describes a method to automatically generate an actual compiler from a formal description which is, in some sense, the partial evaluation of a computation process. […]</p>
</blockquote>
<p>To <em>interpret</em> is to give meaning to a form.</p>
<p>By &quot;form&quot;, we mean symbols or representations.</p>
<p>To <em>compile</em> is to translate a form into another form with the same meaning.</p>
<p>For example, I <em>interpret</em> the English program &quot;Buy food&quot; and the Indonesian program &quot;Beli makanan&quot; as the same meaning: an order to buy food. On the other hand, I can <em>compile</em> (or <em>translate</em>) &quot;Beli makanan&quot; to &quot;Buy food&quot; for people who understand English but not Indonesian. My understanding of &quot;food&quot; is &quot;something I can eat&quot;, but my understanding of &quot;to eat&quot; is a <em>primitive</em> that is built into me by Nature, my hardware designer. Similarly, my machine only understands machine code: the primitives that are built into it by its hardware designer.</p>
<p>In principle, we only need to write <em>one</em> compiler C from language H to machine code, and then we can write many interpreters in language H, such as an S-on-H interpreter I, and get an S-compiler by partially evaluating I(P) and C-compiling the result of the partial evaluation. See also: <a href="https://en.wikipedia.org/wiki/Partial_evaluation">partial evaluation and Futamura projections</a>. See also the book <a href="http://www.itu.dk/people/sestoft/pebook/">Jones, Gomard, &amp; Sestoft 1993</a> <span class="citation" data-cites="jones1993partial">[<a href="#ref-jones1993partial">7</a>]</span>.</p>
<p>The question boils down to: What is <em>meaning</em>? What do we mean by <em>meaning</em>?</p>
<p>Meaning is determined by convention, including context; meaning is determined by pragmatics.</p>
<p>Let us use mathematics to clarify what we mean by &quot;compilers&quot; and &quot;interpreters&quot;.</p>
<p>There are three languages involved: Host H, Source S, and Target T.</p>
<p>A <em>program</em> can be thought of as a representation of a mathematical function.</p>
<p>An <em>L-program</em> is a program written in language L.</p>
<p>Note that (H,M,S,T) stands for (Host,Meaning,Source,Target).</p>
<p>An <em>(H,M,S,T)-compiler</em> C is an H-program that translates each S-program P to a T-program C(P) with the constraint M(P) = M(C(P)). The translation must preserve meaning, but does not have to be <em>invertible</em>. Almost always, we do not care about reconstructing P from C(P), except when we are reverse-engineering.</p>
<p>An <em>(H,M,S)-interpreter</em> I is an H-program that takes each S-program P and gives M(P). The result of an interpreter's interpretation of a program is then <em>interpreted</em> again by humans into meaning.</p>
<p>Both the example compiler and the example interpreter are written in the same host language H.</p>
<p>Good news from <a href="https://www.gwern.net/docs/cs/2009-gluck.pdf">Gluck 2009</a> <span class="citation" data-cites="gluck2009there">[<a href="#ref-gluck2009there">6</a>]</span>?</p>
<blockquote>
<p>Practical specializers that can perform all three Futamura projections and that can automatically convert programs into non-trivial generating extensions and compiler generators have been built for realistic programming languages such as Scheme, Prolog, and C […]</p>
</blockquote>
<p>A compiler establishes an <em>equivalence relation</em> between its source language and its target language. (If we think of a language as a set of programs.)</p>
<p>Example of a tower of languages, upwards:</p>
<ul>
<li>Semantics of L1 is defined in terms of the semantics of L0.</li>
<li>Semantics of Ln is defined in terms of the semantics of Ln-1.</li>
</ul>
<p>But if we go downwards, it is a tower of mathematical models (of a physical system):</p>
<ul>
<li>Semantics of L0 is defined in terms of logic circuit model.</li>
<li>Semantics of logic circuit model is defined in terms of the LEM (lumped element model)</li>
<li>Semantics of LEM is defined in terms of classical electromagnetism model.</li>
<li>etc.</li>
</ul>
<p>Let L0, L1, …, Ln be languages.</p>
<p>&quot;interpreter written in language L0 for language L1&quot;</p>
<p>Compiler/Translator = Program in L1 -&gt; Program in L0 Interpreter in L0 = Program in L1 -&gt; Effect in L0</p>
<p>Programming languages (model-driven languages) have hit a limit; higher abstraction levels are impossible. AI is the highest level we will go without telepathy.</p>
<p>Imagine that you have to write the first assembler for the first processor. All you have are switchboards, instruction manuals, and machine code. You want to minimize your switchboarding, so you want to write the shortest program.</p>
<p>&quot;hand-compile&quot;</p>
<h3 id="how-should-we-make-programming-tools-such-as-compilers-interpreters-and-editors"><span class="section_number">8.2</span><span class="section_title">How should we make programming tools such as compilers, interpreters, and editors?</span></h3>
<h3 id="what-meta-programming-tools-exist"><span class="section_number">8.3</span><span class="section_title">What meta-programming tools exist?</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">8.3.1</span><span class="section_title"><a href="#rascal-mpl">Rascal MPL</a></span><span class="word_count">(2w~1m)</span></li>
<li><span class="section_number">8.3.2</span><span class="section_title"><a href="#eclipse-xtext">Eclipse Xtext</a></span><span class="word_count">(2w~1m)</span></li>
<li><span class="section_number">8.3.3</span><span class="section_title"><a href="#jetbrains-mps">JetBrains MPS</a></span><span class="word_count">(121w~1m)</span></li>
</ul>
</div>
<h4 id="rascal-mpl"><span class="section_number">8.3.1</span><span class="section_title">Rascal MPL</span></h4>
<p><a href="https://www.rascal-mpl.org/">https://www.rascal-mpl.org/</a></p>
<h4 id="eclipse-xtext"><span class="section_number">8.3.2</span><span class="section_title">Eclipse Xtext</span></h4>
<h4 id="jetbrains-mps"><span class="section_number">8.3.3</span><span class="section_title">JetBrains MPS</span></h4>
<p>MPS is &quot;Meta Programming System&quot;.</p>
<p>A concept can have properties. Each property has a type. The property type system is limited to int, string, and regex-constrained string.</p>
<p>A member in a model is an <em>instance</em> of a concept, similar to how an object is an instance of a class in Java.</p>
<p>MPS is a <em>tree</em> editor, not a text editor.</p>
<p>A concept is an AST (abstract syntax tree) node type.</p>
<p>On 2017-08-12, MPS 2017.2 doesn't support Java 7 try-with-resources statements.</p>
<p>The MPS IntelliJ IDEA plugin allows you to use a language from IDEA, but not defining your own language. You need the MPS IDE for that.</p>
<p>External links:</p>
<ul>
<li><a href="https://confluence.jetbrains.com/display/MPSD20172/Using+MPS+inside+IntelliJ+IDEA">Using MPS inside IntelliJ IDEA</a></li>
<li><a href="https://confluence.jetbrains.com/pages/viewpage.action?pageId=93128576">MPS user guide for Java developers (IntelliJ IDEA)</a> (long)</li>
<li><a href="https://confluence.jetbrains.com/display/MPSD20172/Finding+your+way+out">What to do when there is a problem</a></li>
</ul>
<h3 id="meta-programming-and-language-oriented-programming"><span class="section_number">8.4</span><span class="section_title">Meta-programming and language-oriented programming?</span></h3>
<p>The Racket manifesto<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>: programming-language programming language</p>
<p>miniKanren, scheme logic programming <a href="http://minikanren.org/">http://minikanren.org/</a> <a href="https://github.com/clojure/core.logic/wiki/A-Core.logic-Primer">https://github.com/clojure/core.logic/wiki/A-Core.logic-Primer</a></p>
<p>2000 article &quot;Domain Specific Meta Languages&quot; <a href="https://www-users.cs.umn.edu/~evw/pubs/vanwyk00sac/vanwyk00sac.pdf">https://www-users.cs.umn.edu/~evw/pubs/vanwyk00sac/vanwyk00sac.pdf</a></p>
<p>1996 book &quot;Advanced programming language design&quot; 2008 article &quot;Position paper: Practical foundations for programming languages&quot; 2012 book &quot;Practical Foundations for Programming Languages&quot; Version 1.32 of 05.15.2012 <a href="http://profs.sci.univr.it/~merro/files/harper.pdf">http://profs.sci.univr.it/~merro/files/harper.pdf</a></p>
<p>University of Arizona, Spring 2006, CS 520 Principles of Programming Languages - Lecture 04: Types and Polymorphism <a href="https://www2.cs.arizona.edu/classes/cs520/spring06/04types.pdf">https://www2.cs.arizona.edu/classes/cs520/spring06/04types.pdf</a> from &quot;Lecture 4: higher polymorphism&quot; <a href="https://blog.inf.ed.ac.uk/apl16/archives/178/comment-page-1">https://blog.inf.ed.ac.uk/apl16/archives/178/comment-page-1</a></p>
<p>Programming Language Foundations in Agda <a href="https://plfa.github.io/">https://plfa.github.io/</a></p>
<p>2018 article &quot;Logic Programming as a Service&quot; <a href="https://arxiv.org/abs/1806.02577">https://arxiv.org/abs/1806.02577</a></p>
<p>Liber amicorum for Doaitse Swierstra <a href="https://www.reddit.com/r/haskell/comments/1hmc9t/pdf_liber_a_for_doaitse_swierstra_read_free/">https://www.reddit.com/r/haskell/comments/1hmc9t/pdf_liber_a_for_doaitse_swierstra_read_free/</a></p>
<p>1994 article &quot;Efficient Self-Interpretation in Lambda Calculus&quot; <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.4382&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.4382&amp;rep=rep1&amp;type=pdf</a></p>
<p>Lambda the Ultimate: Meta-programming <a href="http://lambda-the-ultimate.org/taxonomy/term/15">http://lambda-the-ultimate.org/taxonomy/term/15</a></p>
<p>2009 article &quot;Directly Reflective Meta-Programming&quot; <a href="http://homepage.divms.uiowa.edu/~astump/papers/archon.pdf">http://homepage.divms.uiowa.edu/~astump/papers/archon.pdf</a></p>
<p>Footnote F from <span class="citation" data-cites="felleisen2018programmable">[<a href="#ref-felleisen2018programmable">4</a>]</span>:</p>
<blockquote>
<p>Language workbenches (such as Spoofax) deal with conventional syntax for DSLs but do not support the incremental modification of existing languages. A 2015 report suggests, however, these tool chains are also converging toward the idea of language creation as language modification. We conjecture that, given sufficient time, development of Racket and language workbenches will converge on similar designs.</p>
</blockquote>
<h3 id="implementing-programming-languages"><span class="section_number">8.5</span><span class="section_title">Implementing programming languages</span></h3>
<h3 id="should-we-use-prolog"><span class="section_number">8.6</span><span class="section_title">Should we use Prolog?</span></h3>
<p>We should prototype our language in Prolog.</p>
<p>We should implement our language in Prolog.</p>
<ul>
<li>2004, parsing in Prolog, &quot;Parsing and Semantics in DCGs&quot; <a href="http://www.inf.ed.ac.uk/teaching/courses/aipp/lecture_slides/11_PS_DCGs.pdf">http://www.inf.ed.ac.uk/teaching/courses/aipp/lecture_slides/11_PS_DCGs.pdf</a></li>
<li>Prolog DCG (definite clause grammar) facilitates writing an attribute grammar.</li>
<li><a href="https://en.wikipedia.org/wiki/Definite_clause_grammar">https://en.wikipedia.org/wiki/Definite_clause_grammar</a></li>
</ul>
<p>Erlang started out as a DSL in Prolog. See 1992 article &quot;Use of Prolog for developing a new programming language&quot;.</p>
<p>&lt;2018-10-20&gt; Change of opinion: we should write the language in Prolog instead of Haskell.</p>
<ul>
<li>&quot;Ott is a tool for writing definitions of programming languages and calculi. It takes as input a definition of a language syntax and semantics, in a concise and readable ASCII notation that is close to what one would write in informal mathematics.&quot; <a href="https://www.cl.cam.ac.uk/~pes20/ott/">https://www.cl.cam.ac.uk/~pes20/ott/</a></li>
</ul>
<p>&lt;2018-12-11&gt; My current answer: Prolog.</p>
<p>My previous answers:</p>
<ul>
<li>Haskell</li>
<li>Racket</li>
<li>Scheme</li>
<li>Java</li>
<li>C</li>
<li>C++</li>
</ul>
<p>Other people?</p>
<ul>
<li><a href="https://hackernoon.com/the-programming-language-im-looking-for-948d93f7a396">https://hackernoon.com/the-programming-language-im-looking-for-948d93f7a396</a></li>
</ul>
<h3 id="write-abstract-interpreters-not-compilers"><span class="section_number">8.7</span><span class="section_title">Write abstract interpreters, not compilers?</span></h3>
<p>&lt;2018-12-30&gt;</p>
<p>The same code fragment can be interpreted in several ways.</p>
<p>The most common interpreter executes the program with the intended semantics. Example: a Python interpreter interprets the Python program &quot;print 'foo'&quot; as printing the string.</p>
<p>Write an abstract interpreter that emits code when interpreting. An interpreter that interprets the Python program &quot;print 'foo'&quot; as &quot;emit a Ruby statement that prints 'foo' to screen when executed&quot;.</p>
<h3 id="begin-with-an-interpreter-not-a-compiler"><span class="section_number">8.8</span><span class="section_title">Begin with an interpreter, not a compiler</span></h3>
<ul>
<li>Don't make a compiler? Make an interpreter instead, and stage it? Turn an interpreter into a compiler for free?</li>
<li>&quot;To stage an interpreter&quot; is to add staging annotations to the code of the interpreter.</li>
<li>Staging is similar to quoting in Lisp/Scheme.</li>
<li>2004 article &quot;A Gentle Introduction to Multi-stage Programming&quot; <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.103.2543&amp;rep=rep1&amp;type=pdf">pdf</a>
<ul>
<li>Basic Problems in Building Program Generators</li>
<li>part 2 <a href="https://pdfs.semanticscholar.org/aa3c/d4233f7c0db95e5c38d5b8fc1d199df21857.pdf">https://pdfs.semanticscholar.org/aa3c/d4233f7c0db95e5c38d5b8fc1d199df21857.pdf</a></li>
</ul></li>
<li>multi-stage programming for Scala <a href="https://scala-lms.github.io/">https://scala-lms.github.io/</a></li>
<li>2006 article &quot;A Verified Staged Interpreter is a Verified Compiler&quot; <a href="https://www.researchgate.net/profile/Kevin_Hammond/publication/221108683_A_verified_staged_interpreter_is_a_verified_compiler/links/00b7d517ede725c057000000.pdf">pdf</a></li>
</ul>
<h3 id="making-compilers"><span class="section_number">8.9</span><span class="section_title">Making compilers?</span></h3>
<p>Every compiler does name resolution / symbol table. Is there a compiler that doesn't do that? <a href="https://www.reddit.com/r/Forth/comments/695oik/advances_in_forth_language_design/dh454oq/">Forth?</a></p>
<ul>
<li><a href="https://www.reddit.com/r/haskell/comments/4jhhrj/anders_hejlsberg_on_modern_compiler_construction/">https://www.reddit.com/r/haskell/comments/4jhhrj/anders_hejlsberg_on_modern_compiler_construction/</a></li>
<li><a href="https://cs.stackexchange.com/questions/63018/visual-programming-tools-why-don-t-they-work-with-the-ast-directly">https://cs.stackexchange.com/questions/63018/visual-programming-tools-why-don-t-they-work-with-the-ast-directly</a></li>
<li><p>compiling with continuations</p>
<ul>
<li><p>Why use CPS (continuation passing style) as intermediate form?</p>
<ul>
<li><a href="http://matt.might.net/articles/cps-conversion/">http://matt.might.net/articles/cps-conversion/</a></li>
<li><a href="https://www.microsoft.com/en-us/research/publication/compiling-with-continuations-continued/">https://www.microsoft.com/en-us/research/publication/compiling-with-continuations-continued/</a></li>
<li><a href="https://news.ycombinator.com/item?id=7150095">https://news.ycombinator.com/item?id=7150095</a></li>
</ul></li>
<li><p>2003, retrospective: the essence of compiling with continuations <a href="https://users.soe.ucsc.edu/~cormac/papers/best-pldi.pdf">https://users.soe.ucsc.edu/~cormac/papers/best-pldi.pdf</a></p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/A-normal_form">https://en.wikipedia.org/wiki/A-normal_form</a></li>
</ul></li>
</ul></li>
</ul>
<h3 id="piggybacking-a-host-language"><span class="section_number">8.10</span><span class="section_title">Piggybacking a host language</span></h3>
<h3 id="how-should-lambda-calculus-be-implemented"><span class="section_number">8.11</span><span class="section_title">How should lambda-calculus be implemented?</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">8.11.1</span><span class="section_title"><a href="#what-is-an-operational-semantics-of-lambda-calculus">What is an operational semantics of lambda calculus?</a></span><span class="word_count">(8w~1m)</span></li>
<li><span class="section_number">8.11.2</span><span class="section_title"><a href="#how">How?</a></span><span class="word_count">(97w~1m)</span></li>
</ul>
</div>
<h4 id="what-is-an-operational-semantics-of-lambda-calculus"><span class="section_number">8.11.1</span><span class="section_title">What is an operational semantics of lambda calculus?</span></h4>
<h4 id="how"><span class="section_number">8.11.2</span><span class="section_title">How?</span></h4>
<p>Normal-order reduction enables us to write fixed points. Should we let the programmer choose the evaluation strategy? Currying simplifies reasoning but complicates implementation (because applications may then nest deeply to the left). What is optimal reduction?<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a><a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
<p>Lambda-calculus is unsound.<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> What does that imply about programming languages containing lambda calculus?</p>
<p>Let <span class="math inline">\( A[B := C] \)</span> mean <span class="math inline">\(A\)</span> but with each free occurrence of <span class="math inline">\(B\)</span> replaced with <span class="math inline">\(C\)</span>. Let <span class="math inline">\( eval(A,B) \)</span> means that <span class="math inline">\(A\)</span> normalizes to <span class="math inline">\(B\)</span>.</p>
<p>Applicative-order evaluation is the easiest to implement.</p>
<p>Where do these things fit in the big picture of lambda-calculus implementations? G-machine, STG, GRIN<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>.</p>
<p>Reading queue:</p>
<ul>
<li><a href="https://stackoverflow.com/questions/31223539/is-it-possible-to-evaluate-lambda-calculus-terms-efficiently">https://stackoverflow.com/questions/31223539/is-it-possible-to-evaluate-lambda-calculus-terms-efficiently</a></li>
<li><a href="https://www.researchgate.net/publication/312462365_About_the_efficient_reduction_of_lambda_terms">https://www.researchgate.net/publication/312462365_About_the_efficient_reduction_of_lambda_terms</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/2zqtfk/why_isnt_anyone_talking_about_optimal_lambda/">https://www.reddit.com/r/haskell/comments/2zqtfk/why_isnt_anyone_talking_about_optimal_lambda/</a></li>
<li>compiling monads <a href="https://www.irif.fr/~mellies/mpri/mpri-ens/articles/danvy-koslowski-malmkjaer-compiling-monads.pdf">https://www.irif.fr/~mellies/mpri/mpri-ens/articles/danvy-koslowski-malmkjaer-compiling-monads.pdf</a></li>
<li>modular monadic semantics <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.136.1656&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.136.1656&amp;rep=rep1&amp;type=pdf</a></li>
</ul>
<h2 id="all-programming-is-maintenance"><span class="section_number">9</span><span class="section_title">All programming is maintenance?</span></h2>
<p>A point of view: All programming can be thought of as modifying an existing program. The act of creating a new program can be thought of as <em>modifying the empty program</em>.</p>
<h2 id="bibliography" class="unnumbered"><span class="section_number">10</span><span class="section_title">Bibliography</span></h2>
<div id="refs" class="references">
<div id="ref-appel1987garbage">
<p>[1] Appel, A.W. 1987. Garbage collection can be faster than stack allocation. <em>Information Processing Letters</em>. 25, 4 (1987), 275–279.</p>
</div>
<div id="ref-belikov2015language">
<p>[2] Belikov, E. 2015. Language run-time systems: An overview. <em>2015 imperial college computing student workshop (iccsw 2015)</em> (2015).</p>
</div>
<div id="ref-crary1999talx86">
<p>[3] Crary, K. et al. 1999. TALx86: A realistic typed assembly language. <em>1999 acm sigplan workshop on compiler support for system software atlanta, ga, usa</em> (1999), 25–35.</p>
</div>
<div id="ref-felleisen2018programmable">
<p>[4] Felleisen, M. et al. 2018. A programmable programming language. <em>Commun. ACM</em>. 61, 3 (Feb. 2018), 62–71. DOI:<a href="https://doi.org/10.1145/3127323">https://doi.org/10.1145/3127323</a>. url: &lt;<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/fffkbmt-programmable-prog-lang/paper.pdf">https://cs.brown.edu/~sk/Publications/Papers/Published/fffkbmt-programmable-prog-lang/paper.pdf</a>&gt;.</p>
</div>
<div id="ref-futamura1999partial">
<p>[5] Futamura, Y. 1999. Partial evaluation of computation process–an approach to a compiler-compiler. <em>Higher-Order and Symbolic Computation</em>. 12, 4 (1999), 381–391.</p>
</div>
<div id="ref-gluck2009there">
<p>[6] Glück, R. 2009. Is there a fourth futamura projection? <em>Proceedings of the 2009 acm sigplan workshop on partial evaluation and program manipulation</em> (2009), 51–60.</p>
</div>
<div id="ref-jones1993partial">
<p>[7] Jones, N.D. et al. 1993. <em>Partial evaluation and automatic program generation</em>. Peter Sestoft. url: &lt;<a href="http://www.itu.dk/~sestoft/pebook/jonesgomardsestoft-a4.pdf">http://www.itu.dk/~sestoft/pebook/jonesgomardsestoft-a4.pdf</a>&gt;.</p>
</div>
<div id="ref-McCarthy1959RecursiveFO">
<p>[8] McCarthy, J. 1959. Recursive functions of symbolic expressions and their computation by machine, part i. <em>Commun. ACM</em>. 3, (1959), 184–195.</p>
</div>
<div id="ref-van2004concepts">
<p>[9] Van-Roy, P. and Haridi, S. 2004. <em>Concepts, techniques, and models of computer programming</em>. MIT press.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>via <a href="https://softwareengineering.stackexchange.com/questions/364371/type-based-memory-safety-without-manual-memory-manage-or-runtime-garbage-collect">Basile Starynkevitch</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>&lt;2019-11-04&gt; <a href="https://www.cis.upenn.edu/~stevez/papers/MCGG99.pdf">https://www.cis.upenn.edu/~stevez/papers/MCGG99.pdf</a><a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><a href="http://felleisen.org/matthias/manifesto/index.html">http://felleisen.org/matthias/manifesto/index.html</a><a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><a href="https://stackoverflow.com/questions/31223539/is-it-possible-to-evaluate-lambda-calculus-terms-efficiently">https://stackoverflow.com/questions/31223539/is-it-possible-to-evaluate-lambda-calculus-terms-efficiently</a><a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><a href="https://en.wikipedia.org/wiki/Lambda_calculus#Optimal_reduction">https://en.wikipedia.org/wiki/Lambda_calculus#Optimal_reduction</a><a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">https://en.wikipedia.org/wiki/Fixed-point_combinator</a><a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p><a href="https://github.com/grin-tech/grin">https://github.com/grin-tech/grin</a><a href="#fnref7" class="footnote-back">↩</a></p></li>
</ol>
</section>
                </div>
            </div>
        </main>
        <footer class="site-footer h-card">
            <data class="u-url" href="/"></data>
            <div class="wrapper">
                <p>This page was created on 2019-02-07 00:00:00 +0700.</p>
                <p class="rss-subscribe">The
                    <a href="/feed.xml">RSS feed</a> of this website has not been implemented.</p>
                <p>
                    I used Disqus, but I removed it because it hijacks my links and redirects them to third-party ad networks.
                    On 2019-05-27, a friend of mine reported that links on my website were broken,
                    and I caught Disqus red-handed redirecting my links to pwieu.com.
                </p>
            </div>
        </footer>
    </body>
</html>
