<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Haskell programming language</title>
        <link rel="stylesheet" href="/assets/main.css"/>
        <script>
// Help the reader estimate how much time the reading is going to take.
// Show word count and reading time estimation in TOC entry.
//
// TOC = table of contents
//
// Known issue: This janks: this DOM manipulation is done after the page is rendered.
// If we don't want jank, we have to manipulate the HTML source before it reaches the browser.
// We assume that the user doesn't refresh the page while reading.
// The benefit of fixing that jank is not enough for me to justify trying to fix it.
document.addEventListener("DOMContentLoaded", function () {
    function count_word (string) {
        return string.trim().split(/\s+/).length;
    }
    function show_quantity (count, singular) {
        let plural = singular + "s"; // For this script only.
        return count + " " + ((count == 1) ? singular : plural);
    }
    function create_length_indicator (word, minute) {
        let e = document.createElement("span");
        e.className = "toc_entry__length_indicator";
        e.textContent = " (" + show_quantity(word, "word") + " ~ " + show_quantity(minute, "minute") + ")";
        return e;
    }
    // We assume that readers read this many words per minute with 100% comprehension.
    // This assumption may not hold for dense texts such as philosophy and mathematics.
    const wpm_assumption = 200;
    // We assume a certain Jekyll template.
    let page = document.querySelector("main.page-content");
    if (page === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"main.page-content\" does not match anything");
        return;
    }
    let page_title = document.querySelector("header.post-header h1.post-title");
    if (page_title === null) {
        console.log("toc_generate_estimate: Impossible: CSS selector \"header.post-header h1.post-title\" does not match anything");
        return;
    }
    let page_word = count_word(page.textContent);
    let page_minute = Math.ceil(page_word / wpm_assumption);
    page_title.insertAdjacentElement("afterend", create_length_indicator(page_word, page_minute));
    // We violate the HTML specification.
    // The page may have several elements with the same ID.
    // We assume that Org HTML Export generates a DIV element with ID "table-of-contents".
    // We assume that Jekyll Markdown-to-HTML generates a UL element with ID "markdown-toc".
    // This only works for Org HTML Export's TOC.
    let toc_entries = document.querySelectorAll("#table-of-contents a, #text-table-of-contents a");
    toc_entries.forEach((toc_entry_a) => {
        let href = toc_entry_a.getAttribute("href"); // We assume that this is a string like "#org0123456".
        if (href.charAt(0) !== '#') {
            console.log("toc_generate_estimate: Impossible: " + href + " does not begin with hash sign");
            return;
        }
        // We can't just document.querySelector(href) because target_id may contain invalid ID characters such as periods.
        let target_id = href.substring(1);
        let id_escaped = target_id.replace("\"", "\\\"");
        let h_elem = document.querySelector("[id=\"" + id_escaped + "\"]"); // We assume that this is the h1/h2/h3 element referred by the TOC entry.
        if (h_elem === null) { // We assume that this is impossible.
            console.log("toc_generate_estimate: Impossible: " + href + " does not refer to anything");
            return;
        }
        let section = h_elem.parentNode;
        let section_word = count_word(section.textContent);
        let section_minute = Math.ceil(section_word / wpm_assumption);
        toc_entry_a.insertAdjacentElement("afterend", create_length_indicator(section_word, section_minute));
    });
});
        </script>

        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12628443-6"></script>
<script>
  window['ga-disable-UA-12628443-6'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-12628443-6');
</script>
        
        <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            jax: ["input/TeX","input/MathML","input/AsciiMath",
            "output/CommonHTML"
            ],
            extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "a11y/accessibility-menu.js"],
            TeX: {
                extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
                , equationNumbers: {
                    autoNumber: "AMS"
                }
            },
            "CommonHTML": {
                scale: 100
            },
            "fast-preview": {
                disabled: true,
            }
        });
        </script>
        <style>
            /*
            PreviewHTML produces small Times New Roman text.
            PreviewHTML scale doesn't work.
            */
            .MathJax_PHTML { font-size: 110%; }
        </style>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js" async defer></script>
    </head>
    <body>
        <header class="site-header" role="banner">
            <div class="wrapper">
                <a class="site-title" rel="author" href="/">Erik Dominikus Research Group</a>
            </div>
        </header>
    <div style="display:none;">\(
    \renewcommand\emptyset{\varnothing}
    \newcommand\abs[1]{\left|#1\right|}
    \newcommand\dom{\textrm{dom}}
    \newcommand\cod{\textrm{cod}}
    \newcommand\Bernoulli{\textrm{Bernoulli}}
    \newcommand\Binomial{\textrm{Binomial}}
    \newcommand\Expect[1]{\mathbb{E}[#1]}
    \newcommand\Nat{\mathbb{N}}
    \newcommand\Integers{\mathbb{Z}}
    \newcommand\Real{\mathbb{R}}
    \newcommand\Rational{\mathbb{Q}}
    \newcommand\Complex{\mathbb{C}}
    \newcommand\Pr{\mathrm{P}}
    \newcommand\Time{\text{Time}}
    \newcommand\DTime{\text{DTime}}
    \newcommand\NTime{\text{NTime}}
    \newcommand\TimeP{\text{P}}
    \newcommand\TimeNP{\text{NP}}
    \newcommand\TimeExp{\text{ExpTime}}
    \newcommand\norm[1]{\left\lVert#1\right\rVert}
    \newcommand\bbA{\mathbb{A}}
    \newcommand\bbC{\mathbb{C}}
    \newcommand\bbD{\mathbb{D}}
    \newcommand\bbE{\mathbb{E}}
    \newcommand\bbN{\mathbb{N}}
    \newcommand\frakI{\mathfrak{I}}
    % deprecated; use TimeExp
    \newcommand\ExpTime{\text{ExpTime}}
    \newcommand\Compute{\text{Compute}}
    \newcommand\Search{\text{Search}}
    % model theory structure
    \newcommand\struc[1]{\mathcal{#1}}
    \)</div>
        <main class="page-content" aria-label="Content">
            <div class="wrapper">
                <article class="post">
                    <header class="post-header">
                        <h1 class="post-title">Haskell programming language</h1>
                    </header>
                </article>
                <div class="post-content">
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1</span><span class="section_title"><a href="#abdullah">Subtyping in Haskell with canonical injections</a></span><span class="word_count">(1203w~7m)</span></li>
<li><span class="section_number">2</span><span class="section_title"><a href="#interpreting-haskell-without-types-a-strong-temptation">Interpreting Haskell without types: a strong temptation</a></span><span class="word_count">(282w~2m)</span></li>
<li><span class="section_number">3</span><span class="section_title"><a href="#a-set-theoretic-programming-language">A set-theoretic programming language?</a></span><span class="word_count">(923w~5m)</span></li>
<li><span class="section_number">4</span><span class="section_title"><a href="#a-mess-do-not-see">A mess; do not see</a></span><span class="word_count">(611w~4m)</span></li>
</ul>
</div>
<h2 id="abdullah"><span class="section_number">1</span><span class="section_title">Subtyping in Haskell with canonical injections</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.1</span><span class="section_title"><a href="#background">Background</a></span><span class="word_count">(134w~1m)</span></li>
<li><span class="section_number">1.2</span><span class="section_title"><a href="#what-is-here-and-how-it-answers-your-questions">What is here, and how it answers your questions</a></span><span class="word_count">(110w~1m)</span></li>
<li><span class="section_number">1.3</span><span class="section_title"><a href="#notation">[NOTATION]</a></span><span class="word_count">(49w~1m)</span></li>
<li><span class="section_number">1.4</span><span class="section_title"><a href="#define-examples-of-canonical-injections">[DEFINE] Examples of canonical injections</a></span><span class="word_count">(89w~1m)</span></li>
<li><span class="section_number">1.5</span><span class="section_title"><a href="#data-inferring-canonical-injections-for-inductive-data-types">[DATA] Inferring canonical injections for inductive data types</a></span><span class="word_count">(114w~1m)</span></li>
<li><span class="section_number">1.6</span><span class="section_title"><a href="#monad-relationship-between-canonical-injections-and-monad-instances">[MONAD] Relationship between canonical injections and Monad instances</a></span><span class="word_count">(182w~1m)</span></li>
<li><span class="section_number">1.7</span><span class="section_title"><a href="#hickey-hickeys-two-wishes">[HICKEY] Hickey's two wishes</a></span><span class="word_count">(79w~1m)</span></li>
<li><span class="section_number">1.8</span><span class="section_title"><a href="#lambda-inferring-canonical-injections-for-lambdas">[LAMBDA] Inferring canonical injections for lambdas</a></span><span class="word_count">(71w~1m)</span></li>
<li><span class="section_number">1.9</span><span class="section_title"><a href="#impl-a-possible-implementation-in-principle">[IMPL] A possible implementation, in principle</a></span><span class="word_count">(104w~1m)</span></li>
<li><span class="section_number">1.10</span><span class="section_title"><a href="#history">History</a></span><span class="word_count">(134w~1m)</span></li>
<li><span class="section_number">1.11</span><span class="section_title"><a href="#half-baked-but-related-ideas-should-be-in-the-article">Half-baked but related ideas, should be in the article</a></span><span class="word_count">(142w~1m)</span></li>
</ul>
</div>
<h3 id="background"><span class="section_number">1.1</span><span class="section_title">Background</span></h3>
<p>In Haskell, Just is the <em>only</em> sound way to make a Maybe t from t. We call such unambiguous construction a <em>canonical injection</em>. The compiler should insert canonical injections to recover from trivial type errors. Such recovery has these interesting benefits:</p>
<ul>
<li>Now we can fake non-overlapping <em>untagged unions</em> (Haskell has tagged unions). This reduces the bureaucracy when composing data types following the free-monad/interpreter pattern; the compiler inserts the required Pure constructors.</li>
<li>Now we can fake <em>equirecursive types</em> (Haskell has isorecursive types). We no longer have to type &quot;In&quot; and &quot;out&quot; when using &quot;Fix&quot;; the compiler inserts the required bureaucracy.</li>
<li>Now we can fake <em>heterogeneous lists</em> and heterogeneous collections.</li>
<li>Now we can have <em>covariant</em> return type and <em>contravariant</em> return type. This means now we can, without breaking callers, generalize an argument or specialize a return value, as in Java.</li>
</ul>
<h3 id="what-is-here-and-how-it-answers-your-questions"><span class="section_number">1.2</span><span class="section_title">What is here, and how it answers your questions</span></h3>
<p>This is what I am going to do in this article, in no particular order:</p>
<ul>
<li>[NOTATION] defines some notations.</li>
<li>[DEFINE] defines canonical injections.</li>
<li>[DATA] shows the rules for inferring canonical injections for inductive data types.</li>
<li>[LAMBDA] shows the rules for inferring canonical injections for lambdas.</li>
<li>[HICKEY] shows that Hickey's two wishes are special cases of canonical injections.</li>
<li>[MONAD] shows the relationship between canonical injections and Monad instances.</li>
<li>[IMPL] sketches a possible implementation, in principle.</li>
</ul>
<p>This is how I answer your questions:</p>
<ul>
<li>Your first question is answered by [DEFINE], [DATA], and [LAMBDA].</li>
<li>Your second question is answered by [HICKEY] and [LAMBDA].</li>
<li>Extra things that may be of interest to you are [MONAD] and [IMPL].</li>
</ul>
<h3 id="notation"><span class="section_number">1.3</span><span class="section_title">[NOTATION]</span></h3>
<p>Notation conventions.</p>
<p>By &quot;injection&quot;, I mean an injective function.</p>
<p>&quot;The canonical injection from A to B&quot; means &quot;the only sound injection from A to B&quot;. By &quot;sound&quot;, I mean &quot;not involving bottom (undefined)&quot;. I assume total functional programming, and I say &quot;the only possible injection&quot; to mean &quot;the only sound injection&quot;.</p>
<h3 id="define-examples-of-canonical-injections"><span class="section_number">1.4</span><span class="section_title">[DEFINE] Examples of canonical injections</span></h3>
<p>&quot;Canonical&quot; means &quot;there is exactly one&quot;. &quot;Injection&quot; means injective function. A canonical injection from A to B is the only injection from A to B.</p>
<p>Examples of canonical injections:</p>
<ul>
<li>In the case of t -&gt; Maybe t, Just is the canonical injection.</li>
<li>In the case of a -&gt; Either a b where a != b, Left is the canonical injection.</li>
<li>In the case of a -&gt; Either a a, each of Left and Right is an injection, so there is no canonical injection here.</li>
</ul>
<p>Thus some constructors are canonical injections.</p>
<h3 id="data-inferring-canonical-injections-for-inductive-data-types"><span class="section_number">1.5</span><span class="section_title">[DATA] Inferring canonical injections for inductive data types</span></h3>
<p>In general, the compiler infers canonical injections from a data definition using this rule: If parameter p occurs exactly once in the right-hand side of the equal sign in &quot;data A p = …&quot;, then the only constructor with p is the <em>canonical injection</em> from p to A p.</p>
<p>For example, observe that, in the following definition, in the right-hand side of the equal sign:</p>
<ul>
<li>Int occurs twice,</li>
<li>String occurs once, and</li>
<li>p occurs once.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">A</span> p <span class="fu">=</span> <span class="dt">A0</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">A1</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">A2</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">A3</span> p</a></code></pre></div>
<p>Therefore, from the above definition, the compiler infers that:</p>
<ul>
<li>A1 : String -&gt; A p is the canonical injection from String to A p.</li>
<li>A3 : p -&gt; A p is the canonical injection from p to A p.</li>
</ul>
<h3 id="monad-relationship-between-canonical-injections-and-monad-instances"><span class="section_number">1.6</span><span class="section_title">[MONAD] Relationship between canonical injections and Monad instances</span></h3>
<p>Let INJ be the canonical injection from p to F p. Let F be an instance of Monad. Then the compiler infers &quot;return&quot; and one case of &quot;bind&quot; as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">return</span> <span class="fu">=</span> <span class="dt">INJ</span></a>
<a class="sourceLine" id="cb2-2" title="2">(<span class="fu">&gt;&gt;=</span>) (<span class="dt">INJ</span> x) k <span class="fu">=</span> k x</a></code></pre></div>
<p>Indeed I think these have to be laws: If INJ is the canonical injection from t to F t, and F is an instance of Monad, then:</p>
<ul>
<li>return has to be equal to INJ,</li>
<li>INJ x &gt;&gt;= k must be equal to k x.</li>
</ul>
<p>I think the above laws relate this concept of &quot;canonical injections&quot; with your concept of monads as &quot;conservative extensions of spaces&quot;.</p>
<p>There is also a law for the other way around: the <code>return</code> function must be an injection, although the user is responsible for ensuring that. I think the compiler should assume that <code>return</code> <em>is</em> a canonical injection, and exploit such injection with this rule: If an <code>x : t</code> is found where an <code>f t</code> is expected, and <code>f</code> is an instance of <code>Monad</code>, then replace <code>x : t</code> with <code>return x : f t</code>.</p>
<p>This rule also works in a nested situation. This should typecheck:</p>
<pre class="example"><code>0 :: (Monad m, Monad n) =&gt; m (Maybe (n Int))
</code></pre>
<h3 id="hickey-hickeys-two-wishes"><span class="section_number">1.7</span><span class="section_title">[HICKEY] Hickey's two wishes</span></h3>
<p>Yes, my rule should work in both of Hickey's cases, because there is a canonical injection in each of those cases. Note that Hickey's cases correspond to wanting the compiler to automatically apply these canonical injections:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="co">-- inj : today -&gt; yesterday,</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">-- so that every caller doesn&#39;t have to be rewritten.</span></a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">-- Making an arg optional:</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">-- yesterday:       X -&gt; Y</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co">-- today:     Maybe X -&gt; Y</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">-- The canonical injection:</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co">-- Wherever you see that a Maybe X -&gt; Y is supplied</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="co">-- where an X -&gt; Y is required, use this:</span></a>
<a class="sourceLine" id="cb4-10" title="10">inj <span class="fu">:</span> (<span class="dt">Maybe</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Y</span>) <span class="ot">-&gt;</span> (<span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Y</span>)</a>
<a class="sourceLine" id="cb4-11" title="11">inj f <span class="fu">=</span> \ x <span class="ot">-&gt;</span> f (<span class="dt">Just</span> x)</a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="co">-- Providing a stronger return promise:</span></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co">-- yesterday: X -&gt; Maybe Y</span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="co">-- today:     X -&gt; Y</span></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="co">-- The canonical injection:</span></a>
<a class="sourceLine" id="cb4-17" title="17"><span class="co">-- Wherever you see that an X -&gt; Y is supplied</span></a>
<a class="sourceLine" id="cb4-18" title="18"><span class="co">-- where an X -&gt; Maybe Y is required, use this:</span></a>
<a class="sourceLine" id="cb4-19" title="19">inj <span class="fu">:</span> (<span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Y</span>) <span class="ot">-&gt;</span> (<span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Y</span>)</a>
<a class="sourceLine" id="cb4-20" title="20">inj f <span class="fu">=</span> \ x <span class="ot">-&gt;</span> <span class="dt">Just</span> (f x)</a></code></pre></div>
<p>Note that the type of inj is &quot;today -&gt; yesterday&quot;, not &quot;yesterday -&gt; today&quot;. (Do you see why?)</p>
<p>Our rewriting the function changes its type from &quot;yesterday&quot; to &quot;today&quot;, but the unchanged callers still expect that the function has the type &quot;yesterday&quot;.</p>
<h3 id="lambda-inferring-canonical-injections-for-lambdas"><span class="section_number">1.8</span><span class="section_title">[LAMBDA] Inferring canonical injections for lambdas</span></h3>
<p>Here I generalize Hickey's cases to all lambdas.</p>
<p>Notation convention: I write the dependently-typed expression &quot;inj A B&quot; to mean the canonical injection from A to B, if such canonical injection exists. The type of the expression &quot;inj A B&quot; is A -&gt; B.</p>
<p>These two rules define canonical injections for all lambdas: For all types A, B, and C:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">inj (<span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">C</span>) (<span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">C</span>) fac <span class="fu">=</span> fbc <span class="kw">where</span> fbc b <span class="fu">=</span> fac (inj <span class="dt">B</span> <span class="dt">A</span> b)</a>
<a class="sourceLine" id="cb5-2" title="2">inj (<span class="dt">C</span> <span class="ot">-&gt;</span> <span class="dt">A</span>) (<span class="dt">C</span> <span class="ot">-&gt;</span> <span class="dt">B</span>) fca <span class="fu">=</span> fcb <span class="kw">where</span> fcb c <span class="fu">=</span> inj <span class="dt">A</span> <span class="dt">B</span> (fca c)</a></code></pre></div>
<p>That should also work with currying and higher-order lambdas.</p>
<h3 id="impl-a-possible-implementation-in-principle"><span class="section_number">1.9</span><span class="section_title">[IMPL] A possible implementation, in principle</span></h3>
<p>Suppose that a compiler encounters a type error.</p>
<p>Let s : S be the supplied (actual) expression and type (what the user actually types).</p>
<p>Let R be the required (expected) type.</p>
<p>Then, if there is the canonical injection inj : S -&gt; R from S to R, the compiler should behave as if the user had typed &quot;inj s&quot; from the beginning.</p>
<p>In principle, it is possible to write a Haskell interpreter in Prolog, and add our own inference rules, such as inferring canonical injections and inserting canonical injections. I think [DATA] and [LAMBDA] sufficiently define canonical injections for all Haskell 98 types.</p>
<h3 id="history"><span class="section_number">1.10</span><span class="section_title">History</span></h3>
<p>This originated as a letter to Abdullah on &lt;2018-12-18&gt;.</p>
<p>&lt;2018-12-18&gt;</p>
<ul>
<li>First publish date.</li>
<li>First revision.</li>
</ul>
<p>Alternative titles:</p>
<ul>
<li>Faking untagged unions and equirecursive types in Haskell
<ul>
<li>This sounds promising.</li>
<li>But this is misleading. This feature requires modifying the compiler, so the code is not &quot;in Haskell&quot;.</li>
</ul></li>
<li>Inferring and inserting canonical injections in Haskell
<ul>
<li>This was the original working title.</li>
</ul></li>
<li>Recovering from trivial type errors in Haskell
<ul>
<li>Unclear about what is being sold.</li>
</ul></li>
<li>A monad is a way of conservatively extending all spaces</li>
</ul>
<p>The concept I'm proposing already exists with the same name (&quot;canonical injection&quot;). <a href="https://en.wikipedia.org/wiki/Inclusion_map">https://en.wikipedia.org/wiki/Inclusion_map</a></p>
<p>&lt;2018-12-14&gt;</p>
<p>Questions leading to this article:</p>
<ul>
<li>Does &quot;algebraic subtyping&quot; mean adding the following rule to the compiler: &quot;for all x, t: everywhere an x : t is found where a Maybe t is expected, replace x : t with Just x : Maybe t&quot;?</li>
<li>Does &quot;algebraic subtyping&quot; mean that the compiler &quot;recovers&quot; from certain (injective) type errors?</li>
</ul>
<h3 id="half-baked-but-related-ideas-should-be-in-the-article"><span class="section_number">1.11</span><span class="section_title">Half-baked but related ideas, should be in the article</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">1.11.1</span><span class="section_title"><a href="#a-subtyping-relation-arises-from-canonical-injections">A subtyping relation arises from canonical injections</a></span><span class="word_count">(70w~1m)</span></li>
<li><span class="section_number">1.11.2</span><span class="section_title"><a href="#subtyping-in-haskell">Subtyping in Haskell?</a></span><span class="word_count">(27w~1m)</span></li>
<li><span class="section_number">1.11.3</span><span class="section_title"><a href="#a-weak-anthropocentric-argument-for-automating-canonical-injections">A weak anthropocentric argument for automating canonical injections?</a></span><span class="word_count">(34w~1m)</span></li>
<li><span class="section_number">1.11.4</span><span class="section_title"><a href="#newtypes-should-be-replaced-with-proofs.">Newtypes should be replaced with <em>proofs</em>.</a></span><span class="word_count">(6w~1m)</span></li>
</ul>
</div>
<h4 id="a-subtyping-relation-arises-from-canonical-injections"><span class="section_number">1.11.1</span><span class="section_title">A subtyping relation arises from canonical injections</span></h4>
<p>Remember:</p>
<ul>
<li>&quot;A is a subtype of B&quot; means an A can be supplied wherever a B is expected.</li>
<li>The existence of a canonical injection from A to B suggests that A is a &quot;subset of&quot; (&quot;is contained in&quot;) B.</li>
</ul>
<p>We can define this subtyping relation: A is a subtype B iff there is a canonical injection from A to B.</p>
<p>Subtyping by canonical injection obeys Liskov substitution principle.</p>
<h4 id="subtyping-in-haskell"><span class="section_number">1.11.2</span><span class="section_title">Subtyping in Haskell?</span></h4>
<ul>
<li><a href="http://referaat.cs.utwente.nl/conference/12/paper/7000/expressing-ontologies-using-a-functional-language.pdf">http://referaat.cs.utwente.nl/conference/12/paper/7000/expressing-ontologies-using-a-functional-language.pdf</a>
<ul>
<li>&quot;there are some proposals for implementing subtyping [in Haskell] [11, 12]&quot;
<ul>
<li>Open ADT precludes exhaustive pattern matching.</li>
</ul></li>
</ul></li>
</ul>
<p>TODO summarize:</p>
<ul>
<li><a href="https://mail.haskell.org/pipermail/haskell-cafe/2007-May/026334.html">https://mail.haskell.org/pipermail/haskell-cafe/2007-May/026334.html</a></li>
<li>&quot;Polymorphic subtyping in O'Haskell&quot; <a href="https://www.sciencedirect.com/science/article/pii/S0167642302000266">https://www.sciencedirect.com/science/article/pii/S0167642302000266</a></li>
<li>&quot;Subtype polymorphism in Haskell&quot; <a href="https://stackoverflow.com/questions/12002979/subtype-polymorphism-in-haskell">https://stackoverflow.com/questions/12002979/subtype-polymorphism-in-haskell</a></li>
</ul>
<h4 id="a-weak-anthropocentric-argument-for-automating-canonical-injections"><span class="section_number">1.11.3</span><span class="section_title">A weak anthropocentric argument for automating canonical injections?</span></h4>
<p>We should conflate <code>x</code> and <code>Just x</code>. <code>Just</code> is there only to make the compiler happy. For us humans, <code>x</code> and <code>Just x</code> have the same semantics.</p>
<h4 id="newtypes-should-be-replaced-with-proofs."><span class="section_number">1.11.4</span><span class="section_title">Newtypes should be replaced with <em>proofs</em>.</span></h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="co">-- Replace this:</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ot">foo ::</span> <span class="dt">Nonneg</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">-- with this, where _p is a proof that x is nonnegative:</span></a>
<a class="sourceLine" id="cb6-4" title="4">foo {_p <span class="fu">:</span> x <span class="fu">&gt;=</span> <span class="dv">0</span>} x <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<h2 id="interpreting-haskell-without-types-a-strong-temptation"><span class="section_number">2</span><span class="section_title">Interpreting Haskell without types: a strong temptation</span></h2>
<p>Suppose that we are writing a Haskell interpreter in Prolog, but we are too lazy to check the types, so we simply ignore all type annotations. Let's call the language HWOT (Haskell WithOut Types), pronounced like &quot;what&quot;. What do we have then? A normal-order beta-reducer/term-rewriter? Something like the Pure language<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>?</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">2.1</span><span class="section_title"><a href="#the-temptation-is-strong">The temptation is strong</a></span><span class="word_count">(217w~2m)</span></li>
<li><span class="section_number">2.2</span><span class="section_title"><a href="#compiling-hwot-to-haskell">Compiling HWOT to Haskell?</a></span><span class="word_count">(11w~1m)</span></li>
</ul>
</div>
<h3 id="the-temptation-is-strong"><span class="section_number">2.1</span><span class="section_title">The temptation is strong</span></h3>
<p>The temptation to ditch types is <em>strong</em>.</p>
<p>Untagged unions are trivial in HWOT. We can write this in HWOT but not Haskell:</p>
<pre class="example"><code>-- is_list :: a -&gt; Bool
is_list [] = True
is_list (_:_) = True
is_list _ = False

-- size :: List a + Tree b -&gt; Integer
size [] = 0
size (_:x) = 1 + size x
size Leaf = 0
size (Node _ lef rig) = size lef + size rig

-- my_list :: [Integer + String]
my_list = [1, 2, &quot;three&quot;]
</code></pre>
<p>Open functions (functions defined in several modules) are also trivial in HWOT.</p>
<p>Overloading and multimethods are trivial if constructors are namespaced.</p>
<pre class="example"><code>fun ModA.Con = 0
fun ModB.Con = 1
</code></pre>
<p>We can make a function argument optional backward-compatibly. We can monkey-patch our programs, although this may lead to maintenance hell.</p>
<pre class="example"><code>-- We have a function f : [a] -&gt; Int.W

f [] = 0
f _ = 1

-- Now we want to make the argument optional.

-- We simply write this somewhere else.
-- This doesn&#39;t even have to be in the same file that defines the original f.

f Nothing = 0
f (Just x) = f x
</code></pre>
<p>We can even write rewrite rules like GHC rewrite rules for stream fusion. The head of a pattern does not have to be a &quot;constructor&quot;.</p>
<pre class="example"><code>map f (map g x) = map (f . g) x
</code></pre>
<p>Data-type-a-la-carte become much shorter. No need for pattern synonyms. Parsing, location, trees-that-grow, everything becomes much shorter.</p>
<pre class="example"><code>eval (Add x y) = eval x + eval y

-- define in other file

eval (Neg x) = - x

-- data Loc a = MkLoc FilePath Int Int a
-- parse :: String -&gt; Loc Exp

-- Simply add this anywhere.
eval (MkLoc _ _ _ e) = eval e
</code></pre>
<p>Unsolved problems: type classes.</p>
<p>Type classes are replaced with implicit first arguments?</p>
<p>Higher-order patterns may be too much to handle. They may break confluence<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.</p>
<pre class="example"><code>\forall f x . f (Just x) = f x
</code></pre>
<p><code>1 + &quot;a&quot;</code> is not an error; it is a <em>value</em> that reduces to itself.</p>
<p><code>1 / 0</code> is not an error; it is a <em>value</em> that reduces to itself.</p>
<p>If <code>f</code> is a &quot;partial&quot; function and <code>f x</code> is &quot;undefined&quot;, then <code>f x</code> is not an error; it is a <em>value</em> that reduces to itself.</p>
<p>I think that type systems should be <em>separate</em> from languages (that is, type systems should be Curry-style, not Church-style; that is, Erlang-Dialyzer-style, not Haskell-style). Users should be able to write their own type systems. But even an interpreter has an implicit type system.</p>
<h3 id="compiling-hwot-to-haskell"><span class="section_number">2.2</span><span class="section_title">Compiling HWOT to Haskell?</span></h3>
<ol>
<li>Write &quot;crazy&quot; programs in HWOT.</li>
<li>Translate it to Haskell.</li>
<li>???</li>
<li>PROFIT</li>
</ol>
<h2 id="a-set-theoretic-programming-language"><span class="section_number">3</span><span class="section_title">A set-theoretic programming language?</span></h2>
<p>(A mess. Do not see.)</p>
<p>Titles?</p>
<ul>
<li>Lambda-calculus with functors and monads</li>
<li>Lambda-calculus with built-in functors and monads</li>
<li>Restricted set theory instead of type theory?</li>
</ul>
<p>To-do:</p>
<ul>
<li>How is this language better than Haskell?</li>
<li>How is this language worse than Haskell?</li>
<li>Proof-of-concept implementation (interpreter from the semantic equations)</li>
</ul>
<p>The key idea is to involve functors and monads in the denotational semantics of the language.</p>
<p>The type theory is a restricted set theory whose membership-check is practical.</p>
<p>We define a programming language. The idea seems very similar to SETL<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a><a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<p>We begin with lambda calculus, and we add strings, sets, sequences, and builtins.</p>
<p>TODO switch to logical structure formalism <span class="math inline">\((D,I,f_1^{m_1},\ldots,R_1^{n_1},\ldots)\)</span>?</p>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.1</span><span class="section_title"><a href="#the-universe-of-values-the-domain-of-discourse">The universe of values, the domain of discourse</a></span><span class="word_count">(63w~1m)</span></li>
<li><span class="section_number">3.2</span><span class="section_title"><a href="#the-abstract-syntax-and-semantics">The abstract syntax and semantics</a></span><span class="word_count">(559w~3m)</span></li>
<li><span class="section_number">3.3</span><span class="section_title"><a href="#the-concrete-syntax">The concrete syntax</a></span><span class="word_count">(19w~1m)</span></li>
<li><span class="section_number">3.4</span><span class="section_title"><a href="#motivation-monads-in-set-theoretic-lambda-calculus">Motivation: Monads in set-theoretic lambda-calculus?</a></span><span class="word_count">(189w~1m)</span></li>
</ul>
</div>
<h3 id="the-universe-of-values-the-domain-of-discourse"><span class="section_number">3.1</span><span class="section_title">The universe of values, the domain of discourse</span></h3>
<p>The universe (the domain of discourse) is <span class="math inline">\(D\)</span>.</p>
<ul>
<li>If <span class="math inline">\(x\)</span> is a string, then <span class="math inline">\(x \in D\)</span>.</li>
<li>If <span class="math inline">\(x\)</span> is a set, then <span class="math inline">\(x \in D\)</span>.</li>
<li>If <span class="math inline">\(x\)</span> is a sequence, then <span class="math inline">\(x \in D\)</span>.</li>
</ul>
<p>A relation is a sequence (domain,codomain,subset) of length three. A lambda abstraction expression is an expression, not a function.</p>
<p>Some axioms:</p>
<span class="math display">\[\begin{align*}
\forall A \quad D \cup A = D
\end{align*}
\]</span>
<p><span class="math inline">\(
\newcommand\semantics[1]{\langle #1 \rangle}
\newcommand\bigsemantics[1]{S\left(#1\right)}
\newcommand\universe{\Omega}
\)</span></p>
<h3 id="the-abstract-syntax-and-semantics"><span class="section_number">3.2</span><span class="section_title">The abstract syntax and semantics</span></h3>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">3.2.1</span><span class="section_title"><a href="#summary-of-the-semantics-of-the-programming-languages-abstract-syntax">Summary of the semantics of the programming language's abstract syntax</a></span><span class="word_count">(343w~2m)</span></li>
<li><span class="section_number">3.2.2</span><span class="section_title"><a href="#what">What?</a></span><span class="word_count">(31w~1m)</span></li>
<li><span class="section_number">3.2.3</span><span class="section_title"><a href="#literal-expressions">Literal expressions</a></span><span class="word_count">(16w~1m)</span></li>
<li><span class="section_number">3.2.4</span><span class="section_title"><a href="#lambda-expressions">Lambda expressions</a></span><span class="word_count">(79w~1m)</span></li>
<li><span class="section_number">3.2.5</span><span class="section_title"><a href="#set-expressions">Set expressions</a></span><span class="word_count">(39w~1m)</span></li>
<li><span class="section_number">3.2.6</span><span class="section_title"><a href="#sequence-expressions">Sequence expressions</a></span><span class="word_count">(45w~1m)</span></li>
<li><span class="section_number">3.2.7</span><span class="section_title"><a href="#logical-expressions">Logical expressions</a></span><span class="word_count">(2w~1m)</span></li>
<li><span class="section_number">3.2.8</span><span class="section_title"><a href="#builtins">Builtins</a></span><span class="word_count">(7w~1m)</span></li>
</ul>
</div>
<h4 id="summary-of-the-semantics-of-the-programming-languages-abstract-syntax"><span class="section_number">3.2.1</span><span class="section_title">Summary of the semantics of the programming language's abstract syntax</span></h4>
<p>Notations:</p>
<span class="math display">\[\begin{align*}
F(X,Y) &amp;= (F(X))(Y) &amp; \text{currying}
\\ A \to B \to C &amp;= A \to (B \to C)
\\ [D,C,F]x &amp;= y \text{ such that } (x,y) \in F &amp; \text{function application}
\\ B[P := X] &amp;= \text{\(B\) with each free \(P\) replaced with \(X\)} &amp; \text{substitution}
\end{align*}
\]</span>
<p>Laws:</p>
<span class="math display">\[\begin{align*}
\\ (A \cup B) \cup C &amp;= A \cup (B \cup C) &amp; \text{associativity of set union}
\\ (A \times B) \times C &amp;= A \times (B \times C) &amp; \text{associativity of Cartesian product}
\\ \universe \to \universe &amp;\subset \universe
\end{align*}
\]</span>
<p>The trivial stuffs:</p>
<span class="math display">\[\begin{align*}
\semantics{\{\}} &amp;= \{\} &amp; \text{empty set}
\\ \semantics{\universe} &amp;= \universe &amp; \text{universe}
\\ \semantics{\{A\}} &amp;= \{ \semantics{A} \} &amp; \text{singleton set}
\\ \semantics{A \cup B} &amp;= \semantics{A} \cup \semantics{B} &amp; \text{set union}
\\ \semantics{A \times B} &amp;= \semantics{A} \times \semantics{B} &amp; \text{Cartesian product}
\\ \semantics{[]} &amp;= [] &amp; \text{empty sequence}
\\ \semantics{[A]} &amp;= [\semantics{A}] &amp; \text{singleton sequence}
\\ \semantics{cons(A,B)} &amp;= cons(\semantics{A},\semantics{B}) &amp; \text{sequence construction}
\\ \semantics{uncons(F,G,L)} &amp;= uncons(\semantics{F},\semantics{G},\semantics{L}) &amp; \text{sequence deconstruction}
\\ \semantics{concat(A,B)} &amp;= concat(\semantics{A},\semantics{B}) &amp; \text{sequence concatenation}
\\ \semantics{N} &amp;= parsenumeral(N) &amp; \text{numeral (numeric literal)}
\end{align*}
\]</span>
<p>Lambda-calculus semantics:</p>
<span class="math display">\[\begin{align*}
\semantics{P \mapsto B} &amp;= [\universe,\universe,\{(x,\semantics{B[P:=x]}) ~|~ x \in \universe \}] &amp; \text{lambda abstraction}
\\ \semantics{F(X)} &amp;= (\semantics{F})(\semantics{X}) &amp; \text{function application}
\end{align*}
\]</span>
<p>Function spaces:</p>
<span class="math display">\[\begin{align*}
\semantics{A \to B} &amp;= \{ [\semantics{A},\semantics{B},F] ~|~ F \subseteq \semantics{A} \times \semantics{B}, ~ F \text{ is functional} \}
\\ F \text{ is functional} &amp;\equiv \forall x \forall y \forall z (F(x,y) \wedge F(x,z) \to y=z)
\end{align*}
\]</span>
<p>We extend the notion of &quot;application&quot; from functions to also include functors, in the type level. If <span class="math inline">\(f : A \to B\)</span>, <span class="math inline">\(x : F(A)\)</span>, and <span class="math inline">\(F = functor(M,m)\)</span>, then <span class="math inline">\(x : M(A)\)</span> and <span class="math inline">\( \semantics{f(x)} = \semantics{m(f,x)} \)</span>.</p>
<p>The expression <span class="math inline">\(x:T\)</span> is the same as <span class="math inline">\(x\)</span> but also asserts <span class="math inline">\(x \in T\)</span> to the domain-checker.</p>
<p>A <em>triple</em> is <span class="math inline">\((D,C,S)\)</span>. Such triple can be thought as a relaxed/generalized/improper <em>relation</em>. If <span class="math inline">\(S\)</span> is functional, then the triple is a function. Such function is <em>partial</em> iff <span class="math inline">\(\exists x \exists y : D(x) \wedge \neg S(x,y)\)</span>. Such function is <em>deceptive</em> iff <span class="math inline">\(\exists x \exists y : \neg C(y) \wedge S(x,y)\)</span>.</p>
<span class="math display">\[\begin{align*}
\exists x \in D (\neg \exists y S(x,y)) &amp;&amp; \text{partial}
\\ \exists y \not \in C (\exists x S(x,y)) &amp;&amp; \text{deceptive}
\\ \exists x \not \in D (\exists y S(x,y)) &amp;&amp; \text{superfluous}
\end{align*}
\]</span>
<p>A superfluous function has unnecessary mapping.</p>
<p>If each of <span class="math inline">\(D,C,S\)</span> is finite, it is straightforward to check a function application.</p>
<pre class="example"><code>extend [D, Maybe C, F] = [
    Maybe D,
    Maybe C,
    F \union { [Nothing, Nothing] }
]

extend [D, Risky E C, F] = [
    Risky E D,
    Risky E C,
    F \union { [Left, e] | e \in E }
]
</code></pre>
<p>We replace subtyping with subsetting.</p>
<p>Because <span class="math inline">\(A \subseteq Maybe(A)\)</span>, each element of <span class="math inline">\(A\)</span> can be passed to a function whose domain is <span class="math inline">\(Maybe(A)\)</span>.</p>
<p>Superfluous functions are harmless if we do domain check at each function application.</p>
<p>In this programming language, every functor is an endofunctor of Set. Such functor is <span class="math inline">\((F,m)\)</span> where <span class="math inline">\(F : Set \to Set\)</span> and <span class="math inline">\(m : \forall A \forall B . (A \to B) \to (FA \to FB)\)</span> such that <span class="math inline">\(m(id) = id\)</span> and <span class="math inline">\(m(f \circ g) = m(f) \circ m(g)\)</span>.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
<p>In this programming language, two endofunctors <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span> are <em>adjoint</em> iff there is an isomorphism (bijection) between <span class="math inline">\(FY \to X\)</span> and <span class="math inline">\(Y \to GX\)</span>, for all two sets <span class="math inline">\(X,Y\)</span>. It seems that adjunctions don't work with endofunctors: we would have to find mutually inverse functions <span class="math inline">\(p : \forall X \forall Y . FY \to X\)</span> and <span class="math inline">\(q : \forall X \forall Y . Y \to GX\)</span>.</p>
<p>A <em>natural transformation from endofunctor <span class="math inline">\(F\)</span> to endofunctor <span class="math inline">\(G\)</span></em> is a function <span class="math inline">\(\eta : \Pi \alpha . F(\alpha) \to G(\alpha)\)</span> such that <span class="math inline">\(\eta(Y) \circ \mu_F(f) = \mu_G(f) \circ \eta(X)\)</span> for every <span class="math inline">\(f : A \to B\)</span>. An example is <span class="math inline">\( \eta(a) : risky(e,a) \to maybe(a) \)</span>. What?<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<pre class="example"><code>class (Functor f, Functor g) =&gt; NaturalTransformation f g where
    eta :: f a -&gt; g a -- where eta . fmap f = fmap f . eta

class NatTrans f g where
    eta :: f -&gt; g

instance NaturalTransformation Identity Maybe where
    eta (Identity x) = Just x

instance NaturalTransformation (Either e) Maybe where
    eta (Left _) = Nothing
    eta (Right x) = Just x

instance (Monoid e) =&gt; NaturalTransformation Maybe (Either e) where
    eta (Just x) = Right x
    eta Nothing = mempty
</code></pre>
<p>A monad is <span class="math inline">\((F,m)\)</span> where <span class="math inline">\(FFX = FX\)</span>. An example monad is <span class="math inline">\(F(X) = 2^X\)</span> (power set-ing).</p>
<h4 id="what"><span class="section_number">3.2.2</span><span class="section_title">What?</span></h4>
<p>We write <span class="math inline">\(M(A)\)</span> or <span class="math inline">\(MA\)</span> to mean &quot;the meaning of <span class="math inline">\(A\)</span>&quot;. <span class="math inline">\(M\)</span> is not a function; it is just a notation. The meaning depends on context. The context contains name bindings.</p>
<h4 id="literal-expressions"><span class="section_number">3.2.3</span><span class="section_title">Literal expressions</span></h4>
<p>The <em>universe literal expression</em> <code>\universe</code> means <span class="math inline">\(D\)</span>.</p>
<p>A <em>string literal expression</em> <code>\string what</code> means <code>what</code> itself.</p>
<h4 id="lambda-expressions"><span class="section_number">3.2.4</span><span class="section_title">Lambda expressions</span></h4>
<p>A <em>lambda abstraction expression</em> <code>\lambda a b</code> means a subset of <span class="math inline">\(D \times D\)</span> according to beta-reduction. Thus, if <span class="math inline">\(L\)</span> is such expression, then <span class="math inline">\(M(L)\)</span> is not a function, but <span class="math inline">\((A,B,M(L))\)</span> is a function if it domain-checks.</p>
<p>An <em>application expression</em> <code>\app f x</code> means <span class="math inline">\((Mf)(Mx)\)</span>. Every application expression is <em>domain-checked</em>. <span class="math inline">\(Mf\)</span> has to be a function (a triple).</p>
<p>A <em>substituting expression</em> <code>\subst name</code> means the meaning of that name as bound by the nearest lambda abstraction that bounds that name.</p>
<h4 id="set-expressions"><span class="section_number">3.2.5</span><span class="section_title">Set expressions</span></h4>
<p>A <em>set expression</em> <code>\set a b c ...</code> means the set <span class="math inline">\(\{M(a),M(b),M(c),\ldots\}\)</span>.</p>
<p>A <em>set union expression</em> <code>\union A B ...</code> means <span class="math inline">\(M(A) \cup M(B) \cup \ldots\)</span>.</p>
<p>A <em>Cartesian product expression</em> <code>\times A B ...</code> means <span class="math inline">\(M(A) \times M(B) \times \ldots\)</span>.</p>
<h4 id="sequence-expressions"><span class="section_number">3.2.6</span><span class="section_title">Sequence expressions</span></h4>
<p>A <em>sequence expression</em> <code>\seq a b c ...</code> means <span class="math inline">\([M(a),M(b),M(c),\ldots]\)</span>.</p>
<p>A <em>sequence concatenation expression</em> <code>\concat a b c ...</code> means <span class="math inline">\(M(a)+M(b)+M(c)+\ldots\)</span> where <span class="math inline">\(+\)</span> is sequence concatenation.</p>
<p>A <em>sequence projection expression</em> <code>\project n s</code> means <span class="math inline">\(\pi_n M(s)\)</span> (the <span class="math inline">\(n\)</span>th component of <span class="math inline">\(M(s)\)</span>) where <span class="math inline">\(n\)</span> starts from one.</p>
<h4 id="logical-expressions"><span class="section_number">3.2.7</span><span class="section_title">Logical expressions</span></h4>
<p><code>\member</code></p>
<p><code>\and</code></p>
<p><code>\or</code></p>
<h4 id="builtins"><span class="section_number">3.2.8</span><span class="section_title">Builtins</span></h4>
<p><code>\println</code> for testing purposes only.</p>
<p><code>\procedural</code> executes sequentially.</p>
<pre class="example"><code>(\procedural
  (\println 1)
  (\println [2 3 4])
  (\println {5 6 7})
)
</code></pre>
<h3 id="the-concrete-syntax"><span class="section_number">3.3</span><span class="section_title">The concrete syntax</span></h3>
<p>Convenience concrete syntax:</p>
<ul>
<li><code>\let name = what in exp</code> means <code>(\ name -&gt; exp) what</code></li>
<li><code>\with</code> means chained <code>\let</code></li>
</ul>
<h3 id="motivation-monads-in-set-theoretic-lambda-calculus"><span class="section_number">3.4</span><span class="section_title">Motivation: Monads in set-theoretic lambda-calculus?</span></h3>
<p>We want <span class="math inline">\(Maybe(A) = A \cup \{Nothing\}\)</span> for each set <span class="math inline">\(A\)</span>. It follows from that definition that:</p>
<span class="math display">\[\begin{align*}
A &amp;\subseteq Maybe(A)
\\ Maybe(Maybe(A)) &amp;= Maybe(A)
\end{align*}
\]</span>
<p>We want <span class="math inline">\(Risky(A,B) = \{ (Fail,a) ~|~ a \in A \} \cup B\)</span> for each set <span class="math inline">\(A\)</span> and each set <span class="math inline">\(B\)</span>. It follows from that definition that:</p>
<span class="math display">\[\begin{align*}
B &amp;\subseteq Risky(A,B)
\\ Risky(A,Risky(A,B)) &amp;= Risky(A,B)
\end{align*}
\]</span>
<p>Thus <span class="math inline">\(Maybe : D \to D\)</span> and <span class="math inline">\(Risky : D \to D \to D\)</span>.</p>
<p>Risky is similar to Haskell Either, but the name &quot;Risky&quot; makes it clear that the parameters are not interchangeable.</p>
<pre class="example"><code>(\with
  ( A {0 1}
    B {0 1}
    Maybe [\universe \universe (\ a (\union $a {Nothing}))]
    F [$A $B {[0 1] [1 0]}]
    G [($Maybe $A)
      (\union $B {none})
      (\union (\mapping $F) {[Nothing none]})]
  )
  (\and ($F 0 1) ($F 1 0))
)
</code></pre>
<p>A <em>relation</em> is a triple <span class="math inline">\((A,B,R)\)</span> where <span class="math inline">\(R \subseteq A \times B\)</span>. We write <span class="math inline">\(R(x,y)\)</span> to mean <span class="math inline">\((x,y) \in R\)</span>.</p>
<p><span class="math inline">\((A,B,R)\)</span> is a <em>subrelation</em> of <span class="math inline">\((A&#39;,B&#39;,R&#39;)\)</span> iff <span class="math inline">\(A \subseteq A&#39;\)</span>, <span class="math inline">\(B \subseteq B&#39;\)</span>, <span class="math inline">\(R \subseteq R&#39;\)</span>, and <span class="math inline">\(R&#39; \subseteq A&#39; \times B&#39;\)</span>.</p>
<p>A <em>monad</em> (in the category of sets) is <span class="math inline">\((M,r,j)\)</span> where <span class="math inline">\(M : \Omega \to \Omega\)</span>, <span class="math inline">\(r : \forall A . A \to M(A)\)</span>, <span class="math inline">\(\forall X : M(M(X)) = M(X)\)</span>.</p>
<p>A monad maps each relation <span class="math inline">\((A,B,R)\)</span> to <span class="math inline">\((MA,MB,LR)\)</span> where <span class="math inline">\(A \subseteq MA\)</span>, <span class="math inline">\(R \subseteq LR\)</span>, <span class="math inline">\(p : A \to MA\)</span>, <span class="math inline">\(j : MMA \to MA\)</span>.</p>
<p>If a hole expects an element of <span class="math inline">\(A\)</span>, then it accepts an element of <span class="math inline">\(A&#39; \subseteq A\)</span>.</p>
<p>Abdullah's law of continuity:</p>
<pre class="example"><code>extend return = id

extend : (a -&gt; m b) -&gt; (m a -&gt; m b)
return :          a -&gt; m a
id     :        m a -&gt; m a
</code></pre>
<h2 id="a-mess-do-not-see"><span class="section_number">4</span><span class="section_title">A mess; do not see</span></h2>
<div class="local_table_of_contents">
<ul>
<li><span class="section_number">4.1</span><span class="section_title"><a href="#open-adts-algebraic-data-types">Open ADTs (algebraic data types)</a></span><span class="word_count">(46w~1m)</span></li>
<li><span class="section_number">4.2</span><span class="section_title"><a href="#can-we-extend-haskell-to-auto-fmap">Can we extend Haskell to &quot;auto-fmap&quot;?</a></span><span class="word_count">(269w~2m)</span></li>
<li><span class="section_number">4.3</span><span class="section_title"><a href="#auto-lifting-and-therefore-sequencing-of-function-application-involving-monad-instances">Auto-lifting (and therefore sequencing) of function application involving Monad instances</a></span><span class="word_count">(176w~1m)</span></li>
<li><span class="section_number">4.4</span><span class="section_title"><a href="#equirecursive-types">Equirecursive types?</a></span><span class="word_count">(35w~1m)</span></li>
<li><span class="section_number">4.5</span><span class="section_title"><a href="#bootstrap-ghc">&lt;2018-12-15&gt; Bootstrap GHC?</a></span><span class="word_count">(85w~1m)</span></li>
</ul>
</div>
<h3 id="open-adts-algebraic-data-types"><span class="section_number">4.1</span><span class="section_title">Open ADTs (algebraic data types)</span></h3>
<ul>
<li>&quot;Closed&quot; means &quot;defined in one place&quot;.</li>
<li><p>Open ADTs don't mix with exhaustive case analysis (function totality).</p>
<ul>
<li><a href="https://stackoverflow.com/questions/870919/why-are-haskell-algebraic-data-types-closed">https://stackoverflow.com/questions/870919/why-are-haskell-algebraic-data-types-closed</a></li>
<li><p>But what if functions are &quot;open&quot; too?</p>
<ul>
<li><a href="https://www.andres-loeh.de/OpenDatatypes.pdf">https://www.andres-loeh.de/OpenDatatypes.pdf</a></li>
</ul></li>
</ul></li>
<li><p>If <code>f : a -&gt; b</code>, then the compiler should infer <code>lift f : (Monad m) =&gt; m a -&gt; m b</code>.</p></li>
</ul>
<h3 id="can-we-extend-haskell-to-auto-fmap"><span class="section_number">4.2</span><span class="section_title">Can we extend Haskell to &quot;auto-fmap&quot;?</span></h3>
<ul>
<li><p>Possibilities:</p>
<ul>
<li>Add rewrite rules so that the compiler &quot;recovers&quot; from some type &quot;errors&quot;.</li>
<li>Extend the syntax and semantics of function application.</li>
</ul></li>
<li><p>Related</p>
<ul>
<li>1989, article, Wadler, &quot;Theorems for free!&quot;</li>
<li>The Haskell Djinn can, given a type T, infer/construct a term having type T.</li>
</ul></li>
<li><p>Recovering from some type errors</p>
<ul>
<li><p>Idea</p>
<ul>
<li>Extend Haskell with &quot;implicit injections&quot;.</li>
<li><p>The compiler should try in-scope injections automatically when there is a typing error, before quitting with a type error.</p>
<ul>
<li><p>Isn't this similar to Scala implicits and implicit conversion?</p>
<ul>
<li>I forgot who, but I think somebody on the Internet said that Scala implicits are a way for the compiler to recover from type errors.</li>
</ul></li>
</ul></li>
<li><p>Can we do this on GHC?</p>
<ul>
<li><p><a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/TypeChecker">https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/TypeChecker</a></p>
<ul>
<li>GHC typechecker works on Haskell before it's transformed to Core.</li>
</ul></li>
<li><p>Write a plugin for GHC?</p>
<ul>
<li>Can a GHC modify the syntax tree on type error?</li>
</ul></li>
<li>Use GHC as library?</li>
<li><p>We can't use GHC rewrite rules because they are only applied when optimization is enabled.</p></li>
</ul></li>
</ul></li>
<li>Define the concept of &quot;expected type&quot;.</li>
<li>Let <code>e</code> be an expression.</li>
<li>Let <code>f : a -&gt; b</code>.</li>
<li>Let <code>m</code> be an instance of Monad.</li>
<li>If <code>e</code> has type <code>a</code>, but the compiler expects <code>e</code> to have type <code>m a</code>, then the compiler shall rewrite <code>e</code> to <code>return e</code>.</li>
<li><p>If <code>e</code> has type <code>m a</code>, then the compiler rewrites <code>f e</code> to <code>map f e</code>.</p></li>
</ul></li>
<li>If <code>x</code> is a Monad, then these are two <em>different</em> things: <code>x : a</code> and <code>return x</code>, but they are related, in the sense that they are equivalent, in the sense that one is trivially computable/derivable from the other.</li>
<li><p>Can Strathclyde Haskell Enhancement (SHE) do this?</p>
<ul>
<li><p>It has idiom brackets. It translates <code>(| f a1 ... an |)</code> to <code>pure f &lt;*&gt; a1 &lt;*&gt; ... &lt;*&gt; an</code>.</p>
<ul>
<li><a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html">https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html</a></li>
</ul></li>
<li><p>Enhancement to SHE <a href="https://github.com/bezirg/she">https://github.com/bezirg/she</a></p>
<ul>
<li><a href="http://blog.bezirg.net/posts/2013-08-03-enhancement-to-the-strathclyde-haskell-enhancement.html">http://blog.bezirg.net/posts/2013-08-03-enhancement-to-the-strathclyde-haskell-enhancement.html</a></li>
</ul></li>
</ul></li>
<li><p><a href="https://en.wikipedia.org/wiki/Bidirectional_transformation">https://en.wikipedia.org/wiki/Bidirectional_transformation</a></p>
<ul>
<li><a href="https://www.cis.upenn.edu/~bcpierce/papers/lenses-etapsslides.pdf">https://www.cis.upenn.edu/~bcpierce/papers/lenses-etapsslides.pdf</a></li>
</ul></li>
</ul>
<h3 id="auto-lifting-and-therefore-sequencing-of-function-application-involving-monad-instances"><span class="section_number">4.3</span><span class="section_title">Auto-lifting (and therefore sequencing) of function application involving Monad instances</span></h3>
<ul>
<li><p>The standard rule is:</p>
<ul>
<li>If <code>x : a</code> and <code>f : a -&gt; b</code>, then <code>f x : b</code>.</li>
</ul></li>
<li><p>Suppose that <code>m</code> has a Monad instance.</p>
<ul>
<li><p>If <code>x : m a</code> and <code>f : a -&gt; b</code>, then should the compiler silently translate <code>f x</code> to <code>x &gt;&gt;</code> return . f=?</p>
<ul>
<li><p>Isn't it the only desirable way of putting together <code>f</code> and <code>x</code>?</p>
<ul>
<li><p>Monad class requires that <code>x &gt;&gt;</code> return . f= be equivalent to <code>fmap f x</code>.</p>
<ul>
<li>So there is really only one way to do it, isn't it?</li>
</ul></li>
<li><p>Examples of non-desirable ways: <code>unsafeCoerce</code>, <code>undefined</code>.</p></li>
</ul></li>
</ul></li>
<li><p>Should the compiler also appropriately translate <code>f x</code> for all these combinations?</p>
<ul>
<li><p>Possibilities for the type of <code>x</code>:</p>
<ul>
<li><code>a</code></li>
<li><code>m a</code></li>
</ul></li>
<li><p>Possibilities for the type of <code>f</code>:</p>
<ul>
<li><code>a -&gt; b</code></li>
<li><code>a -&gt; m b</code></li>
<li><code>m (a -&gt; b)</code></li>
<li><code>m a -&gt; m b</code></li>
<li><code>m a -&gt; b</code></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>At first glance it seems convenient, but what are the consequences?</p>
<ul>
<li><p>Some I can think of</p>
<ul>
<li><p>Confusing error message</p>
<ul>
<li><p>Suppose:</p>
<ul>
<li>The programmer makes a typing mistake.</li>
<li>The compiler infers the wrong type.</li>
<li>The compiler performs translation based on the wrongly inferred type.</li>
<li>The compiler produces a confusing error message.</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="equirecursive-types"><span class="section_number">4.4</span><span class="section_title">Equirecursive types?</span></h3>
<p>Haskell has isorecursive types. Can we make it use equirecursive types?</p>
<ul>
<li>Can we make it automatically insert roll-unroll/fold-unfold/In-out?</li>
<li><p>How do we compose monads seamlessly?</p>
<ul>
<li>Isorecursive types?</li>
<li>True sum types (untagged unions)?</li>
</ul></li>
<li>&quot;System F-omega with Equirecursive Types for Datatype-Generic Programming&quot;?</li>
</ul>
<h3 id="bootstrap-ghc"><span class="section_number">4.5</span><span class="section_title">&lt;2018-12-15&gt; Bootstrap GHC?</span></h3>
<p><a href="https://twitter.com/ErikDominikus/status/1073726987338842112">https://twitter.com/ErikDominikus/status/1073726987338842112</a></p>
<p>How about writing a Haskell interpreter with Prolog? I guess Haskell type checker takes ~100 lines of Prolog, and parser takes ~200 lines. It may be doable in a month. I have ~20 lines of Prolog type-checking Haskell AST but without type classes.</p>
<p>Add ~500 more lines of Prolog metaprogram for translating lists to arrays, ~2000 more lines for translating Prolog to optimized x86_64 native code (if not reinventing LLVM), 1 more month, and … we may beat GHC at its own game? :)</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Pure_(programming_language)">https://en.wikipedia.org/wiki/Pure_(programming_language)</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><a href="https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)">https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)</a><a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p><a href="https://en.wikipedia.org/wiki/SETL">https://en.wikipedia.org/wiki/SETL</a><a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><a href="https://en.wikipedia.org/wiki/Set_theoretic_programming">https://en.wikipedia.org/wiki/Set_theoretic_programming</a><a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p><a href="https://en.wikipedia.org/wiki/Functor">https://en.wikipedia.org/wiki/Functor</a><a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><a href="https://en.wikipedia.org/wiki/Natural_transformation">https://en.wikipedia.org/wiki/Natural_transformation</a><a href="#fnref6" class="footnote-back">↩</a></p></li>
</ol>
</section>
                </div>
            </div>
        </main>
                        <div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
var disqus_config = function () {
    this.page.url = "https://edom.github.io/haskell.html";  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = "https://edom.github.io/haskell.html"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://edom-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                        <footer class="site-footer h-card">
            <data class="u-url" href="/"></data>
            <div class="wrapper">
                <p>This page was created on 2018-07-22 02:45 +0700.</p>
                <p class="rss-subscribe">There is an
                    <a href="/feed.xml">RSS feed</a>, but it's unused because this site is a wiki, not a blog.</p>
                <p>Stop writing books, papers, and blogs!
                    Write a personal wiki instead!
                    Or, even better, contribute to a community wiki.
                </p>
            </div>
        </footer>
    </body>
</html>
