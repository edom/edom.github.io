<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Computational complexity</title>
  <meta name="description" content="Personal website">

  <link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700&amp;subset=latin-ext" rel="stylesheet">
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://edom.github.io/complexity.html">
  <link rel="alternate" type="application/rss+xml" title="Erik Dominikus&#39;s wiki" href="/feed.xml">

  

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-12628443-6', 'auto');
  ga('send', 'pageview');

</script>
  

  

  
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    jax: ["input/TeX","input/MathML","input/AsciiMath",

    "output/CommonHTML"

    ],
    extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "a11y/accessibility-menu.js"],
    TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
        , equationNumbers: {
            autoNumber: "AMS"
        }
    },
    "CommonHTML": {
        scale: 100
    },
    "fast-preview": {
        disabled: true,
    }
});
  </script>
  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js" async></script>
  
</head>


  <body>

    <header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Erik Dominikus&#39;s wiki</a>
  </div>
</header>


    
  <div style="display:none;">\(
\renewcommand\emptyset{\varnothing}
\newcommand\abs[1]{\left|#1\right|}
\newcommand\dom{\textrm{dom}}
\newcommand\cod{\textrm{cod}}
\newcommand\Bernoulli{\textrm{Bernoulli}}
\newcommand\Binomial{\textrm{Binomial}}
\newcommand\Expect[1]{\mathbb{E}[#1]}
\newcommand\Nat{\mathbb{N}}
\newcommand\Integers{\mathbb{Z}}
\newcommand\Real{\mathbb{R}}
\newcommand\Rational{\mathbb{Q}}
\newcommand\Complex{\mathbb{C}}
\newcommand\Pr{\mathrm{P}}
\newcommand\Time{\text{Time}}
\newcommand\DTime{\text{DTime}}
\newcommand\NTime{\text{NTime}}
\newcommand\TimeP{\text{P}}
\newcommand\TimeNP{\text{NP}}
\newcommand\TimeExp{\text{ExpTime}}
\newcommand\norm[1]{\left\lVert#1\right\rVert}
\newcommand\bbA{\mathbb{A}}
\newcommand\bbC{\mathbb{C}}
\newcommand\bbD{\mathbb{D}}
\newcommand\bbE{\mathbb{E}}
\newcommand\bbN{\mathbb{N}}
\newcommand\frakI{\mathfrak{I}}
% deprecated; use TimeExp
\newcommand\ExpTime{\text{ExpTime}}
\newcommand\Compute{\text{Compute}}
\newcommand\Search{\text{Search}}
% model theory structure
\newcommand\struc[1]{\mathcal{#1}}
  \)</div>
    

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Computational complexity</h1>
  </header>

  <div class="post-content">
    <ul>
  <li>world effort
    <ul>
      <li><a href="https://www.nada.kth.se/~viggo/wwwcompendium/wwwcompendium.html">A compendium of NP optimization problems</a>
        <ul>
          <li>Smallest equivalent something:
https://en.wikipedia.org/wiki/Skeleton_(category_theory)</li>
          <li>Minimum equivalent graph,
also called transitive reduction.
https://en.wikipedia.org/wiki/Transitive_reduction
https://www.nada.kth.se/~viggo/wwwcompendium/node49.html</li>
        </ul>
      </li>
      <li><a href="https://polymathprojects.org/2013/11/04/polymath9-pnp/">2013 Polymath project: Polymath 9: Discretized Borel Determinacy</a>
        <ul>
          <li>https://gowers.wordpress.com/2013/10/24/what-i-did-in-my-summer-holidays/</li>
          <li>https://gowers.wordpress.com/2013/11/03/dbd1-initial-post/</li>
        </ul>
      </li>
      <li>https://cstheory.stackexchange.com/questions/4090/ways-for-a-mathematician-to-stay-informed-of-current-research-in-complexity-theo</li>
    </ul>
  </li>
  <li>open access journals
    <ul>
      <li><a href="https://lmcs.episciences.org/browse/latest">Logical methods in computer science</a></li>
    </ul>
  </li>
  <li>recent publication trackers
    <ul>
      <li>arxiv list of recent submissions
        <ul>
          <li><a href="https://arxiv.org/list/cs/recent">computer science</a></li>
          <li><a href="https://arxiv.org/list/cs.CC/recent">computational complexity theory</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>NP-complete problems
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/List_of_NP-complete_problems">WP:List of NP-complete problems</a></li>
      <li>https://mathoverflow.net/questions/72628/number-theory-and-np-complete</li>
      <li>https://cstheory.stackexchange.com/questions/14124/is-there-a-natural-problem-on-the-naturals-that-is-np-complete</li>
    </ul>
  </li>
  <li>descriptive complexity theory
    <ul>
      <li>Immerman and Vardi shows that FO(LFP) corresponds with P.
        <ul>
          <li>What does a FO(LFP) formula look like?</li>
          <li><a href="http://michaelnielsen.org/polymath1/index.php?title=Immerman-Vardi_theorem">Immerman–Vardi theorem</a></li>
          <li><a href="https://complexityzoo.uwaterloo.ca/Complexity_Zoo:F#folfp">FO(LFP) on Complexity Zoo</a></li>
        </ul>
      </li>
      <li>Fagin (?) proved that NP = ESO (existential second-order logic).</li>
      <li>Immerman (?) proved that P = FO(LFP) (first-order logic with least fixed point).
        <ul>
          <li>Therefore, to prove that P does not equal NP,
  construct a sentence that is in ESO but not in FO(LFP).
            <ul>
              <li>Easier said than done?
                <ul>
                  <li>Learn finite model theory?
                    <ul>
                      <li><a href="https://logic.rwth-aachen.de/~graedel/yurifest.pdf">Erich Grädel and Martin Grohe, “Is polynomial time choiceless?”</a>.
  Choiceless polynomial time logic would imply \( \TimeP \neq \TimeNP \)?</li>
                      <li><a href="http://researcher.ibm.com/researcher/files/us-fagin/tcs93.pdf">Ronald Fagin’s perspective on finite model theory</a></li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>https://people.cs.umass.edu/~immerman/pub/ch0_1_2.pdf</li>
      <li><a href="http://www.gpwu.ac.jp/~satoru/lnlg05kuroda.pdf">Descriptive Complexity and Language-Theoretic Complexity</a>
  by Satoru Kuroda</li>
      <li><a href="https://people.cs.umass.edu/~immerman/pub/ExperimentalDC.pdf">Experimental descriptive complexity</a>
  by Neil Immerman et al</li>
      <li>http://arxiv.org/pdf/cs/0409039v11.pdf
  On Certain Modular Equations
  Marius Constantin Ionescu
        <ul>
          <li>is this valid?</li>
        </ul>
      </li>
      <li>http://mathworld.wolfram.com/Computation.html</li>
      <li>http://mathworld.wolfram.com/PrincipleofComputationalEquivalence.html</li>
      <li>http://mathworld.wolfram.com/ComputationalIrreducibility.html</li>
      <li>https://en.wikipedia.org/wiki/Algebraic_logic</li>
    </ul>
  </li>
  <li>http://blog.computationalcomplexity.org/2010/05/structure-or-lack-thereof-of-data.html</li>
  <li>Plan for the P vs NP problem?
    <ul>
      <li>Relate configuration graph and problem theory</li>
      <li>Unexplored ideas:
        <ul>
          <li>Machine is not computation.</li>
          <li>Machine <em>is</em> formal system.</li>
          <li>Computation <em>is</em> repeated function application.</li>
          <li><em>Under what conditions does nondeterminism give extra power?</em></li>
        </ul>
      </li>
      <li>Where is computation theory, computability theory, complexity theory now?</li>
    </ul>
  </li>
  <li>Complexity axioms
    <ul>
      <li>Blum’s?</li>
      <li>Here we axiomatize machine-independent <em>complexity</em>.</li>
      <li>Recall that a problem \( P \) is a subset of <span>\( X \times Y \)</span>.
  We posit, without referring to any model of computation,
  that every question \(x\) has a <em>complexity</em> \(m(x)\), usually a number.
  The function \( m \) is a <em>complexity measure</em> of \( P \) iff it satisfies the axioms below.</li>
      <li>For help, we define \( S(k) \)
  as the set of all questions with the same complexity \( k \),
  that is <span>\( S(k) = \{ x ~|~ m(x) = k \} \)</span>.
  Then, the <em>complexity axioms</em> are:
        <ul>
          <li>Every <span>\( S(k) \)</span> is finite.</li>
          <li>There are always more complex questions than less complex questions,
  because, for example, longer strings can encode more questions.
  Formally, if \( i &lt; j \) then <span>\( |S(i)| &lt; |S(j)| \)</span>.</li>
        </ul>
      </li>
      <li>Note that the complexity measure is \( m \), not \( S \).</li>
      <li>Computation graph axiom:
        <ul>
          <li>A machine can only manipulate one symbol at a time.
  Formally, if \( E(a,b) \) then <span>\( |m(a) - m(b)| \le 1 \)</span>.</li>
          <li>The out-degree of a vertex of a nondeterministic graph may exceed 1 but cannot exceed a constant.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Machine, algorithm, and complexity
    <ul>
      <li>The <a href="https://en.wikipedia.org/wiki/Worst-case_complexity#Definition">time complexity</a>
  of machine \(m\) for input \(x\) is \(t(m,x)\),
  the number of steps \(m\) makes between the beginning and the halting.
  The <em>worst-case time complexity</em> of \(m\) for input <em>size</em> \(n\) is
  <span>\(T(m,n) = \left\vert \max_{|x| = n} t(m,x) \right\vert\)</span>.
  We can also write asymptotic statements such as \(T(m,n) \in O(f(n))\).</li>
      <li>An algorithm \(a\) implies a machine \(m(a)\).</li>
      <li>An <em>algorithm</em> solves a <em>problem</em>.
  A problem can be solved by many algorithms with different resource usage characteristics.</li>
      <li>The what (?) time complexity class of a problem is the worst-case time complexity of the most efficient algorithm solving that problem.</li>
      <li>Machine <em>is</em> algorithm.</li>
      <li>A <em>machine</em> \(M\) is a <em>transition relation</em> \(T\)
  (an <em>acyclic</em> binary relation).
\[
T(x,y) = \text{\(M\) can state-transition from \(x\) to \(y\).}
\]</li>
      <li>\(M\) <em>computes</em> \(P\) iff
  a subgraph of the shortcut of \(T\) is isomorphic to \(P\).
  (If \(T\) were cyclic, this definition would fail.)</li>
      <li>Related:
  <a href="https://en.wikipedia.org/wiki/Graph_isomorphism">graph isomorphism</a>,
  <a href="https://en.wikipedia.org/wiki/Subgraph_isomorphism_problem">subgraph isomorphism problem</a>.</li>
      <li><em>Deterministic</em> machine equals <em>functional</em> relation.</li>
      <li>(G) \emph{accepts} (v) iff (F^\infty({v}) = \emptyset) where (F) is the graph’s fringe function.
  The \emph{language} recognized by (G) is the largest (L \subseteq V) such that (F^\infty(L) = \emptyset).</li>
      <li>A Turing machine is ((C,I,f))
  where (C) is countable
  and (f) is recursive.</li>
      <li>https://en.wikipedia.org/wiki/Register_machine</li>
      <li>Example: a state of a Turing machine is ((c,l,h,r))
  where (c) is a configuration,
  (l) is the tape content to the left of the head,
  (h) is the tape content at the head,
  and (r) is the tape content to the right of the head.</li>
      <li>A problem class is a function.</li>
      <li>A <em>problem</em> is a member of (S).</li>
      <li>A <em>problem class</em> is a subset of (S).</li>
      <li>Sometimes we can <em>reduce</em> a problem (p : P) into another problem (q : Q)
  by an injective reduction (r : P \to Q).</li>
    </ul>
  </li>
  <li>Space and time complexity
    <ul>
      <li>Can we deal with complexity without ever defining machine and computation
  (besides assuming they exist)?</li>
      <li>(\newcommand\ftime{\text{time}}
  \newcommand\fspace{\text{space}}
  \newcommand\fsize{\text{size}})We are interested at the number of steps
  a machine makes for an input before terminating.
  We define (\ftime~f~x) as the <em>running time</em>
  of the machine (f) for input (initial state) (x).</li>
      <li>We also define (\fsize~x) as the <em>size</em> of the state (x).</li>
      <li>(Concrete)
  Formally, (\ftime~f~x = n) iff (n) is the smallest natural number such that (f^{n+1}~x = f^n~x).</li>
      <li>We apply general algebraic thinking again, this time about congruences.
  Let (T~f~n = { x ~|~ \ftime~f~x = n } )
  be the set of all inputs that (f) handles in (n) steps.
  We can also let (U~n = { (f,x) ~|~ \ftime~f~x = n })?
  [
  \lambda f . \lambda n . { x ~|~ \ftime~f~x = n }
  <br />
  \lambda n . { (f,x) ~|~ \ftime~f~x = n }
  <br />
  \lambda m . \lambda n . { (f,x) ~|~ \fsize~x = m, ~ \ftime~f~x = n }
  ]</li>
      <li>We define (\fspace : M~S \to S \to \Nat),
  where (\fspace~f~x) is the size of the biggest state in ({ f^n~x ~|~ n \in \Nat }).</li>
      <li>The other option is to require that each machine (f) have a (t : S \to \Nat) where (t~(f~x) = 1 + t~x).</li>
    </ul>
  </li>
  <li>Complexity as an ordering of questions
    <ul>
      <li>Postulate:
  For every pair of questions, we can always decide which is more complex.
  Therefore, complexity is a <em>total ordering</em> of questions.
  We write \( x &lt; y \) iff \( x \) is less complex than \( y \).
  Then the complexity axioms are:
        <ul>
          <li>For each \( y \), there are finitely many \( x \) such that \( x \le y \).</li>
          <li>For each \( x \), there are infinitely many \( y \) such that \( x \le y \).
  (Is this required?)</li>
        </ul>
      </li>
      <li>A <em>reduction</em> \( r \) from problem \( P \) to problem \( Q \) is an order-preserving (but not necessarily order-reflecting) function
  that maps \( P \)-questions to \( Q \)-questions.
  Formally, for all \( x, y \in P \), if \( x \le y \) then \( r(x) \le r(y) \),
  but the converse does not need to hold.
  (Are we sure we don’t need order-reflecting?)</li>
      <li>Rabin complexity axioms?
  Still with the same \( m \) here.
  For help, let <span>\( L(k) = \{ x ~|~ m(x) \le k \} \)</span>
  be the set of all questions that are not more complex than \( k \).
  Then the axioms are:
        <ul>
          <li>Every \( L(k) \) is finite.</li>
          <li>For every \( i \), there exists \( j &gt; i \) such that \( L(i) \subset L(j) \).
  We say that \( L \) is <em>eventually increasing</em>.</li>
          <li>The limit of \( L(k) \) as \( k \) grows unbounded is \( X \), the set of all questions.</li>
          <li>(That is not what Rabin says? He uses Post canonical system and Curry-Howard correspondence?)</li>
        </ul>
      </li>
      <li>Corollary:
        <ul>
          <li>\( L \) is nondecreasing: If \( i &lt; j \) then \( L(i) \subseteq L(j) \).</li>
        </ul>
      </li>
      <li><a href="https://en.wikipedia.org/wiki/Order_theory">WP:Order theory</a></li>
    </ul>
  </li>
  <li>Articles
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">WP:Boolean satisfiability problem</a></li>
      <li><a href="http://www.dcs.gla.ac.uk/~pat/cpM/papers/cheeseman91where.pdf">Where the really hard problems are</a>, Cheeseman, Kanefsky, and Taylor,
        <ul>
          <li>“Almost all k-colorable graphs are easy to color”, J. S. Turner, 1988</li>
        </ul>
      </li>
      <li>Blum
        <ul>
          <li><a href="https://www.researchgate.net/profile/Juris_Hartmanis/publication/242506038_On_the_Computational_Complexity_of_Algorithms/links/53fcd0a40cf2364ccc04db1d.pdf">On the computational complexity of algorithms</a>, J. Hartmanis and R. E. Stearns, 1965</li>
        </ul>
      </li>
      <li><a href="http://www.sciencedirect.com/science/article/pii/0022000078900089">The complexity of total order structures</a>, Dan Moore, 1978</li>
    </ul>
  </li>
  <li>Books
    <ul>
      <li><a href="http://theory.cs.princeton.edu/complexity/">Computational Complexity: A Modern Approach, by Sanjeev Arora and Boaz Barak</a>, more than 400 pages, no finite model theory</li>
      <li><a href="http://cglab.ca/~michiel/TheoryOfComputation/TheoryOfComputation.pdf">Introduction to Theory of Computation, by Anil Maheshwari and Michiel Smid</a>, more than 200 pages</li>
    </ul>
  </li>
  <li><a href="http://port70.net/~nsz/articles/classic/blum_complexity_1976.pdf">Blum 1976 “a machine independent theory of the complexity of recursive functions”</a>, 15 pages
    <ul>
      <li><a href="https://www.cs.toronto.edu/~sacook/homepage/rabin_thesis.pdf">Michael O. Rabin’s 1960 technical report</a>
        <ul>
          <li><a href="https://cstheory.stackexchange.com/questions/34236/rabins-degree-of-difficulty-of-computing-a-function-and-a-partial-ordering-of">from cstheory stackexchange</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>https://en.wikipedia.org/wiki/Proof_complexity</li>
  <li>A question related to P vs NP
    <ul>
      <li>Proving lower bound is much harder than proving upper bound.</li>
      <li>Unsolved problem: How do we prove that an algorithm is the fastest solution of a problem?
  In order to prove that an algorithm is the fastest,
  it suffices us to prove that there is no faster algorithm for the same problem,
  but this is easier said than done.
        <ul>
          <li>https://cs.stackexchange.com/questions/38357/is-it-really-possible-to-prove-lower-bounds</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>https://en.wikipedia.org/wiki/Time_hierarchy_theorem</li>
  <li>https://en.wikipedia.org/wiki/Constructible_function</li>
  <li>Entertainment
    <ul>
      <li>http://beza1e1.tuxen.de/articles/accidentally_turing_complete.html</li>
    </ul>
  </li>
</ul>

  </div>

</article>

      </div>
    </main>

    
    
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
var disqus_config = function () {
    this.page.url = "https://edom.github.io/complexity.html";  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = "https://edom.github.io/complexity.html"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://edom-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    

    <footer class="site-footer h-card">
    <data class="u-url" href="/"></data>

    <div class="wrapper">
        <p>This page was created on 2017-06-29 18:30 +0700.</p>
        <p class="rss-subscribe">There is an <a href="/feed.xml">RSS feed</a>,
        but it's unused because this site is a wiki, not a blog.</p>
        <p>Stop writing books, papers, and blogs! Write a personal wiki instead! Or, even better, contribute to a community wiki.</p>
    </div>

</footer>


  </body>

</html>
